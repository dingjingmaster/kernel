# 程序类型

## 网路程序类型

## CGroup程序类型

## Tracing程序类型

### BPF_PROG_TYPE_KPROBE

`BPF_PROG_TYPE_KPROBE` 是可以附加到 Kprobes 的 eBPF 程序。Kprobes 并不是 eBPF 的特定功能，但它们确实能很好地协同工作。传统上，我们必须编写一个自定义的内核模块，该模块可以从 kprobe 中调用，或者仅满足于跟踪日志输出。

#### 使用

Kprobe 和 kretprobe 用于探测内核，uprobe 和 uretprobe 用于探测用户空间。普通探测会在被探测位置执行时调用。ret 变体将在函数返回时执行，以便捕获返回值。

usdt 探针是变相的 uprobe，它希望附加到用户空间程序中定义的跟踪点。详情请查看 USDT 概念页面。

所有这些探针类型都与 kprobe 程序类型协同工作，而附加方法决定了程序的执行方式。

#### 上下文

传递给 kprobe 程序的上下文是 `struct pt_regs`。由于该结构包含调用 kprobe 时 CPU 寄存器的副本，因此每个 CPU 架构的结构都不同。

kprobe 程序通常使用 Libbpf `bpf_tracing.h` 头文件中的宏，该文件定义了 `PT_REGS_PARM1` ... `PT_REGS_PARM5` 以及其他一些宏。这些宏将根据当前的体系结构转换到 `struct pt_regs` 中的正确字段。通过在程序中定义一个 `__TARGET_ARCH_*` 值，或在编译时通过命令行，就能传递编译 BPF 程序时所使用的体系结构。

同一头文件还提供了 `BPF_KPROBE(name,args...)`宏，允许程序作者以与跟踪函数相同的方式定义函数签名，并提供类型信息等所有信息。该宏将把正确的参数号转换为给定的参数名。例如：
```c
SEC("kprobe/proc_sys_write")
int BPF_KPROBE(my_kprobe_example,
           struct file* filp, const char* buf,
           size_t count, loff_t* ppos) {
    ...
}
```

用于附加到系统调用的 kprobes 也有类似的宏： `BPF_KSYSCALL(name, args...)` 和 kprobes: `BPF_KRETPROBE(name, args...)`

#### 连接

有两种附加探针程序的方法，上位机也有不同。传统 "方法是通过 DebugFS 手动创建 `k{ret}probe` 或 `u{ret}probe` 事件，然后通过 `perf_event_open` 系统调用将 BPF 程序附加到该事件。

新方法使用 BPF 链接来创建探针事件和附加多个探针。不过，单个探针仍可通过 `perf_event_open` 系统调用连接，但需要不同的参数，之后还需要使用 BPF 链接。

##### 传统的 kprobe 连接

第一步是创建 kprobe 或 kretprobe 跟踪事件。为此，我们可以使用 DebugFS，在本文档中，我们将假定 DebugFS 挂载在 /sys/kernel/debug。

通过打印 `/sys/kernel/debug/tracing/kprobe_events` 可以列出现有的 `kprobe` 事件。我们还可以通过写入这个伪文件来创建新事件。例如，执行 `echo 'p:myprobe do_sys_open' > /sys/kernel/debug/tracing/kprobe_events`，就会在内核的 `do_sys_open` 函数中创建一个名为 `myprobe` 的新 `kprobe (p:)`。有关完整语法的详细信息，请查看此链接。 kretprobe 是通过指定 r: 前缀创建的。

创建探针后，`/sys/kernel/debug/tracing/events/kprobes/`目录中将出现一个新目录，其名称与我们给探针起的相同，本例中为`/sys/kernel/debug/tracing/events/kprobes/myprobe`。该目录包含一些伪文件，对我们来说 id 很重要。`/sys/kernel/debug/tracing/events/kprobes/myprobe/id`的内容包含下一步需要的唯一标识符。

下一步是使用 `perf_event_open` 系统调用打开一个新的 perf 事件：

```c
struct perf_event_attr attr = {
    .type = PERF_TYPE_TRACEPOINT,
    .size = sizeof(struct perf_event_attr),
    .config = kprobe_id, /* The ID of your kprobe */
    .sample_period = 1,
    .sample_type = PERF_SAMPLE_RAW,
    .wakeup_events = 1,
};

syscall(SYS_perf_event_open,
    &attr,  /* struct perf_event_attr * */
    -1,     /* pid_t pid */
    0       /* int cpu */
    -1,     /* int group_fd */
    PERF_FLAG_FD_CLOEXEC /* unsigned long flags */
);
```
调用成功后将返回一个文件描述符。最后一步是调用两个 ioctl 系统调用，将 BPF 程序附加到 kprobe 事件并启用 kprobe。

`ioctl(perf_event_fd, PERF_EVENT_IOC_SET_BPF, bpf_prog_fd);` 附加。

`ioctl(perf_event_fd,PERF_EVENT_IOC_ENABLE,0)；`启用。

可以使用 `PERF_EVENT_IOC_DISABLE` ioctl 选项暂时禁用 `kprobe`。否则，在 `perf_event` FD 关闭或程序退出之前，kprobe 会一直连接在 `perf_event` 上。perf 事件持有对 BPF 程序的引用，因此它将一直被加载，直到不再有 kprobe 引用它为止。

##### 连接 kprobe

使用 BPF 系统调用的链接创建命令是更现代、更受欢迎的连接方式。对于单个探针，可使用 `perf_event_open` 系统调用打开一个新的 perf 事件。请注意，与传统方式相比，这里的 perf 事件结构属性值略有不同。
```c
 struct perf_event_attr attr = {
    .type = 8; /* read type from /sys/bus/event_source/devices/kprobe/type or uprobe/type */
    .sample_type = PERF_SAMPLE_RAW;
    .sample_period = 1;
    .wakeup_events = 1;
    .size = sizeof(attr);
    .config |= 1 << 0;
    .kprobe_func = ((uint64_t)"symbol_name");  /* symbol name in string, valid names can be found in /proc/kallsyms */
    .config1 = ((uint64_t)"symbol_name");
    .config2 = 0x0;
    .probe_offset = 0x0; /* offset must be a valid instruction, here it is just the start of the kernel symbol*/
};

syscall(SYS_perf_event_open,
    &attr,  /* struct perf_event_attr * */
    -1,     /* pid_t pid */
    0       /* int cpu */
    -1,     /* int group_fd */
    PERF_FLAG_FD_CLOEXEC /* unsigned long flags */
);
```

perf 事件系统调用成功后，返回的有效文件描述符可用于在调用链接创建命令前设置 bpf 结构中的 `link_create.target_fd` 属性。

```c
union bpf_attr attr = {
    .link_create.prog_fd = prog_fd; /* valid fd to bpf program of type KPROBE */
    .link_create.target_fd = perf_fd; /* valid fd to PMU event */
    .link_create.attach_type = BPF_PERF_EVENT;
    .link_create.flags = 0;
    .link_create.perf_event.bpf_cookie = 0;
};

syscall(SYS_bpf,
    BPF_LINK_CREATE,
    &attr,
    sizeof(attr)
);
```

对于多个探针，可以使用带有 `BPF_TRACE_KPROBE_MULTI` 预期附加类型的链接创建命令来合并探针的创建和链接。Fprobes 用于多个 kprobes。

```c
union bpf_attr attr = {
    .link_create.prog_fd = prog_fd;
    .link_create.attach_type = BPF_TRACE_KPROBE_MULTI;
    .link_create.kprobe_multi.cnt = sym_count;
    .link_create.kprobe_multi.cookies = 0;
    .link_create.kprobe_multi.flags = BPF_F_KPROBE_MULTI_RETURN;
    .link_create.kprobe_multi.syms = ((uint64_t)sym_name); /* char array of symbol names */
);

syscall(SYS_bpf,
    BPF_LINK_CREATE,
    &attr,
    sizeof(attr)
);
```

通过附件类型 `BPF_TRACE_KPROBE_SESSION`，可以附加到会话。在这种方法中，一个链接就能将 BPF 程序附加到函数入口和返回探针上。将入口探针和出口探针合并到一个会话附件中可简化整体代码结构和可维护性。传统上，许多工具（如 Tetragon 和 bpftrace）都会创建一个额外的入口探针，专门用于设置返回探针，但使用会话链接后，就省略了这个额外的执行过程。

```c
union bpf_attr attr = {
    .link_create.prog_fd = prog_fd;
    .link_create.attach_type = BPF_TRACE_KPROBE_SESSION;
};

syscall(SYS_bpf,
    BPF_LINK_CREATE,
    &attr,
    sizeof(attr)
);
```

#### Helper函数

并非所有辅助函数都适用于所有程序类型。这些是 kprobe 程序可用的辅助调用：
- bpf_cgrp_storage_delete
- bpf_cgrp_storage_get
- bpf_copy_from_user
- bpf_copy_from_user_task
- bpf_current_task_under_cgroup
- bpf_dynptr_data
- bpf_dynptr_from_mem
- bpf_dynptr_read
- bpf_dynptr_write
- bpf_find_vma
- bpf_for_each_map_elem
- bpf_get_attach_cookie
- bpf_get_branch_snapshot
- bpf_get_current_ancestor_cgroup_id
- bpf_get_current_cgroup_id
- bpf_get_current_comm
- bpf_get_current_pid_tgid
- bpf_get_current_task
- bpf_get_current_task_btf
- bpf_get_current_uid_gid
- bpf_get_func_ip
- bpf_get_ns_current_pid_tgid
- bpf_get_numa_node_id
- bpf_get_prandom_u32
- bpf_get_smp_processor_id
- bpf_get_stack
- bpf_get_stackid
- bpf_get_task_stack
- bpf_jiffies64
- bpf_kptr_xchg
- bpf_ktime_get_boot_ns
- bpf_ktime_get_ns
- bpf_ktime_get_tai_ns
- bpf_loop
- bpf_map_delete_elem
- bpf_map_lookup_elem
- bpf_map_lookup_percpu_elem
- bpf_map_peek_elem
- bpf_map_pop_elem
- bpf_map_push_elem
- bpf_map_update_elem
- bpf_override_return
- bpf_per_cpu_ptr
- bpf_perf_event_output
- bpf_perf_event_read
- bpf_perf_event_read_value
- bpf_probe_read
- bpf_probe_read_kernel
- bpf_probe_read_kernel_str
- bpf_probe_read_str
- bpf_probe_read_user
- bpf_probe_read_user_str
- bpf_probe_write_user
- bpf_ringbuf_discard
- bpf_ringbuf_discard_dynptr
- bpf_ringbuf_output
- bpf_ringbuf_query
- bpf_ringbuf_reserve
- bpf_ringbuf_reserve_dynptr
- bpf_ringbuf_submit
- bpf_ringbuf_submit_dynptr
- bpf_send_signal
- bpf_send_signal_thread
- bpf_snprintf
- bpf_snprintf_btf
- bpf_spin_lock
- bpf_spin_unlock
- bpf_strncmp
- bpf_tail_call
- bpf_task_pt_regs
- bpf_task_storage_delete
- bpf_task_storage_get
- bpf_this_cpu_ptr
- bpf_timer_cancel
- bpf_timer_init
- bpf_timer_set_callback
- bpf_timer_start
- bpf_trace_printk
- bpf_trace_vprintk
- bpf_user_ringbuf_drain

#### KFuncs

- bpf_session_cookie
- bpf_session_is_return

### BPF_PROG_TYPE_TRACEPOINT

BPF_PROG_TYPE_TRACEPOINT 程序是附加到 linux 内核中预定义跟踪点的 eBPF 程序。这些跟踪点通常位于有趣的位置或常用的位置，用于测量性能。

#### 使用

Tracepoint 程序可以附加到跟踪事件。这些事件是用 `TRACE_EVENT` 宏声明的。以 xdp_exception 跟踪事件为例。通过 `TP_*` 宏的组合，我们定义了跟踪点的函数原型、将传递给任何处理程序的结构体以及从参数到结构体的转换方法。

TRACE_EVENT 宏将通过名称后带 trace_ 前缀的函数来提供跟踪点。因此，trace_xdp_exception 将触发 xdp_exception 事件，该事件可能发生在代码中的任意位置。所有对跟踪程序的调用都将调用所附的 eBPF 程序。

我们可以使用 tracefs 列出所有这些可用的跟踪事件。在本页中，我们将假设 tracefs 挂载在 /sys/kernel/tracing（这在大多数发行版中都很常见）。在/sys/kernel/tracing/events/目录下还包含许多其他目录。事件按其名称中的第一个单词分组，因此所有 kvm_* 事件都位于 /sys/kernel/tracing/events/kvm。因此 xdp_exception 位于 /sys/kernel/tracing/events/xdp/xdp_exception。我们将把该目录称为 “事件目录”。

#### 上下文

跟踪点程序的上下文是一个指向结构体的指针，每个跟踪事件的结构体类型都不同。事件目录包含一个名为 format 的伪文件，因此对于 xdp_exception，这个伪文件就是 /sys/kernel/tracing/events/xdp/xdp_exception/format。我们可以读取该文件来获取结构类型的布局：
`$ cat /sys/kernel/tracing/events/xdp/xdp_exception/format`
```
name: xdp_exception
ID: 488
format:
    field:unsigned short common_type;   offset:0;   size:2; signed:0;
    field:unsigned char common_flags;   offset:2;   size:1; signed:0;
    field:unsigned char common_preempt_count;   offset:3;   size:1; signed:0;
    field:int common_pid;   offset:4;   size:4; signed:1;

    field:int prog_id;  offset:8;   size:4; signed:1;
    field:u32 act;  offset:12;  size:4; signed:0;
    field:int ifindex;  offset:16;  size:4; signed:1;

print fmt: "prog_id=%d action=%s ifindex=%d", REC->prog_id, __print_symbolic(REC->act, { 0, "ABORTED" }, { 1, "DROP" }, { 2, "PASS" }, { 3, "TX" }, { 4, "REDIRECT" }, { -1, ((void *)0) }), REC->ifindex
```
根据输出结果，我们可以重构上下文，C 结构的上下文如下所示：
```c
struct xdp_exception_ctx {
    __u16 common_type;
    __u8 flags;
    __u8 common_preempt_count;
    __s32 common_pid;

    __s32 prog_int;
    __u32 act;
    __s32 ifindex;
};
```
#### 附加
附加跟踪点程序有三种方法，从最古老、最不推荐的到最新、最推荐的，但所有方法的第一部分都是相同的。

首先，我们要在 tracefs 中查找事件 ID。在事件目录下有一个名为 id 的伪文件，因此对于 xdp_exception，文件名是 /sys/kernel/tracing/events/xdp/xdp_exception/id。读取文件时会返回一个十进制数字。

下一步是使用 perf_event_open 系统调用打开一个新的 perf 事件：
```c
struct perf_event_attr attr = {
    .type = PERF_TYPE_TRACEPOINT,
    .size = sizeof(struct perf_event_attr),
    .config = event_id, /* The ID of your trace event */
    .sample_period = 1,
    .sample_type = PERF_SAMPLE_RAW,
    .wakeup_events = 1,
};

syscall(SYS_perf_event_open, 
    &attr,  /* struct perf_event_attr * */
    -1,     /* pid_t pid */
    0       /* int cpu */
    -1,     /* int group_fd */
    PERF_FLAG_FD_CLOEXEC /* unsigned long flags */
);
```
该系统调用成功后将返回一个文件描述符。
#### ioctl 方法

这是最古老也是最不推荐的方法。获得 perf 事件文件描述符后，我们执行两个 ioctl 系统调用，将 BPF 程序附加到跟踪事件并启用跟踪。

```c
ioctl(perf_event_fd, PERF_EVENT_IOC_SET_BPF, bpf_prog_fd); 附加。
ioctl(perf_event_fd,PERF_EVENT_IOC_ENABLE,0)；启用。
```

可以使用 PERF_EVENT_IOC_DISABLE ioctl 选项暂时禁用跟踪点。否则，跟踪点会一直连接到 perf_event 因 perf_event FD 关闭或程序退出而消失为止。perf 事件持有对 BPF 程序的引用，因此它将一直被加载，直到不再有跟踪点引用它为止。

#### perf_event_open PMU

#### BPF link

这是最新也是最推荐的附加 tracepoint 程序的方法。

在获取 perf 事件文件描述符后，我们通过 link create syscall 命令创建一个 BPF 链接来附加程序。

我们调用 syscall 命令时要使用 BPF_PERF_EVENT attach_type，target_fd 设为 perf 事件文件描述符，prog_fd 设为跟踪点程序的文件描述符，并可选择使用 cookie

#### Helper函数

- bpf_cgrp_storage_delete
- bpf_cgrp_storage_get
- bpf_copy_from_user
- bpf_copy_from_user_task
- bpf_current_task_under_cgroup
- bpf_dynptr_data
- bpf_dynptr_from_mem
- bpf_dynptr_read
- bpf_dynptr_write
- bpf_find_vma
- bpf_for_each_map_elem
- bpf_get_attach_cookie
- bpf_get_branch_snapshot
- bpf_get_current_ancestor_cgroup_id
- bpf_get_current_cgroup_id
- bpf_get_current_comm
- bpf_get_current_pid_tgid
- bpf_get_current_task
- bpf_get_current_task_btf
- bpf_get_current_uid_gid
- bpf_get_func_ip
- bpf_get_ns_current_pid_tgid
- bpf_get_numa_node_id
- bpf_get_prandom_u32
- bpf_get_smp_processor_id
- bpf_get_stack
- bpf_get_stackid
- bpf_get_task_stack
- bpf_jiffies64
- bpf_kptr_xchg
- bpf_ktime_get_boot_ns
- bpf_ktime_get_ns
- bpf_ktime_get_tai_ns
- bpf_loop
- bpf_map_delete_elem
- bpf_map_lookup_elem
- bpf_map_lookup_percpu_elem
- bpf_map_peek_elem
- bpf_map_pop_elem
- bpf_map_push_elem
- bpf_map_update_elem
- bpf_per_cpu_ptr
- bpf_perf_event_output
- bpf_perf_event_read
- bpf_perf_event_read_value
- bpf_probe_read
- bpf_probe_read_kernel
- bpf_probe_read_kernel_str
- bpf_probe_read_str
- bpf_probe_read_user
- bpf_probe_read_user_str
- bpf_probe_write_user
- bpf_ringbuf_discard
- bpf_ringbuf_discard_dynptr
- bpf_ringbuf_output
- bpf_ringbuf_query
- bpf_ringbuf_reserve
- bpf_ringbuf_reserve_dynptr
- bpf_ringbuf_submit
- bpf_ringbuf_submit_dynptr
- bpf_send_signal
- bpf_send_signal_thread
- bpf_snprintf
- bpf_snprintf_btf
- bpf_spin_lock
- bpf_spin_unlock
- bpf_strncmp
- bpf_tail_call
- bpf_task_pt_regs
- bpf_task_storage_delete
- bpf_task_storage_get
- bpf_this_cpu_ptr
- bpf_timer_cancel
- bpf_timer_init
- bpf_timer_set_callback
- bpf_timer_start
- bpf_trace_printk
- bpf_trace_vprintk
- bpf_user_ringbuf_drain

#### KFuncs

- bpf_arena_alloc_pages 
- bpf_arena_free_pages 
- bpf_cast_to_kern_ctx 
- bpf_cgroup_acquire 
- bpf_cgroup_ancestor 
- bpf_cgroup_from_id 
- bpf_cgroup_release 
- bpf_copy_from_user_str 
- bpf_cpumask_acquire 
- bpf_cpumask_and 
- bpf_cpumask_any_and_distribute 
- bpf_cpumask_any_distribute 
- bpf_cpumask_clear 
- bpf_cpumask_clear_cpu 
- bpf_cpumask_copy 
- bpf_cpumask_create 
- bpf_cpumask_empty 
- bpf_cpumask_equal 
- bpf_cpumask_first 
- bpf_cpumask_first_and 
- bpf_cpumask_first_zero 
- bpf_cpumask_full 
- bpf_cpumask_intersects 
- bpf_cpumask_or 
- bpf_cpumask_release 
- bpf_cpumask_set_cpu 
- bpf_cpumask_setall 
- bpf_cpumask_subset 
- bpf_cpumask_test_and_clear_cpu 
- bpf_cpumask_test_and_set_cpu 
- bpf_cpumask_test_cpu 
- bpf_cpumask_weight 
- bpf_cpumask_xor 
- bpf_dynptr_adjust 
- bpf_dynptr_clone 
- bpf_dynptr_from_skb 
- bpf_dynptr_is_null 
- bpf_dynptr_is_rdonly 
- bpf_dynptr_size 
- bpf_dynptr_slice 
- bpf_dynptr_slice_rdwr 
- bpf_get_dentry_xattr 
- bpf_get_file_xattr 
- bpf_get_fsverity_digest 
- bpf_get_kmem_cache 
- bpf_get_task_exe_file 
- bpf_iter_bits_destroy 
- bpf_iter_bits_new 
- bpf_iter_bits_next 
- bpf_iter_css_destroy 
- bpf_iter_css_new 
- bpf_iter_css_next 
- bpf_iter_css_task_destroy 
- bpf_iter_css_task_new 
- bpf_iter_css_task_next 
- bpf_iter_kmem_cache_destroy 
- bpf_iter_kmem_cache_new 
- bpf_iter_kmem_cache_next 
- bpf_iter_num_destroy 
- bpf_iter_num_new 
- bpf_iter_num_next 
- bpf_iter_scx_dsq_destroy 
- bpf_iter_scx_dsq_new 
- bpf_iter_scx_dsq_next 
- bpf_iter_task_destroy 
- bpf_iter_task_new 
- bpf_iter_task_next 
- bpf_iter_task_vma_destroy 
- bpf_iter_task_vma_new 
- bpf_iter_task_vma_next 
- bpf_key_put 
- bpf_list_pop_back 
- bpf_list_pop_front 
- bpf_list_push_back_impl 
- bpf_list_push_front_impl 
- bpf_local_irq_restore 
- bpf_local_irq_save 
- bpf_lookup_system_key 
- bpf_lookup_user_key 
- bpf_map_sum_elem_count 
- bpf_obj_drop_impl 
- bpf_obj_new_impl 
- bpf_path_d_path 
- bpf_percpu_obj_drop_impl 
- bpf_percpu_obj_new_impl 
- bpf_preempt_disable 
- bpf_preempt_enable 
- bpf_put_file 
- bpf_rbtree_add_impl 
- bpf_rbtree_first 
- bpf_rbtree_remove 
- bpf_rcu_read_lock 
- bpf_rcu_read_unlock 
- bpf_rdonly_cast 
- bpf_refcount_acquire_impl 
- bpf_send_signal_task 
- bpf_sock_destroy 
- bpf_task_acquire 
- bpf_task_from_pid 
- bpf_task_from_vpid 
- bpf_task_get_cgroup1 
- bpf_task_release 
- bpf_task_under_cgroup 
- bpf_throw 
- bpf_verify_pkcs7_signature 
- bpf_wq_init 
- bpf_wq_set_callback_impl 
- bpf_wq_start 
- cgroup_rstat_flush 
- cgroup_rstat_updated 
- crash_kexec 
- scx_bpf_cpu_rq 
- scx_bpf_cpuperf_cap 
- scx_bpf_cpuperf_cur 
- scx_bpf_cpuperf_set 
- scx_bpf_destroy_dsq 
- scx_bpf_dsq_nr_queued 
- scx_bpf_dump_bstr 
- scx_bpf_error_bstr 
- scx_bpf_exit_bstr 
- scx_bpf_get_idle_cpumask 
- scx_bpf_get_idle_smtmask 
- scx_bpf_get_online_cpumask 
- scx_bpf_get_possible_cpumask 
- scx_bpf_kick_cpu 
- scx_bpf_now 
- scx_bpf_nr_cpu_ids 
- scx_bpf_pick_any_cpu 
- scx_bpf_pick_idle_cpu 
- scx_bpf_put_cpumask 
- scx_bpf_put_idle_cpumask 
- scx_bpf_task_cgroup 
- scx_bpf_task_cpu 
- scx_bpf_task_running 
- scx_bpf_test_and_clear_cpu_idle 

### BPF_PROG_TYPE_PERF_EVENT

可附加到硬件和软件 perf 事件的 perf 事件程序。一旦附加上 BPF 程序，就会在每次触发 perf 事件时执行。

#### 使用

Perf 事件程序通常用于剖析和跟踪。调用这些程序时，需要提供事件发生时的 CPU 寄存器状态。这样，程序就能收集每个事件的信息，并以定制方式进行汇总。

Perf 事件程序通常放在 perf_event ELF 头中。

#### 上下文

- regs：该字段包含事件发生时的 CPU 寄存器。由于每个架构的寄存器不同，因此每个架构的字段类型也不同。可以使用 tools/lib/bpf/bpf_tracing.h 中的助手以可移植的方式访问寄存器。
- sample_period：该字段包含该 perf 甚至被触发的次数。
- addr

#### 附件

这里有三种附加 perf 事件程序的方法，从最古老、最不推荐的到最新、最推荐的，但所有方法的第一部分都是相同的。

下一步是使用 perf_event_open 系统调用打开一个新的 perf 事件：
```c
struct perf_event_attr attr = {
    .sample_freq = SAMPLE_FREQ,
    .freq = 1,
    .type = PERF_TYPE_HARDWARE,
    .config = PERF_COUNT_HW_CPU_CYCLES,
};

syscall(SYS_perf_event_open, 
    &attr,  /* struct perf_event_attr * */
    -1,     /* pid_t pid */
    0       /* int cpu */
    -1,     /* int group_fd */
    PERF_FLAG_FD_CLOEXEC /* unsigned long flags */
);
```
该系统调用成功后将返回一个文件描述符。只要是 PERF_TYPE_HARDWARE 或 PERF_TYPE_SOFTWARE 类型的事件，Perf 事件程序都可以附加到任何事件上。

##### ioctl方法

这是最古老也是最不推荐的方法。获得 perf 事件文件描述符后，我们执行两个 ioctl 系统调用，将 BPF 程序附加到跟踪事件并启用跟踪。

```c
ioctl(perf_event_fd, PERF_EVENT_IOC_SET_BPF, bpf_prog_fd); //附加。
ioctl(perf_event_fd,PERF_EVENT_IOC_ENABLE,0)；//启用。
```
可以使用 PERF_EVENT_IOC_DISABLE ioctl 选项暂时禁用 perf 事件程序。否则，perf 事件程序将保持连接，直到 perf_event FD 关闭或程序退出导致 perf_event 消失。perf 事件持有对 BPF 程序的引用，因此它将一直被加载，直到不再有 perf 事件程序引用它为止。

##### BPF link

这是最新也是最推荐的附加 perf 事件程序的方法。

在获取 perf 事件文件描述符后，我们通过 link create syscall 命令创建一个 BPF 链接来附加程序。

我们调用 syscall 命令时要使用 BPF_PERF_EVENT attach_type，target_fd 设为 perf 事件文件描述符，prog_fd 设为跟踪点程序的文件描述符，还可选择使用 cookie

#### 例子

profiling example：
```c
/* Copyright (c) 2016 Facebook
*
* This program is free software; you can redistribute it and/or
* modify it under the terms of version 2 of the GNU General Public
* License as published by the Free Software Foundation.
*/
#include <linux/ptrace.h>
#include <uapi/linux/bpf.h>
#include <uapi/linux/bpf_perf_event.h>
#include <uapi/linux/perf_event.h>
#include <bpf/bpf_helpers.h>
#include <bpf/bpf_tracing.h>

struct key_t {
    char comm[TASK_COMM_LEN];
    u32 kernstack;
    u32 userstack;
};

struct {
    __uint(type, BPF_MAP_TYPE_HASH);
    __type(key, struct key_t);
    __type(value, u64);
    __uint(max_entries, 10000);
} counts SEC(".maps");

struct {
    __uint(type, BPF_MAP_TYPE_STACK_TRACE);
    __uint(key_size, sizeof(u32));
    __uint(value_size, PERF_MAX_STACK_DEPTH * sizeof(u64));
    __uint(max_entries, 10000);
} stackmap SEC(".maps");

#define KERN_STACKID_FLAGS (0 | BPF_F_FAST_STACK_CMP)
#define USER_STACKID_FLAGS (0 | BPF_F_FAST_STACK_CMP | BPF_F_USER_STACK)

SEC("perf_event")
int bpf_prog1(struct bpf_perf_event_data *ctx)
{
    char time_fmt1[] = "Time Enabled: %llu, Time Running: %llu";
    char time_fmt2[] = "Get Time Failed, ErrCode: %d";
    char addr_fmt[] = "Address recorded on event: %llx";
    char fmt[] = "CPU-%d period %lld ip %llx";
    u32 cpu = bpf_get_smp_processor_id();
    struct bpf_perf_event_value value_buf;
    struct key_t key;
    u64 *val, one = 1;
    int ret;

    if (ctx->sample_period < 10000)
        /* ignore warmup */
        return 0;
    bpf_get_current_comm(&key.comm, sizeof(key.comm));
    key.kernstack = bpf_get_stackid(ctx, &stackmap, KERN_STACKID_FLAGS);
    key.userstack = bpf_get_stackid(ctx, &stackmap, USER_STACKID_FLAGS);
    if ((int)key.kernstack < 0 && (int)key.userstack < 0) {
        bpf_trace_printk(fmt, sizeof(fmt), cpu, ctx->sample_period,
                PT_REGS_IP(&ctx->regs));
        return 0;
    }

    ret = bpf_perf_prog_read_value(ctx, (void *)&value_buf, sizeof(struct bpf_perf_event_value));
    if (!ret)
    bpf_trace_printk(time_fmt1, sizeof(time_fmt1), value_buf.enabled, value_buf.running);
    else
    bpf_trace_printk(time_fmt2, sizeof(time_fmt2), ret);

    if (ctx->addr != 0)
    bpf_trace_printk(addr_fmt, sizeof(addr_fmt), ctx->addr);

    val = bpf_map_lookup_elem(&counts, &key);
    if (val)
        (*val)++;
    else
        bpf_map_update_elem(&counts, &key, &one, BPF_NOEXIST);
    return 0;
}

char _license[] SEC("license") = "GPL";
```

recording instruction pointer：
```c
/* Copyright 2016 Netflix, Inc.
*
* This program is free software; you can redistribute it and/or
* modify it under the terms of version 2 of the GNU General Public
* License as published by the Free Software Foundation.
*/
#include <linux/ptrace.h>
#include <uapi/linux/bpf.h>
#include <uapi/linux/bpf_perf_event.h>
#include <bpf/bpf_helpers.h>
#include <bpf/bpf_tracing.h>

#define MAX_IPS     8192

struct {
    __uint(type, BPF_MAP_TYPE_HASH);
    __type(key, u64);
    __type(value, u32);
    __uint(max_entries, MAX_IPS);
} ip_map SEC(".maps");

SEC("perf_event")
int do_sample(struct bpf_perf_event_data *ctx)
{
    u64 ip;
    u32 *value, init_val = 1;

    ip = PT_REGS_IP(&ctx->regs);
    value = bpf_map_lookup_elem(&ip_map, &ip);
    if (value)
        *value += 1;
    else
        /* E2BIG not tested for this example only */
        bpf_map_update_elem(&ip_map, &ip, &init_val, BPF_NOEXIST);

    return 0;
}
char _license[] SEC("license") = "GPL";
```

#### Helper函数

- bpf_cgrp_storage_delete
- bpf_cgrp_storage_get
- bpf_copy_from_user
- bpf_copy_from_user_task
- bpf_current_task_under_cgroup
- bpf_dynptr_data
- bpf_dynptr_from_mem
- bpf_dynptr_read
- bpf_dynptr_write
- bpf_find_vma
- bpf_for_each_map_elem
- bpf_get_attach_cookie
- bpf_get_branch_snapshot
- bpf_get_current_ancestor_cgroup_id
- bpf_get_current_cgroup_id
- bpf_get_current_comm
- bpf_get_current_pid_tgid
- bpf_get_current_task
- bpf_get_current_task_btf
- bpf_get_current_uid_gid
- bpf_get_func_ip
- bpf_get_ns_current_pid_tgid
- bpf_get_numa_node_id
- bpf_get_prandom_u32
- bpf_get_smp_processor_id
- bpf_get_stack
- bpf_get_stackid
- bpf_get_task_stack
- bpf_jiffies64
- bpf_kptr_xchg
- bpf_ktime_get_boot_ns
- bpf_ktime_get_ns
- bpf_ktime_get_tai_ns
- bpf_loop
- bpf_map_delete_elem
- bpf_map_lookup_elem
- bpf_map_lookup_percpu_elem
- bpf_map_peek_elem
- bpf_map_pop_elem
- bpf_map_push_elem
- bpf_map_update_elem
- bpf_per_cpu_ptr
- bpf_perf_event_output
- bpf_perf_event_read
- bpf_perf_event_read_value
- bpf_perf_prog_read_value
- bpf_probe_read
- bpf_probe_read_kernel
- bpf_probe_read_kernel_str
- bpf_probe_read_str
- bpf_probe_read_user
- bpf_probe_read_user_str
- bpf_probe_write_user
- bpf_read_branch_records
- bpf_ringbuf_discard
- bpf_ringbuf_discard_dynptr
- bpf_ringbuf_output
- bpf_ringbuf_query
- bpf_ringbuf_reserve
- bpf_ringbuf_reserve_dynptr
- bpf_ringbuf_submit
- bpf_ringbuf_submit_dynptr
- bpf_send_signal
- bpf_send_signal_thread
- bpf_snprintf
- bpf_snprintf_btf
- bpf_spin_lock
- bpf_spin_unlock
- bpf_strncmp
- bpf_tail_call
- bpf_task_pt_regs
- bpf_task_storage_delete
- bpf_task_storage_get
- bpf_this_cpu_ptr
- bpf_timer_cancel
- bpf_timer_init
- bpf_timer_set_callback
- bpf_timer_start
- bpf_trace_printk
- bpf_trace_vprintk
- bpf_user_ringbuf_drain

#### KFuncs

- bpf_arena_alloc_pages 
- bpf_arena_free_pages 
- bpf_cast_to_kern_ctx 
- bpf_cgroup_acquire 
- bpf_cgroup_ancestor 
- bpf_cgroup_from_id 
- bpf_cgroup_release 
- bpf_copy_from_user_str 
- bpf_cpumask_acquire 
- bpf_cpumask_and 
- bpf_cpumask_any_and_distribute 
- bpf_cpumask_any_distribute 
- bpf_cpumask_clear 
- bpf_cpumask_clear_cpu 
- bpf_cpumask_copy 
- bpf_cpumask_create 
- bpf_cpumask_empty 
- bpf_cpumask_equal 
- bpf_cpumask_first 
- bpf_cpumask_first_and 
- bpf_cpumask_first_zero 
- bpf_cpumask_full 
- bpf_cpumask_intersects 
- bpf_cpumask_or 
- bpf_cpumask_release 
- bpf_cpumask_set_cpu 
- bpf_cpumask_setall 
- bpf_cpumask_subset 
- bpf_cpumask_test_and_clear_cpu 
- bpf_cpumask_test_and_set_cpu 
- bpf_cpumask_test_cpu 
- bpf_cpumask_weight 
- bpf_cpumask_xor 
- bpf_dynptr_adjust 
- bpf_dynptr_clone 
- bpf_dynptr_from_skb 
- bpf_dynptr_is_null 
- bpf_dynptr_is_rdonly 
- bpf_dynptr_size 
- bpf_dynptr_slice 
- bpf_dynptr_slice_rdwr 
- bpf_get_dentry_xattr 
- bpf_get_file_xattr 
- bpf_get_fsverity_digest 
- bpf_get_kmem_cache 
- bpf_get_task_exe_file 
- bpf_iter_bits_destroy 
- bpf_iter_bits_new 
- bpf_iter_bits_next 
- bpf_iter_css_destroy 
- bpf_iter_css_new 
- bpf_iter_css_next 
- bpf_iter_css_task_destroy 
- bpf_iter_css_task_new 
- bpf_iter_css_task_next 
- bpf_iter_kmem_cache_destroy 
- bpf_iter_kmem_cache_new 
- bpf_iter_kmem_cache_next 
- bpf_iter_num_destroy 
- bpf_iter_num_new 
- bpf_iter_num_next 
- bpf_iter_scx_dsq_destroy 
- bpf_iter_scx_dsq_new 
- bpf_iter_scx_dsq_next 
- bpf_iter_task_destroy 
- bpf_iter_task_new 
- bpf_iter_task_next 
- bpf_iter_task_vma_destroy 
- bpf_iter_task_vma_new 
- bpf_iter_task_vma_next 
- bpf_key_put 
- bpf_list_pop_back 
- bpf_list_pop_front 
- bpf_list_push_back_impl 
- bpf_list_push_front_impl 
- bpf_local_irq_restore 
- bpf_local_irq_save 
- bpf_lookup_system_key 
- bpf_lookup_user_key 
- bpf_map_sum_elem_count 
- bpf_obj_drop_impl 
- bpf_obj_new_impl 
- bpf_path_d_path 
- bpf_percpu_obj_drop_impl 
- bpf_percpu_obj_new_impl 
- bpf_preempt_disable 
- bpf_preempt_enable 
- bpf_put_file 
- bpf_rbtree_add_impl 
- bpf_rbtree_first 
- bpf_rbtree_remove 
- bpf_rcu_read_lock 
- bpf_rcu_read_unlock 
- bpf_rdonly_cast 
- bpf_refcount_acquire_impl 
- bpf_send_signal_task 
- bpf_sock_destroy 
- bpf_task_acquire 
- bpf_task_from_pid 
- bpf_task_from_vpid 
- bpf_task_get_cgroup1 
- bpf_task_release 
- bpf_task_under_cgroup 
- bpf_throw 
- bpf_verify_pkcs7_signature 
- bpf_wq_init 
- bpf_wq_set_callback_impl 
- bpf_wq_start 
- cgroup_rstat_flush 
- cgroup_rstat_updated 
- crash_kexec 
- scx_bpf_cpu_rq 
- scx_bpf_cpuperf_cap 
- scx_bpf_cpuperf_cur 
- scx_bpf_cpuperf_set 
- scx_bpf_destroy_dsq 
- scx_bpf_dsq_nr_queued 
- scx_bpf_dump_bstr 
- scx_bpf_error_bstr 
- scx_bpf_exit_bstr 
- scx_bpf_get_idle_cpumask 
- scx_bpf_get_idle_smtmask 
- scx_bpf_get_online_cpumask 
- scx_bpf_get_possible_cpumask 
- scx_bpf_kick_cpu 
- scx_bpf_now 
- scx_bpf_nr_cpu_ids 
- scx_bpf_pick_any_cpu 
- scx_bpf_pick_idle_cpu 
- scx_bpf_put_cpumask 
- scx_bpf_put_idle_cpumask 
- scx_bpf_task_cgroup 
- scx_bpf_task_cpu 
- scx_bpf_task_running 
- scx_bpf_test_and_clear_cpu_idle 

### BPF_PROG_TYPE_RAW_TRACEPOINT

原始 tracepoint 程序与 tracepoint 程序类似，但内核不对参数进行预处理，而是直接将原始参数传递给 tracepoint 程序。

#### 使用

原始 tracepoint 程序通常放在以 raw_tp/ 为前缀的 ELF 部分或 raw_tracepoint 部分中。当作为 BPF_PROG_TYPE_TRACING 程序加载时，原始跟踪点通常位于以 tp_btf/ 为前缀的部分中。

原始跟踪点与普通跟踪点程序一样，被附加到相同的跟踪点上。之所以要使用原始跟踪点而不是普通跟踪点，是因为这样可以提高性能。对于普通的 tracepoints，即使参数从未使用过，内核也会对参数进行转换。通过使用原始参数，BPF 程序只有在参数被使用时才会进行转换，从而提高了跟踪点程序的效率。

#### 上下文

原始跟踪点程序的上下文是指向结构 bpf_raw_tracepoint_args 的指针：
```c
struct bpf_raw_tracepoint_args {
    __u64 args[0];
};
```

args 数组包含跟踪点的原始参数。参数数由 tracepoint 决定。校验器将确保参数数与 tracepoint 预期的参数数一致。BPF 程序可将 u64 值转换为预期类型，或使用 bpf_probe_read/bpf_probe_read_kernel 辅助函数读取参数。

#### 连接

原始跟踪点可通过两种方式附加，第一种是使用专用系统调用，第二种是使用更通用的 BPF 链接系统调用。

#### 系统调用

专用系统调用 BPF_RAW_TRACEPOINT_OPEN 可用于附加原始跟踪点。这需要将 name 字段设置为包含用户希望附加的跟踪点名称的字符串。prog_fd 属性字段应设置为要附加的 BPF 程序的文件描述符。

#### BPF link

BPF 链接也可用于附加原始跟踪点程序。为此，原始跟踪点必须以 BPF_PROG_TYPE_TRACING 程序类型而非 BPF_PROG_TYPE_RAW_TRACEPOINT 程序类型加载。expected_attach_type 应为 BPF_TRACE_RAW_TP，attach_btf_id 属性应设置为程序应连接的跟踪点的 BTF ID。

然后，应通过 link create syscall 命令 syscall 创建链接。附加类型设置为 BPF_TRACE_RAW_TP。

#### 例子

raw tracepoint
```c
// SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
// Copyright (c) 2021 Facebook
#include "vmlinux.h"
#include <bpf/bpf_helpers.h>
#include <bpf/bpf_tracing.h>

struct {
    __uint(type, BPF_MAP_TYPE_PERF_EVENT_ARRAY);
    __uint(key_size, sizeof(__u32));
    __uint(value_size, sizeof(int));
    __uint(map_flags, BPF_F_PRESERVE_ELEMS);
} events SEC(".maps");

struct {
    __uint(type, BPF_MAP_TYPE_PERCPU_ARRAY);
    __uint(key_size, sizeof(__u32));
    __uint(value_size, sizeof(struct bpf_perf_event_value));
    __uint(max_entries, 1);
} prev_readings SEC(".maps");

struct {
    __uint(type, BPF_MAP_TYPE_PERCPU_ARRAY);
    __uint(key_size, sizeof(__u32));
    __uint(value_size, sizeof(struct bpf_perf_event_value));
    __uint(max_entries, 1);
} diff_readings SEC(".maps");

SEC("raw_tp/sched_switch")
int BPF_PROG(on_switch)
{
    struct bpf_perf_event_value val, *prev_val, *diff_val;
    __u32 key = bpf_get_smp_processor_id();
    __u32 zero = 0;
    long err;

    prev_val = bpf_map_lookup_elem(&prev_readings, &zero);
    if (!prev_val)
        return 0;

    diff_val = bpf_map_lookup_elem(&diff_readings, &zero);
    if (!diff_val)
        return 0;

    err = bpf_perf_event_read_value(&events, key, &val, sizeof(val));
    if (err)
        return 0;

    diff_val->counter = val.counter - prev_val->counter;
    diff_val->enabled = val.enabled - prev_val->enabled;
    diff_val->running = val.running - prev_val->running;
    *prev_val = val;
    return 0;
}

char LICENSE[] SEC("license") = "Dual BSD/GPL";
```

tracing program
```c
// SPDX-License-Identifier: GPL-2.0
// Copyright (c) 2019 Facebook
#include "vmlinux.h"
#include <bpf/bpf_helpers.h>
#include "runqslower.h"

#define TASK_RUNNING 0
#define BPF_F_CURRENT_CPU 0xffffffffULL

const volatile __u64 min_us = 0;
const volatile pid_t targ_pid = 0;

struct {
    __uint(type, BPF_MAP_TYPE_TASK_STORAGE);
    __uint(map_flags, BPF_F_NO_PREALLOC);
    __type(key, int);
    __type(value, u64);
} start SEC(".maps");

struct {
    __uint(type, BPF_MAP_TYPE_PERF_EVENT_ARRAY);
    __uint(key_size, sizeof(u32));
    __uint(value_size, sizeof(u32));
} events SEC(".maps");

/* record enqueue timestamp */
__always_inline
static int trace_enqueue(struct task_struct *t)
{
    u32 pid = t->pid;
    u64 *ptr;

    if (!pid || (targ_pid && targ_pid != pid))
        return 0;

    ptr = bpf_task_storage_get(&start, t, 0,
                BPF_LOCAL_STORAGE_GET_F_CREATE);
    if (!ptr)
        return 0;

    *ptr = bpf_ktime_get_ns();
    return 0;
}

SEC("tp_btf/sched_wakeup")
int handle__sched_wakeup(u64 *ctx)
{
    /* TP_PROTO(struct task_struct *p) */
    struct task_struct *p = (void *)ctx[0];

    return trace_enqueue(p);
}

SEC("tp_btf/sched_wakeup_new")
int handle__sched_wakeup_new(u64 *ctx)
{
    /* TP_PROTO(struct task_struct *p) */
    struct task_struct *p = (void *)ctx[0];

    return trace_enqueue(p);
}

SEC("tp_btf/sched_switch")
int handle__sched_switch(u64 *ctx)
{
    /* TP_PROTO(bool preempt, struct task_struct *prev,
    *       struct task_struct *next)
    */
    struct task_struct *prev = (struct task_struct *)ctx[1];
    struct task_struct *next = (struct task_struct *)ctx[2];
    struct runq_event event = {};
    u64 *tsp, delta_us;
    long state;
    u32 pid;

    /* ivcsw: treat like an enqueue event and store timestamp */
    if (prev->__state == TASK_RUNNING)
        trace_enqueue(prev);

    pid = next->pid;

    /* For pid mismatch, save a bpf_task_storage_get */
    if (!pid || (targ_pid && targ_pid != pid))
        return 0;

    /* fetch timestamp and calculate delta */
    tsp = bpf_task_storage_get(&start, next, 0, 0);
    if (!tsp)
        return 0;   /* missed enqueue */

    delta_us = (bpf_ktime_get_ns() - *tsp) / 1000;
    if (min_us && delta_us <= min_us)
        return 0;

    event.pid = pid;
    event.delta_us = delta_us;
    bpf_get_current_comm(&event.task, sizeof(event.task));

    /* output */
    bpf_perf_event_output(ctx, &events, BPF_F_CURRENT_CPU,
                &event, sizeof(event));

    bpf_task_storage_delete(&start, next);
    return 0;
}

char LICENSE[] SEC("license") = "GPL";
```

#### Helper函数

- bpf_cgrp_storage_delete
- bpf_cgrp_storage_get
- bpf_copy_from_user
- bpf_copy_from_user_task
- bpf_current_task_under_cgroup
- bpf_dynptr_data
- bpf_dynptr_from_mem
- bpf_dynptr_read
- bpf_dynptr_write
- bpf_find_vma
- bpf_for_each_map_elem
- bpf_get_attach_cookie
- bpf_get_branch_snapshot
- bpf_get_current_ancestor_cgroup_id
- bpf_get_current_cgroup_id
- bpf_get_current_comm
- bpf_get_current_pid_tgid
- bpf_get_current_task
- bpf_get_current_task_btf
- bpf_get_current_uid_gid
- bpf_get_func_ip
- bpf_get_ns_current_pid_tgid
- bpf_get_numa_node_id
- bpf_get_prandom_u32
- bpf_get_smp_processor_id
- bpf_get_stack
- bpf_get_stackid
- bpf_get_task_stack
- bpf_jiffies64
- bpf_kptr_xchg
- bpf_ktime_get_boot_ns
- bpf_ktime_get_ns
- bpf_ktime_get_tai_ns
- bpf_loop
- bpf_map_delete_elem
- bpf_map_lookup_elem
- bpf_map_lookup_percpu_elem
- bpf_map_peek_elem
- bpf_map_pop_elem
- bpf_map_push_elem
- bpf_map_update_elem
- bpf_per_cpu_ptr
- bpf_perf_event_output
- bpf_perf_event_read
- bpf_perf_event_read_value
- bpf_probe_read
- bpf_probe_read_kernel
- bpf_probe_read_kernel_str
- bpf_probe_read_str
- bpf_probe_read_user
- bpf_probe_read_user_str
- bpf_probe_write_user
- bpf_ringbuf_discard
- bpf_ringbuf_discard_dynptr
- bpf_ringbuf_output
- bpf_ringbuf_query
- bpf_ringbuf_reserve
- bpf_ringbuf_reserve_dynptr
- bpf_ringbuf_submit
- bpf_ringbuf_submit_dynptr
- bpf_send_signal
- bpf_send_signal_thread
- bpf_snprintf
- bpf_snprintf_btf
- bpf_spin_lock
- bpf_spin_unlock
- bpf_strncmp
- bpf_tail_call
- bpf_task_pt_regs
- bpf_task_storage_delete
- bpf_task_storage_get
- bpf_this_cpu_ptr
- bpf_timer_cancel
- bpf_timer_init
- bpf_timer_set_callback
- bpf_timer_start
- bpf_trace_printk
- bpf_trace_vprintk
- bpf_user_ringbuf_drain

#### KFuncs

目前没有

### BPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE

原始跟踪点可写程序与原始跟踪点程序类似，但允许写入给定上下文。

#### 使用方法

该程序类型可附加到内核开发人员放置在内核特定位置的跟踪点上。与不可写跟踪点不同，这些跟踪点可以写入整个上下文或部分上下文。这基本上允许你在运行时以非常特殊的方式修改内核的行为。

可写原始跟踪点程序只能附加到使用 DEFINE_EVENT_WRITABLE 或 DECLARE_TRACE_WRITABLE 宏创建的跟踪点上。

实际上，这样的跟踪点非常有限，内核 v6.14 中只有一个 nbd_send_request

#### 上下文

该程序类型的上下文是一个由 u64 值组成的数组。每个元素代表跟踪点的一个参数。程序必须将元素转换为适当的类型，libbpf 提供了 BPF_PROG 宏来帮助实现这一点。

上下文的第一个元素被称为 “可写缓冲区”，它是一个指向允许修改的值的指针。验证器将检查您是否试图修改任何其他部分或超出可写缓冲区的范围。

#### 连接

原始跟踪点可通过两种方式附加，第一种是使用专用系统调用，第二种是使用更通用的 BPF 链接系统调用。

#### 系统调用

专用系统调用 BPF_RAW_TRACEPOINT_OPEN 可用于连接原始跟踪点。这需要将 name 字段设置为包含用户希望附加的跟踪点名称的字符串。prog_fd 属性字段应设置为要附加的 BPF 程序的文件描述符。

#### 例子

```c
// SPDX-License-Identifier: GPL-2.0
/* Copyright (c) 2020 Facebook */

SEC("raw_tp.w/bpf_testmod_test_writable_bare")
int BPF_PROG(handle_raw_tp_writable_bare,
         struct bpf_testmod_test_writable_ctx *writable)
{
    raw_tp_writable_bare_in_val = writable->val;
    writable->early_ret = raw_tp_writable_bare_early_ret;
    writable->val = raw_tp_writable_bare_out_val;
    return 0;
}
```

#### Helper函数

- bpf_cgrp_storage_delete
- bpf_cgrp_storage_get
- bpf_copy_from_user
- bpf_copy_from_user_task
- bpf_current_task_under_cgroup
- bpf_dynptr_data
- bpf_dynptr_from_mem
- bpf_dynptr_read
- bpf_dynptr_write
- bpf_find_vma
- bpf_for_each_map_elem
- bpf_get_branch_snapshot
- bpf_get_current_ancestor_cgroup_id
- bpf_get_current_cgroup_id
- bpf_get_current_comm
- bpf_get_current_pid_tgid
- bpf_get_current_task
- bpf_get_current_task_btf
- bpf_get_current_uid_gid
- bpf_get_func_ip
- bpf_get_ns_current_pid_tgid
- bpf_get_numa_node_id
- bpf_get_prandom_u32
- bpf_get_smp_processor_id
- bpf_get_stack
- bpf_get_stackid
- bpf_get_task_stack
- bpf_jiffies64
- bpf_kptr_xchg
- bpf_ktime_get_boot_ns
- bpf_ktime_get_ns
- bpf_ktime_get_tai_ns
- bpf_loop
- bpf_map_delete_elem
- bpf_map_lookup_elem
- bpf_map_lookup_percpu_elem
- bpf_map_peek_elem
- bpf_map_pop_elem
- bpf_map_push_elem
- bpf_map_update_elem
- bpf_per_cpu_ptr
- bpf_perf_event_output
- bpf_perf_event_read
- bpf_perf_event_read_value
- bpf_probe_read
- bpf_probe_read_kernel
- bpf_probe_read_kernel_str
- bpf_probe_read_str
- bpf_probe_read_user
- bpf_probe_read_user_str
- bpf_probe_write_user
- bpf_ringbuf_discard
- bpf_ringbuf_discard_dynptr
- bpf_ringbuf_output
- bpf_ringbuf_query
- bpf_ringbuf_reserve
- bpf_ringbuf_reserve_dynptr
- bpf_ringbuf_submit
- bpf_ringbuf_submit_dynptr
- bpf_send_signal
- bpf_send_signal_thread
- bpf_snprintf
- bpf_snprintf_btf
- bpf_spin_lock
- bpf_spin_unlock
- bpf_strncmp
- bpf_tail_call
- bpf_task_pt_regs
- bpf_task_storage_delete
- bpf_task_storage_get
- bpf_this_cpu_ptr
- bpf_timer_cancel
- bpf_timer_init
- bpf_timer_set_callback
- bpf_timer_start
- bpf_trace_printk
- bpf_trace_vprintk
- bpf_user_ringbuf_drain

#### KFunc

### BPF_PROG_TYPE_TRACING

跟踪程序是 kprobes 和 tracepoints 的新替代方案。跟踪程序利用 BPF 蹦极，这是一种新的机制，可提供几乎为零的开销。此外，跟踪程序还可以附加到 BPF 程序中，以提供故障排除和调试功能，这是 kprobes 无法做到的。

#### 使用方法
根据附件类型的不同，跟踪程序有几种不同的类型。

##### 原始跟踪点

原始跟踪点程序可作为专用程序类型或跟踪程序类型下的附加类型加载。当作为跟踪程序加载时，它可通过链接附加到跟踪点的 BTF ID，而无需使用特殊系统调用来附加。

有关详情，请参阅原始跟踪点页面。

##### 文件

Fentry 程序的功能类似于附加到函数第一条指令的 kprobe。这种程序类型在控制权传递到函数之前被调用，以便进行跟踪/观察。

Kprobe 不一定要附加在函数的入口处，Kprobe 可以安装在函数的任何位置，而 Fentry 程序则总是附加在函数的入口处。

Fentry 程序是使用 BPF 蹦床附加的，这比 kprobes 造成的开销要少。条目程序还可以附加到 BPF 程序，如 XDP、TC 或 cGroup 程序，这使得调试 eBPF 程序变得更容易。Kprobes 则不具备这种功能。

Fentry 程序通常位于以 fentry/ 为前缀的 ELF 部分。

##### Fexit

Fexit 程序与 kretprobes 类似。当函数返回时，无论返回发生在何处，程序都会被调用。Fexit 程序会调用输入参数和函数的返回值，因此无需像 kprobes 和 kretprobes 那样将输入参数存储在映射表中。

Fexit 程序通常位于以 fexit/ 为前缀的 ELF 部分。

##### 修改返回值

Fmodify_return 程序运行在 fentry 程序之后，但在我们要跟踪的函数之前。与 fentry 和 fexit 程序不同，fmodify_return 程序可以返回非零值。当返回非零值时，我们正在跟踪的函数将不会被执行，取而代之的是 fmodify_return 程序返回的值。

Fmodify_return 程序会提供被跟踪函数的输入参数和返回值。如果附加了多个 fmodify_return 程序，则前一个 fmodify_return 程序的返回值将作为下一个 fmodify_return 程序的输入。

与 fentry/fexit 程序不同，fmodify_return 程序只允许用于安全钩子（额外的 CAP_MAC_ADMIN 检查）和白名单错误注入函数（ALLOW_ERROR_INJECTION）。

Fmodify_return 程序通常位于以 fmod_ret/ 为前缀的 ELF 部分中。

##### 迭代器

迭代器程序使用相同的程序类型，但用途不同。迭代器程序用于迭代内核数据结构列表，以有效收集数据和/或汇总数据，特别是在内核-用户空间边界会造成瓶颈的情况下。

迭代器程序只能附加到特定的预定义迭代器上。每个迭代器都遵循 bpf_iter___<iter_name>（内核 vmlinux 中的一种类型）的命名规则。该类型也是针对迭代器中的每个数据结构调用程序的上下文。

迭代器程序通常位于以 iter/ 为前缀的 ELF 部分中。

#### 上下文

##### 原始跟踪点

##### Fentry / Fexit / Fmodify_return

所有这些附加类型的程序都会提供一个 u64 值数组，代表被跟踪函数的参数。此外，Fexit 和 Fmodify_return 程序还提供了函数或上一个 Fmodify_return 程序的返回值。

libbpf 中定义的 BPF_PROG 和 BPF_PROG2 宏可以用来将数组的值转换为适当的类型，从而提供更自然的 BPF 程序声明方式。

内核中的某些函数会传递大于 8 字节的结构，在这种情况下，参数值可能会分布在数组的多个索引中。BPF_PROG 无法处理这种情况，因此在编写 BPF 程序时，如果要附加到以结构作为参数的函数，则应使用 BPF_PROG2 宏。

##### 迭代器

迭代器程序的上下文因迭代器而异，但每个迭代器上下文元的第一个字段都是指向 struct bpf_iter_meta 的指针：

```c
struct bpf_iter_meta {
    struct seq_file *seq;
    __u64 session_id;
    __u64 seq_num;
};
```

上下文结构的其余部分将包含当前迭代的数据结构。

元数据包含一个序列文件，实际上就是迭代器程序的输出。当读取一个钉住的迭代器时，迭代器程序将针对迭代器中的每个数据结构进行调用。然后，迭代器程序可以使用 seq_file 向用户输出数据。专用打印助手用于向序列文件写入数据，如 bpf_seq_printf、bpf_seq_printf_btf 和 bpf_seq_write。

session_id 是一个递增值，用于标识当前迭代会话。seq_num 是会话中的当前迭代次数。

#### 附件

所有跟踪程序都是通过 BPF 链接附加的。程序加载时应使用正确的附加类型，并与通过 attach_type 属性创建链接时使用的附加类型相同。应通过 target_btf_id 属性指定要附加的跟踪点、函数或迭代器，其值应与 vmlinux BTF blob 中目标的 BTF ID 匹配。

#### 例子

Raw tracepoint：
```c
/**
* A trivial example tracepoint program that shows how to
* acquire and release a struct task_struct * pointer.
*/
SEC("tp_btf/task_newtask")
int BPF_PROG(task_acquire_release_example, struct task_struct *task, u64 clone_flags)
{
    struct task_struct *acquired;

    acquired = bpf_task_acquire(task);
    if (acquired)
        /*
            * In a typical program you'd do something like store
            * the task in a map, and the map will automatically
            * release it later. Here, we release it manually.
            */
        bpf_task_release(acquired);
    return 0;
}
```

Fentry：

```c
// SPDX-License-Identifier: GPL-2.0

#include "vmlinux.h"
#include <bpf/bpf_helpers.h>
#include <bpf/bpf_tracing.h>

extern const int bpf_prog_active __ksym;

struct {
    __uint(type, BPF_MAP_TYPE_RINGBUF);
    __uint(max_entries, 1 << 12);
} ringbuf SEC(".maps");

SEC("fentry/security_inode_getattr")
int BPF_PROG(d_path_check_rdonly_mem, struct path *path, struct kstat *stat,
        __u32 request_mask, unsigned int query_flags)
{
    void *active;
    u32 cpu;

    cpu = bpf_get_smp_processor_id();
    active = (void *)bpf_per_cpu_ptr(&bpf_prog_active, cpu);
    if (active) {
        /* FAIL here! 'active' points to 'regular' memory. It
        * cannot be submitted to ring buffer.
        */
        bpf_ringbuf_submit(active, 0);
    }
    return 0;
}

char _license[] SEC("license") = "GPL";
```

// Fexit
```c
SEC("fexit/inet_stream_connect")
int BPF_PROG(update_cookie_tracing, struct socket *sock,
        struct sockaddr *uaddr, int addr_len, int flags, int ret)
{
    struct socket_cookie *p;

    if (uaddr->sa_family != AF_INET6)
        return 0;

    p = bpf_cgrp_storage_get(&socket_cookies, sock->sk->sk_cgrp_data.cgroup, 0, 0);
    if (!p)
        return 0;

    if (p->cookie_key != bpf_get_socket_cookie(sock->sk))
        return 0;

    p->cookie_value |= 0xF0;
    return 0;
}
```

// Fmodify_return

```c
// SPDX-License-Identifier: GPL-2.0

#include "vmlinux.h"
#include <bpf/bpf_helpers.h>
#include <bpf/bpf_tracing.h>
#include "hid_bpf_helpers.h"

SEC("fmod_ret/hid_bpf_device_event")
int BPF_PROG(hid_y_event, struct hid_bpf_ctx *hctx)
{
    s16 y;
    __u8 *data = hid_bpf_get_data(hctx, 0 /* offset */, 9 /* size */);

    if (!data)
        return 0; /* EPERM check */

    bpf_printk("event: size: %d", hctx->size);
    bpf_printk("incoming event: %02x %02x %02x",
        data[0],
        data[1],
        data[2]);
    bpf_printk("                %02x %02x %02x",
        data[3],
        data[4],
        data[5]);
    bpf_printk("                %02x %02x %02x",
        data[6],
        data[7],
        data[8]);

    y = data[3] | (data[4] << 8);

    y = -y;

    data[3] = y & 0xFF;
    data[4] = (y >> 8) & 0xFF;

    bpf_printk("modified event: %02x %02x %02x",
        data[0],
        data[1],
        data[2]);
    bpf_printk("                %02x %02x %02x",
        data[3],
        data[4],
        data[5]);
    bpf_printk("                %02x %02x %02x",
        data[6],
        data[7],
        data[8]);

    return 0;
}

SEC("fmod_ret/hid_bpf_device_event")
int BPF_PROG(hid_x_event, struct hid_bpf_ctx *hctx)
{
    s16 x;
    __u8 *data = hid_bpf_get_data(hctx, 0 /* offset */, 9 /* size */);

    if (!data)
        return 0; /* EPERM check */

    x = data[1] | (data[2] << 8);

    x = -x;

    data[1] = x & 0xFF;
    data[2] = (x >> 8) & 0xFF;
    return 0;
}

SEC("fmod_ret/hid_bpf_rdesc_fixup")
int BPF_PROG(hid_rdesc_fixup, struct hid_bpf_ctx *hctx)
{
    __u8 *data = hid_bpf_get_data(hctx, 0 /* offset */, 4096 /* size */);

    if (!data)
        return 0; /* EPERM check */

    bpf_printk("rdesc: %02x %02x %02x",
        data[0],
        data[1],
        data[2]);
    bpf_printk("       %02x %02x %02x",
        data[3],
        data[4],
        data[5]);
    bpf_printk("       %02x %02x %02x ...",
        data[6],
        data[7],
        data[8]);

    /*
    * The original report descriptor contains:
    *
    * 0x05, 0x01,                    //   Usage Page (Generic Desktop)      30
    * 0x16, 0x01, 0x80,              //   Logical Minimum (-32767)          32
    * 0x26, 0xff, 0x7f,              //   Logical Maximum (32767)           35
    * 0x09, 0x30,                    //   Usage (X)                         38
    * 0x09, 0x31,                    //   Usage (Y)                         40
    *
    * So byte 39 contains Usage X and byte 41 Usage Y.
    *
    * We simply swap the axes here.
    */
    data[39] = 0x31;
    data[41] = 0x30;

    return 0;
}

char _license[] SEC("license") = "GPL";
```

// iterator
```c
SEC("iter/task_file")
int dump_task_file(struct bpf_iter__task_file *ctx)
{
    struct seq_file *seq = ctx->meta->seq;
    struct task_struct *task = ctx->task;
    struct file *file = ctx->file;
    __u32 fd = ctx->fd;

    if (task == NULL || file == NULL)
        return 0;

    if (ctx->meta->seq_num == 0) {
        count = 0;
        BPF_SEQ_PRINTF(seq, "    tgid      gid       fd      file\n");
    }

    if (tgid == task->tgid && task->tgid != task->pid)
        count++;

    if (last_tgid != task->tgid) {
        last_tgid = task->tgid;
        unique_tgid_count++;
    }

    BPF_SEQ_PRINTF(seq, "%8d %8d %8d %lx\n", task->tgid, task->pid, fd,
            (long)file->f_op);
    return 0;
}
```

#### Helper函数

- bpf_cgrp_storage_delete
- bpf_cgrp_storage_get
- bpf_copy_from_user
- bpf_copy_from_user_task
- bpf_current_task_under_cgroup
- bpf_d_path
- bpf_dynptr_data
- bpf_dynptr_from_mem
- bpf_dynptr_read
- bpf_dynptr_write
- bpf_find_vma
- bpf_for_each_map_elem
- bpf_get_attach_cookie  v5.19
- bpf_get_branch_snapshot
- bpf_get_current_ancestor_cgroup_id
- bpf_get_current_cgroup_id
- bpf_get_current_comm
- bpf_get_current_pid_tgid
- bpf_get_current_task
- bpf_get_current_task_btf
- bpf_get_current_uid_gid
- bpf_get_func_arg
- bpf_get_func_arg_cnt
- bpf_get_func_ip
- bpf_get_func_ret
- bpf_get_ns_current_pid_tgid
- bpf_get_numa_node_id
- bpf_get_prandom_u32
- bpf_get_smp_processor_id
- bpf_get_socket_cookie
- bpf_get_stack
- bpf_get_stackid
- bpf_get_task_stack
- bpf_jiffies64
- bpf_kptr_xchg
- bpf_ktime_get_boot_ns
- bpf_ktime_get_ns
- bpf_ktime_get_tai_ns
- bpf_loop
- bpf_map_delete_elem
- bpf_map_lookup_elem
- bpf_map_lookup_percpu_elem
- bpf_map_peek_elem
- bpf_map_pop_elem
- bpf_map_push_elem
- bpf_map_update_elem
- bpf_per_cpu_ptr
- bpf_perf_event_output
- bpf_perf_event_read
- bpf_perf_event_read_value
- bpf_probe_read
- bpf_probe_read_kernel
- bpf_probe_read_kernel_str
- bpf_probe_read_str
- bpf_probe_read_user
- bpf_probe_read_user_str
- bpf_probe_write_user
- bpf_ringbuf_discard
- bpf_ringbuf_discard_dynptr
- bpf_ringbuf_output
- bpf_ringbuf_query
- bpf_ringbuf_reserve
- bpf_ringbuf_reserve_dynptr
- bpf_ringbuf_submit
- bpf_ringbuf_submit_dynptr
- bpf_send_signal
- bpf_send_signal_thread
- bpf_seq_printf
- bpf_seq_printf_btf
- bpf_seq_write
- bpf_sk_storage_delete  v5.11
- bpf_sk_storage_get  v5.11
- bpf_skb_output
- bpf_skc_to_mptcp_sock
- bpf_skc_to_tcp6_sock
- bpf_skc_to_tcp_request_sock
- bpf_skc_to_tcp_sock
- bpf_skc_to_tcp_timewait_sock
- bpf_skc_to_udp6_sock
- bpf_skc_to_unix_sock
- bpf_snprintf
- bpf_snprintf_btf
- bpf_sock_from_file
- bpf_spin_lock
- bpf_spin_unlock
- bpf_strncmp
- bpf_tail_call
- bpf_task_pt_regs
- bpf_task_storage_delete
- bpf_task_storage_get
- bpf_this_cpu_ptr
- bpf_timer_cancel
- bpf_timer_init
- bpf_timer_set_callback
- bpf_timer_start
- bpf_trace_printk
- bpf_trace_vprintk
- bpf_user_ringbuf_drain
- bpf_xdp_get_buff_len
- bpf_xdp_output

#### KFunc

- bpf_arena_alloc_pages
- bpf_arena_free_pages
- bpf_cast_to_kern_ctx
- bpf_cgroup_acquire
- bpf_cgroup_ancestor
- bpf_cgroup_from_id
- bpf_cgroup_release
- bpf_copy_from_user_str
- bpf_cpumask_acquire
- bpf_cpumask_and
- bpf_cpumask_any_and_distribute
- bpf_cpumask_any_distribute
- bpf_cpumask_clear
- bpf_cpumask_clear_cpu
- bpf_cpumask_copy
- bpf_cpumask_create
- bpf_cpumask_empty
- bpf_cpumask_equal
- bpf_cpumask_first
- bpf_cpumask_first_and
- bpf_cpumask_first_zero
- bpf_cpumask_full
- bpf_cpumask_intersects
- bpf_cpumask_or
- bpf_cpumask_release
- bpf_cpumask_set_cpu
- bpf_cpumask_setall
- bpf_cpumask_subset
- bpf_cpumask_test_and_clear_cpu
- bpf_cpumask_test_and_set_cpu
- bpf_cpumask_test_cpu
- bpf_cpumask_weight
- bpf_cpumask_xor
- bpf_dynptr_adjust
- bpf_dynptr_clone
- bpf_dynptr_from_skb
- bpf_dynptr_is_null
- bpf_dynptr_is_rdonly
- bpf_dynptr_size
- bpf_dynptr_slice
- bpf_dynptr_slice_rdwr
- bpf_get_dentry_xattr
- bpf_get_file_xattr
- bpf_get_fsverity_digest
- bpf_get_kmem_cache
- bpf_get_task_exe_file
- bpf_iter_bits_destroy
- bpf_iter_bits_new
- bpf_iter_bits_next
- bpf_iter_css_destroy
- bpf_iter_css_new
- bpf_iter_css_next
- bpf_iter_css_task_destroy
- bpf_iter_css_task_new
- bpf_iter_css_task_next
- bpf_iter_kmem_cache_destroy
- bpf_iter_kmem_cache_new
- bpf_iter_kmem_cache_next
- bpf_iter_num_destroy
- bpf_iter_num_new
- bpf_iter_num_next
- bpf_iter_scx_dsq_destroy
- bpf_iter_scx_dsq_new
- bpf_iter_scx_dsq_next
- bpf_iter_task_destroy
- bpf_iter_task_new
- bpf_iter_task_next
- bpf_iter_task_vma_destroy
- bpf_iter_task_vma_new
- bpf_iter_task_vma_next
- bpf_key_put
- bpf_list_pop_back
- bpf_list_pop_front
- bpf_list_push_back_impl
- bpf_list_push_front_impl
- bpf_local_irq_restore
- bpf_local_irq_save
- bpf_lookup_system_key
- bpf_lookup_user_key
- bpf_map_sum_elem_count
- bpf_obj_drop_impl
- bpf_obj_new_impl
- bpf_path_d_path
- bpf_percpu_obj_drop_impl
- bpf_percpu_obj_new_impl
- bpf_preempt_disable
- bpf_preempt_enable
- bpf_put_file
- bpf_rbtree_add_impl
- bpf_rbtree_first
- bpf_rbtree_remove
- bpf_rcu_read_lock
- bpf_rcu_read_unlock
- bpf_rdonly_cast
- bpf_refcount_acquire_impl
- bpf_send_signal_task
- bpf_sock_destroy
- bpf_task_acquire
- bpf_task_from_pid
- bpf_task_from_vpid
- bpf_task_get_cgroup1
- bpf_task_release
- bpf_task_under_cgroup
- bpf_throw
- bpf_verify_pkcs7_signature
- bpf_wq_init
- bpf_wq_set_callback_impl
- bpf_wq_start
- cgroup_rstat_flush
- cgroup_rstat_updated
- crash_kexec
- hid_bpf_allocate_context 
- hid_bpf_get_data 
- hid_bpf_hw_output_report 
- hid_bpf_hw_request 
- hid_bpf_input_report 
- hid_bpf_release_context 
- hid_bpf_try_input_report 
- scx_bpf_cpu_rq
- scx_bpf_cpuperf_cap
- scx_bpf_cpuperf_cur
- scx_bpf_cpuperf_set
- scx_bpf_destroy_dsq
- scx_bpf_dsq_nr_queued
- scx_bpf_dump_bstr
- scx_bpf_error_bstr
- scx_bpf_exit_bstr
- scx_bpf_get_idle_cpumask
- scx_bpf_get_idle_smtmask
- scx_bpf_get_online_cpumask
- scx_bpf_get_possible_cpumask
- scx_bpf_kick_cpu
- scx_bpf_now
- scx_bpf_nr_cpu_ids
- scx_bpf_pick_any_cpu
- scx_bpf_pick_idle_cpu
- scx_bpf_put_cpumask
- scx_bpf_put_idle_cpumask
- scx_bpf_task_cgroup
- scx_bpf_task_cpu
- scx_bpf_task_running
- scx_bpf_test_and_clear_cpu_idle


## 其它程序类型
