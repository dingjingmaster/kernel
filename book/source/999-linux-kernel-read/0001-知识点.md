# 知识点

## 统一编址和独立编址

概念：
- 独立编址：独立编址是说，内存和外设分别编址，同样一个32根地址线的处理器，内存可用的地址空间为4G，外设可用的地址空间也为4G，独立编址里采用了不同的地址总线来区分是访问内存还是访问外设，也就是说，独立编址就是内存一根总线，外设一根总线，他们互不干涉，通过指令来加以区分。对于x86架构来说，通过IN/OUT指令访问（单独编址）。PC架构一共有65536个8bit的I/O端口，组成64K个I/O地址空间，编号从0~0xFFFF，有16位，80x86用低16位地址线A0-A15来寻址。连续两个8bit的端口可以组成一个16bit的端口，连续4个组成一个32bit的端口。`cat /proc/ioports`
- 统一编址：外设接口中的IO寄存器（即IO端口）与主存单元一样看待，每个端口占用一个存储单元的地址，将主存的一部分划出来用作IO地址空间，统一编址也称为“I/O内存”方式，外设寄存器位于“内存空间”（很多外设有自己的内存、缓冲区，外设的寄存器和内存统称“I/O空间”）。

实际使用：
- 对于某一既定的系统，它要么是独立编址、要么是统一编址，具体采用哪一种则取决于CPU的体系结构。 如，PowerPC、m68k等采用统一编址，而X86等则采用独立编址，存在IO空间的概念。目前，大多数嵌入式微控制器如ARM、PowerPC等并不提供I/O空间，仅有内存空间，可直接用地址、指针访问。但对于Linux内核而言，它可能用于不同的CPU，所以它必须都要考虑这两种方式，于是它采用一种新的方法，将基于I/O映射方式的或内存映射方式的I/O端口通称为“I/O区域”（I/O region），不论你采用哪种方式，都要先申请IO区域：request_resource()，结束时释放它：release_resource()。
- 访问IO端口有2种途径：I/O映射方式（I/O－mapped）、内存映射方式（Memory－mapped）。前一种途径不映射到内存空间，直接使用intb()/outb()之类的函数来读写IO端口；后一种MMIO是先把IO端口映射到IO内存（“内存空间”），再使用访问IO内存的函数来访问IO端口。

![](imgs/0001-0.png)

## PC的I/O接口三种控制方式

- 程序循环查询方式-死等，效率低，成本低，CPU浪费资源参与
- 中断处理方式-提前设定好中断向量及中断处理服务程序
- DMA方式-硬件支持，效率高成本高，需要CPU参与的工作少

## BIOS与COMS

- 传统的CPU寻址能力只有1MB，在其后发展过程中为了兼容，持续保持各个架构的套路，就算是现在的PC，开机后依然是实模式，依然是只能用1MB物理内存空间。经过资源获取、部署、指令跳转等操作变成32位甚至64位CPU模式。
- BIOS一直都是，一开始就是规定的放在内存的最高处，就算现在的PC架构也是，但是运行的时候还是加载到1MB低物理内存地址里面。
- BIOS程序比较固定，走固定路线固定套路，效率也比较低，所以OS开发一般只在开机的时候借助BIOS辅助启动，之后就废弃掉BIOS提供的一些功能。
- CMOS，也就是BIOS中的参数，它独立编址的哦，CMOS是个硬件存储器，只有64B或者128B，还需要电池供电，不然就丢数据。

![](imgs/0001-1.png)
![](imgs/0001-2.png)

## 控制器和控制卡

- 8259A可编程中断控制芯片，BIOS阶段会初始化中断控制器芯片，建立中断向量表及其处理服务例程。但是并不给Intel接收，OS会自己再初始化一波。Linux会在内核初始化期间重新初始化中断控制器。

![](imgs/0001-3.png)

![](imgs/0001-4.png)

- 8237芯片-DMA控制器，想要用DMA进行数据传输，必须先对DMA控制器进行编程。它毕竟是硬件帮助你数据传输，传输的时候CPU可以干别的事情，并行工作，更高效，当然硬件就是贵。
- DMA使用前必须设置，有三个寄存器需要设置，8位和16位，但是实模式只能一次性搞定8位寄存器，16位就需要分两次进行。
- 键盘控制器为了兼容，总是把扫描码转换成最古老的第一套扫描集。

![](imgs/0001-5.png)

- 对磁盘控制器的编程其实就是通过I/O端口设置控制器中的相关寄存器，并通过寄存器获取操作的结果。

## as86汇编器

- as86虽然可以编译16位和32位程序，但是Linux仅用它来编译boot/bootsect.s和boot/setup.s。主要是因为其16位支持特色。
- as86采用Intel汇编
- 汇编器编译产生的目标文件至少包括3个段
    - text段：代码段，包括代码和只读数据
    - data段：可读写数据且已经初始化
    - 未初始化数据段：目标文件没有为该段保留空间，但是链接的时候会把该段内容填充0
- 伪操作符=汇编伪指令=汇编指示符
    - 例如 .global begtext,begdata,begbss
- 一个汇编源文件主要包括辣么几部分，赋值语句+伪操作符语句+机器指令语句
    - 赋值语句=定义一个符号常量
    - 伪操作符语句=指示符+0个或多个操作数，不会产生机器码，仅作用于汇编阶段指示汇编器动作
    - 机器指令语句=机器指令的助记符=操作码+0个或多个操作数

![](imgs/0001-6.png)

![](imgs/0001-7.png)

- as汇编器具备预处理功能
    - 删除多余空格字符和制表符
    - 删除所有注释符
    - 字符常量转换成对应的数字
## C语言程序

![](imgs/0001-8.png)

![](imgs/0001-9.png)

- 预处理器：将.c 文件转化成 .i文件，使用的gcc命令是：gcc –E，对应于预处理命令cpp；
- 编译器：将.c/.h文件转换成.s文件，使用的gcc命令是：gcc –S，对应于编译命令 cc –S；
- 汇编器：将.s 文件转化成 .o文件，使用的gcc 命令是：gcc –c，对应于汇编命令是 as；
- 链接器：将.o文件转化成可执行程序，使用的gcc 命令是： gcc，对应于链接命令是 ld；
- 加载器：将可执行程序加载到内存并进行执行，loader和ld-linux.so。

## ELF可重定位目标文件结构

![](imgs/0001-10.png)

## 内核虚拟内存布局

![](imgs/0001-11.png)

## 处理目标文件常用工具

- ar ：创建静态库，插入、删除、列出和提取成员；
- strings ：列出目标文件中所有可以打印的字符串；
- strip ：从目标文件中删除符号表信息；
- nm ：列出目标文件符号表中定义的符号；
- size ：列出目标文件中节的名字和大小；
- readelf ：显示一个目标文件的完整结构，包括ELF 头中编码的所有信息。
- objdump ：显示目标文件的所有信息，最有用的功能是反汇编.text节中的二进制指令。
- ldd ：列出可执行文件在运行时需要的共享库。

![](imgs/0001-12.png)

## 内嵌汇编 与 寄存器

- C语言内嵌汇编。C语言不能直接操作寄存器，所以，所有直接操作寄存器的活儿都得内嵌汇编来完成。

![](imgs/0001-13.png)

- asm或asm用来声明一个内联汇编表达式，所以任何一个内联汇编表达式都是以它开头的，是必不可少的。
![](imgs/0001-14.png)
![](imgs/0001-15.png)
![](imgs/0001-16.png)
![](imgs/0001-17.png)
![](imgs/0001-18.png)

- volatile 关键字可以让gcc不要做过多不必要的优化。
- ISO C99标注和gcc的内联有较大区别，把gcc使用的inline static当成inline

## C与汇编程序的互相调用

![](imgs/0001-19.png)

## a.out目标文件格式

![](imgs/0001-20.png)
![](imgs/0001-21.png)

- 强调一下，重定位信息只供链接器使用。每一条重定位信息都有专门的格式
![](imgs/0001-22.png)

![](imgs/0001-23.png)
![](imgs/0001-24.png)

- strip命令可以剥离符号表信息，其实吧，符号信息就是某个地址对应了那个标号。这个，很容易知道哪个变量，哪个函数的地址了。逆向的时候求之不得，逆向难点就在于，搞不清楚起点终点，变量是啥，什么用。

![](imgs/0001-25.png)

- Linux 0.12中进程的逻辑地址空间大小为64MB。进程在逻辑地址空间从0地址处开始，区别于现代系统0x0804,8000开始

![](imgs/0001-26.png)

- 对于linux下的elf可执行文件来说,代码段的起始地址0x08048000既是逻辑地址,也是线性地址也是虚拟地址

![](imgs/0001-27.png)

由上图可知，32位平台中，进程虚拟地址范围为0x00000000-0xFFFFFFFF（共4GB），其中0x00000000-0xBFFFFFFF（共3GB）为用户空间，位于高地址部分的1GB为内核空间，范围为0xC0000000-0xFFFFFFFF。整个进程虚拟地址可分为几个部分

![](imgs/0001-28.png)

- 为嘛一定要在0x0804,8000这个位置开始呢？其实这是默认位置，也是可以改的。博客中提到因为历史遗留，为了兼容呗。反正Linux里面提到历史都是兼容，提到兼容都是历史。

- 在学习《深入理解计算机系统》中链接这一章中，数据讲一个可执行文件包含多个段。在Linux系统中代码段总是从0x08048000处开始，数据段在接下来的4KB对齐的地址处，运行时堆在接下来的读写段之后的第一个4KB对齐的地址处，并通过调用malloc库网上增长，开始于地址0x40000000处的段是为共享库保留的，用户栈总是从地址0xbfffffff处开始，并向下增长，从栈的上部开始于地址0xc0000000处的段是为操作系统驻留存储器部分的代码和数据保留的。
![](imgs/0001-29.png)

```
0x08048000 (32bit OS)
0x00400000 (64bit OS)
```
- 内核日志后台程序klogd用于记录内核异常时对应的地址及其指令，那么这个地址如果仅仅是地址，你又能获取什么有用信息？所以内核编译的时候会把编译好的符号和地址及其所在区域类型弄成一个表格放到System.map文件中。这个文件分三列，每一行一条地址信息。第一列是地址，第二列是所在区域，第三列是符号名称
![](imgs/0001-30.png)
![](imgs/0001-31.png)

## 80x86 保护模式及其编程

- 现代操作系统，都是运行处于保护模式的CPU之上的。所以，掌握好保护模式，才能学好操作系统。
- 段机制和页机制是保护模式的基础，也是实现现代操作系统的基础。只有深刻掌握和理解 CPU 的段页机制，你才能掌握操作系统底层的一些原理。
- 需要注意的是，段机制和页机制是 CPU 这个硬件提供的功能，并不是操作系统提供的。操作系统只是利用了 CPU 的这个功能。

![](imgs/0001-32.png)
![](imgs/0001-33.png)
![](imgs/0001-34.png)
![](imgs/0001-35.png)
![](imgs/0001-36.png)

## GDT、LDT、IDT、门、门描述符

### GDT和LDT

- GDT和LDT类似，都是用于保存段描述符。
- GDT是全局表，所有任务共享；LDT属于每个任务的局部段描述符表，主要用于多任务，给每个任务提供自己的段描述符
- GDT中保存：
    - 常规描述符(S=1)：代码段描述符、数据段描述符
    - 系统描述符(S=0)：调用门描述符、中断门描述符(通常放在IDT中，但是也允许放在GDT中)、陷阱门描述符(通常放在IDT中，理论允许放GDT)、任务门描述符(通常放IDT中， 理论上允许放GDT)、TSS(Task State Segment Descriptor)描述符、LDT(Local Descriptor Table Descriptor)描述符

- 调用门是x86保护模式下一种系统描述符(Type=0xC或0x4)，存放在GDT、LDT中，用于跨级别安全调用函数。关键字段：
    - 目标段选择子：指向内核代码段
    - 目标偏移地址：目标函数入口地址
    - DPL：限定谁能访问该调用门
    - 参数计数字段：切换栈时候从用户态栈拷贝多少参数
- 调用门主要功能：
    - 安全特权级切换(Ring 3->Ring 0)。用户态程序(CPL=3)无法直接跳转到内核态(CPL=0)代码，否则触发#GP异常。调用门提供一个CPU硬件控制的合法通道：CPU检查访问权限(CPL <= 调用门 DPL， 调用门内的目标代码段DPL必须CPL)；检查通过后：1. 切换栈(根据TSS获取Ring 0栈)；2. 压入用户态的CS:EIP和参数；3. 跳到调用门指定的内核入口函数
    - 防止非法跳转：用户不能指定任意Ring 0地址，必须通过操作系统预设的调用门
    - 用于系统调用机制：早期OS、某些嵌入式RTOS，现代 OS 大多改用 `int 0x80` `sysentry`、`syscall`代替调用门

### IDT

- 中断描述符表，存放中断处理入口信息。主要存放：中断门(Interrupt Gate)、陷阱门(Trap Gate)、任务门(Task Gate)
- 中断门：处理硬件中断或软件中断。特点：切换到目标段(通常是内核代码段)；清除IF标志(关闭中断)，避免嵌套中断；通常用于外部设备中断
- 陷阱门：处理异常(如：调试、断点)。与中断门类似，但不清除IF标志(允许嵌套中断)。主要用于CPU异常和调试
- 任务门：通过TSS切换任务来处理中断。IDT中只包含指向TSS的选择子。在现代操作系统中基本不用，因为现代采用基于栈的中断处理，而非硬件任务切换。

> 注意：调用门用于显式调用；而IDT中的门都是被动调用

### 门

门机制是x86保护模式提供的一种安全控制机制，用于受控的改变执行流，尤其在跨特权级调用 或 处理中断、异常时候。

其核心思想：程序不能直接跳转到任意高权限代码，而必须通过 “门” 进入，由 CPU 硬件检查权限并完成必要的上下文切换（栈切换、CS/IP更新）

|门类型|用途|放置位置|
|:-----|:---|:-------|
|调用门(Call Gate)|跨特权级函数调用(用户态->内核态)|GDT/LDT|
|中断门(Interrupt Gate)|硬件/软件中断处理入口|IDT|
|陷阱门(Trap Gate)|异常处理(调试、断点等)|IDT|
|任务门(Task Gate)|硬件任务切换(通过TSS)|IDT或GDT|

### 门描述符

所有门描述符都是系统描述符(S=0)，包含以下核心字段：
- Offset(目标偏移地址)：处理例程的入口偏移
- Selector(段选择子)：目标段(通常是内核代码段)
- Type(类型)：指定调用门的类型
- DPL(Descriptor Privlege Level)：访问该门所需的最低特权级
- P(Present)：描述符是否有效

> 区别：调用门、中断门、陷阱门 --> 目标是代码段 + 偏移地址
> 任务门 --> 目标是 TSS 选择子(任务切换)

## 任务(Task)在x86中的定义

- 在x86保护模式下，任务是CPU硬件管理的执行单元。
- 每个任务有一个TSS(Task State Segment)，TSS保存该任务的：
    - 寄存器状态(EIP、EFLAGS、通用寄存器)
    - 段寄存器(CS、DS、SS等)
    - 栈信息（针对不同的特权级）
    - I/O权限位图
- 任务切换(Task Switch)可以由CPU硬件完成，通过：
    - JMP或CALL到任务门(Task Gate)或TSS描述符
    - 发生中断且IDT项为任务门
- 切换后，CPU自动：
    - 保存当前任务状态到TSS
    - 加载新任务的 TSS
    - 切换 CR3(页目录)，实现地址空间切换(如果 OS 配置)
- 特点
    - 完全由硬件执行（Intel设计的“硬件多任务”）
    - 现代 OS 基本不用硬件任务切换，而是软件调用

## 80x86保护模式内存管理

### 分段机制

- 一般情况下，数据段是非一致的，权限高的可以访问权限低的。代码段要求平级访问，就算权限高也不能访问。访问者没有必要也不可能降低身份去访问权限低的代码。
- 处理器从高特权级降低到低特权级：中断处理程序返回到用户态的时候。
- 代码段有一致性和非一致性，但是数据段总是非一致性。
- 一致性代码段 = 共享代码段 = 特权级变化访问高特权级代码
- 非一致性代码段 = 代码段必须平级访问 = 非一致性数据段可以高级别访问
- 代码段必须不可写，其他段根据段属性划分可读可写。
- GDT 表是全局描述符表，LDT 表是局部描述符表。当我们写段寄存器的时候，只给了16位，剩下80位并未给出，其实这80位的数据将通过查 GDT 表或者 LDT 表来获得。GDT 表和 LDT 表实际上就是一个大数组，数组中的每一项占用 8 个字节。
- 16位选择子作为索引去GDT表查找对应段描述符

![](imgs/0001-37.png)

## 中断

![](imgs/0001-38.png)

外部硬件中断通过NMI或INTR这里两根信号线通知CPU

![](imgs/0001-39.png)

- Linux把中断分成上半部分和下半部分。上半部分在关中断下执行，下半部分在开中断下执行（可被嵌套）

![](imgs/0001-40.png)

![](imgs/0001-41.png)

![](imgs/0001-42.png)

- 进入保护模式必须先配置好GDT和IDT

## 内部中断

![](imgs/0001-43.png)
![](imgs/0001-44.png)
![](imgs/0001-45.png)

- CPU内部的中断包括软中断和硬中断都是不受IF位影响

![](imgs/0001-46.png)
![](imgs/0001-47.png)

- int [number] 中断也是在中断向量表中的

![](imgs/0001-48.png)
![](imgs/0001-49.png)
![](imgs/0001-50.png)
![](imgs/0001-51.png)
![](imgs/0001-52.png)

- 所有IDT中的描述符都叫门

![](imgs/0001-53.png)
![](imgs/0001-54.png)

- 调用门不能放到IDT表中
- 一个中断源就会产生一个中断向量，每个中断向量都对应中断描述符表中的一个门描述符，任何中断源都通过中断向量对应到中断描述符表中的门描述符，通过该门描述符就找到了对应的中断处理程序。
- 中断发生后，采取什么样的动作是由中断处理程序决定的，但该程序是在中断描述符表中找到的，该表决定了中断信号落到哪个程序上，中断向量相当于子弹，门描述符相当于靶子，中断描述符表相当于祖击手，人家指哪就打哪，门描述符位置错了子弹就打错地方了
- 处理器只支持256个中断也就是说0~255中断向量号。

![](imgs/0001-55.png)
![](imgs/0001-56.png)
![](imgs/0001-57.png)

## 保护 CPL+DPL+RPL

- DPL是段描述符的特权级。它的含义是，如果你(处于某个当前特权级下的程序)想访问我这个段，你应当具备什么样的级别。
    - 比如某个政府机构，它规定了，只允许市长及其以上级别的人才能进入。这个机构要求的级别就是 DPL（=0），而市长本人的这个职称就是 CPL（=0）。倘若你一个村长（CPL=3）想进这个地方，必然会被拒绝。
- RPL的值只存在于段选择子中。注意，不是段寄存器中，不是段寄存器中，不是段寄存器中。段选择子就是一个数字，前面讲过，它有三段结构，分别是“索引-TI指示-RPL”它的含义是当前我想以 RPL 这个级别来请求你把这个段选择子置入段寄存器。实际上 RPL 并没有什么用。因为请求者任何时刻都可以让 RPL = 0。但是如果请求者是 CPL = 3 的程序，用 RPL = 0 的级别来请求 DPL = 0的数据段，必然会失败。
    - 省长以省长的身份去办事情的时候（CPL=0的程序以RPL=0的级别去请求DPL=0的数据段），肯定没什么问题。省长以平民的身份去办事情的时候（CPL=0的程序以RPL=3的级别去请求DPL=0的数据段），肯定会失败。
    - 平民以省长的身份去办事情的时候（CPL=3的程序以RPL=0的级别去请求DPL=0的数据段），结果可想而知……失败！！！
- 3环只能加载DPL为3的数据段
- 0环可以加载DPL=0,1,2,3 的数据段
- 数据段权限检查，本质上就是检查能不能把段选择子代入到段寄存器。如果代入成功，表明权限检查通过。如果代入不成功，说明权限不够（CPL在数值上太大了）。数据段权限检查。为什么不是段权限检查？因为数据段权限检查简单。这确实是一个无懈可击的理由。相比于数据段的权限检查，代码段权限检查要更加严格。
- 选择子为0的不能使用。GDT第0项不用，LDT第0项可以用，但一般不用。0选择子可以加载但是不能访问，访问就出错，你懂得~一般保护性异常。
- CPU 的有些指令，只能在 0 环执行。有些内存的访问，也只能在 0 环。这就是所谓的保护。硬件级别的保护
- 代码段描述符中，有DPL字段，它是专门用来描述代码段级别的。分析GDT表中段描述符发现有0环的代码段和3环代码段。这里的DPL表示，只允许特定级别的下的程序跳过来执行，除非被我同意，低特权级的程序才能跳进来执行。所谓的特定级别下的程序，是指的当前CPL的级别是否符合对方代码段DPL字段要求，什么要求？权限高一点
- CPU 是不允许 CPL = 3 的程序直接跳转到 DPL=0 的代码中去执行，这是必须的呀，一跃成上帝想得美
- CPL = 当前特权级 = 始终保存在 cs 或者 ss 段寄存器的低 2 位。

> 如果你细心观察，你总会发现，cs 的最低2位一定是2进制 11，也就是3. 你绝对不可能看到这个值变成 0. 因为 OD 本身就是运行在 3 环的调试器。这是不是意味着，当前特权级永远不会变成 0？
> 如果你想在 VC6.0 中写程序，直接去读取高 2G 地址的数据，一定会报错。如果你当前的特权级被提升为 0 环（简称提权），这时候再去读取高 2G 地址数据，就没有问题了。然而提权并不是这么简单。
> 跨段执行，就是指改变当前的 cs 段寄存器，把另一个代码段的描述符加载到 cs 段寄存器。千万不要想当然的使用 mov ax, 0x08; mov cs, ax，编译器都不会让你通过。前面你也发现，也不存在lcs这样的指令加载段寄存器。

## 跨段执行-就是改变 CS 段寄存器

- 跨段执行，就是指改变当前的 cs 段寄存器，把另一个代码段的描述符加载到 cs 段寄存器。千万不要想当然的使用mov ax, 0x08; mov cs, ax，编译器都不会让你通过。也不存在lcs这样的指令加载段寄存器。
- 改变 cs 段寄存器，可以使用 jmp far 和 call far 等等。注意，除了这两个指令，还有别的，这里不能讲太多。原因还是那样，因为它简单。
> 指令 jmp 可以实现跨段执行代码，但是它并不能提权（无法改变当权特权级），也就是说，即便你跨到了 DPL = 0 的段，你的 CPL 也不会发生任何改变。 除非你原来就是 0 特权级。
- 使用 jmp 跨到 0 环代码段，也是有要求的，除非这个0环代码段描述符同意（这就是所谓的一致代码段）

## 一致代码段与非一致代码段

- 一致代码段 = 共享段。你跑到零环区域执行，代码段属于0环，但是0环允许你执行，并且你执行的权限依然是你的CPL权限。当然，只能用于共享的段，其他别想了，涉及到高特权级才能运行的指令在设计时不会让你运行的，就算有，就当操作系统设计者傻了，CPU也会做检查，有软有硬防护。
- 当段描述符描述代码段时，TYPE 字段的 c 位置 1 说明该段是一致代码段，否则是非一致代码段。 

> 只有得到段描述符的同意，才允许 低权限 的程序跳转进去执行。这种段称为一致代码段。
> 而有些代码段描述符，绝对不允许 低权限的程序跳转进去执行，这种段称为非一致代码段。

- 只有一致代码段，才允许低特权级的程序跳转进去访问。

- 无论如何，jmp far 也无法更改 CPL。即使你的 RPL = 0，也是徒劳。 有没有办法更改 cs 段寄存器，同时也更改 CPL？
- 一致性代码段的特点就是，转移后的特权级不变成DPL，而是保持转移前的低特权级。听从、依从转移前的特权级。既然权限没有变，那就是说明仅仅只是跑到特权级代码段中用低特权执行了一波代码就走而已。

## 调用门

![](imgs/0001-58.png)

- 调用门，是CPU提供给我们的一个功能，它允许 3 环程序（CPL=3）通过这扇“门”达到修改 cs 段寄存器的目的，同时达到提权的目的。
> “门”，是一种系统段描述符（段描述符的 S=0），这个描述符的结构和数据段描述符和代码段描述符有很大区别，这种描述符中嵌入了选择子。
> 如果你在“门”嵌入DPL=0的代码段选择子，那么你在 3 环，就可以通过这扇门，到达0环领空，这时候你的CPL=3就变成CPL=0。
- 调用门就具备了这种功能。你可以在调用门中嵌入选择子 0x0008，这个选择子指向的是 DPL = 0的代码段。然后使用 call far + 调用门描述符的段选择子，跨段到 0x0008 指向的代码段。

![](imgs/0001-59.png)
![](imgs/0001-60.png)
![](imgs/0001-61.png)
![](imgs/0001-62.png)

## 调用门运行步骤

![](imgs/0001-63.png)
![](imgs/0001-64.png)
![](imgs/0001-65.png)

- 务必记住，硬件实现了参数传递。

![](imgs/0001-66.png)
![](imgs/0001-67.png)
![](imgs/0001-68.png)
![](imgs/0001-69.png)

- 这个retf返回比较重要，构造返回过程。Linux系统初始化阶段跳转到init1进程，从内核态跳转到用户态，就要构造一个环境供retf跳转。
- 返回过程中必须要检查，并且是处理器检查DS、FS、GS中选择子所指向的数据段描述符的DPL是否比目标特权级别高，如果高了就是异常，自动填充0。

![](imgs/0001-70.png)

## call far 指令对堆栈的影响

- CPU需要始终保持CS中的CPL和SS中的CPL一致

![](imgs/0001-71.png)
![](imgs/0001-72.png)
![](imgs/0001-73.png)
![](imgs/0001-74.png)
![](imgs/0001-75.png)

- 当使用调用门进行提权的时候，程序由3环进入0环，这时候需要切换栈，也就是说要更改 ss 段选择子和 esp 的值。这时候 CPU 会自动的帮我们把原始 3 环的 ss, esp, 参数（如果有的话）, cs 和 eip 复制到这个 0 环栈中去。一定要注意，这是 CPU 自动帮我们做的事情，和 OS 没有任何关系。
- 切换栈，需要 0 环 ss 段选择子和 esp ，这些值 CPU 是如何找到了呢？TSS

## 中断门

- 和调用门稍稍有点不一样的地方是，中断门提权会在堆栈中多压入一个值——EFLAGS。
- IDT表中各种类型的门，都可以通过 int [index] 汇编指令进入。有一点需要说明的是，使用 int 指令进入中断门，会影响栈。如果从 3 环进入 0 环，有两件事情要做。这些值都是被 CPU 自动保存起来的，和操作系统没有任何关系，这是 CPU 本身固有的特性。
    - 切换成 0 环栈
    - 在 0 环栈压入 ss3, esp3, eflags3, cs3, eip3( ss3 等后面的 3 表示的是 3 环下的栈，栈顶指针，eflags, 3环代码段选择子和返回地址。)
- 很少有使用中断门从 3 环进入 3 环的，这种设计感觉有点傻。

## 任务门

![](imgs/0001-76.png)

- call/jmp可以访问一个任务段，来达到切换一堆寄存器的目的。但是，CPU同时又提供了另一种方法让我们访问任务段——任务门。
- 任务门是安装在 IDT 表中的
- IDT 表中只可以安装 3 种门：中断门、陷阱门和任务门
- 既然都可以使用 call/jmp 来访问任务段了，为什么又弄个任务门来访问段，何必多此一举？仔细想想，使用 int 指令加索引号，是不是比call/jmp加选择子要方便。因为一个 int 0x20 指令（假设我在 IDT[20]处安装了一个任务门描述符）就可以让我切换一堆寄存器。
- 所有的门描述符的里头都嵌入着另一个段的选择子。比如中断门和陷阱门中嵌入了代码段的选择子。任务门也不例外，它里头嵌入了任务段的选择子。
- CPU提供任务门，是为了方便访问任务段。在CPU发生二重错误的时候，会直接跳到 8 号中断，而 8 号中断就是任务门（这是Windows xp 系统设计的任务门），这意味着什么？一旦进入 8 号中断，CPU 会切换一堆寄存器，这时候无论发生什么错误都没什么关系，通过一堆寄存器的切换，CPU 保证能跳到一个正确的地方去执行（除非那个地方也被破坏了），紧接着做一些后续处理（比如收集错误信息），系统蓝屏。

## 陷阱门

- 进入中断门，CPU会把EFLAGS中的IF位置1，而进入陷阱门，CPU并不修改 IF 位。

## TSS-任务状态段

- TSS 段是门于内存中的一段数据
- TSS 段描述符是描述 TSS 段的基址和大小，并且安装在 GDT 表中
- 任务门中嵌入了TSS段选择子，任务门安装在 IDT 表中

![](imgs/0001-77.png)
- 任务是不可以递归调用的，任务不能调用自己，任务调用别的任务的时候，新任务会把老任务的TSS选择子保存起来方便回到老任务。俗称。。保留前任

![](imgs/0001-78.png)

- 任务切换也会切换到另一个LDT
- 任务切换也会切换CR3寄存器值，每个任务都有自己的一套页表
- 使用处理器来实现任务切换是可选的，也可以使用软件实现，Linux就是如此

## 任务门+中断门+陷阱门+调用门比较

- 在x86种有四种门：中断门、陷阱门、调用门、任务门,这些是CPU从硬件层提供的支持。
- 中断描述符IDT表示一个系统表，它与中断或异常向量相联系。每一个中断或异常向量在这个系统表中有对应的中断或异常处理程序入口地址。中断描述符的每一项对应一个中断或异常向量，每个向量由8个字节组成。因此，最多需要`256*8=2048`字节来存放IDT。
- 在运行中断之前，必须初始化IDT（中断描述符表）。
- IDT包含三种类型的中断描述符：任务门、中断门、陷阱门。描述符的第40~43位用于区分不同的描述符（每个描述符有8个字节/64bit）。
- 任务门和其他三种门相比，在任务门中不需要用段内位移，因为任务门不指向某一个子程序的入口，TSS本身是作为一个段来对待的，而中断门、陷阱门和调用门则都要指向一个子程序，所以必须结合使用段选择码和段内位移。此外，任务门中相对于D标志位的位置永远是0.
- 中断门和陷阱门在使用上的区别不在于中断是外部产生的还是有CPU本身产生的，而在于通过中断门进入中断服务程序时CPU会自动将中断关闭（将EFLAGS寄存器中IF标志位置0），以防止嵌套中断产生，而通过陷阱门进入服务程序时则维持IF标志位不变。这是二者唯一的区别。
- 将真正的实现提权——当前特权级从3变为0。当然，CPU 不会让你就这么简单的从3环跨到0环。但是，CPU又必须提供一套方法，来让你完成这个功能。
- DPL = 0 的非一致代码段，是绝对不允许不同特权级的程序跳转进来。可是，我给以给你开个后门，让你进来，然后给你最高权限，允许你胡作非为。这个后门，必须由我（操作系统）来指定，而且只允许你跳转到我指定的地方。
- 所谓的后门，其实有很多，比如中断门，陷阱门，任务门。它们都可以实现提权。
- 陷阱门和中断门是调用门的特殊类，专门用于异常和中断的处理程序。

## Linux 内核模式

- Linux 0.12采用整体式结构的单内核模式。结构紧凑，执行速度快，缺点是，层次结构性不强。

![](imgs/0001-79.png)

- 内核分成五个模块：进程调度模块、内存管理模块、文件系统模块、进程间通信模块、网络接口模块

![](imgs/0001-80.png)

> 虚线表示Linux 0.12还没有实现。典型的VFS也只在0.95版本才有。

![](imgs/0001-81.png)

- 句话很关键，进程调度模块跟其他模块关联最大。从图中进程调度的度（处度、入度）就可看出。所以平常为嘛进程调度极度重要，就是因为它复杂，调度的时候得考虑其他子系统的状态。说白了，就是N中状态机转换机制。

![](imgs/0001-82.png)

## Linux内核对内存的管理和使用

![](imgs/0001-83.png)
![](imgs/0001-84.png)

- 必须搞清楚三个地址：虚拟地址、线性地址、物理地址
    - 虚拟地址：由于程序产生的由段选择符和段内偏移地址两部分组成
    - 逻辑地址：其实就是段内偏移地址
    - 线性地址：虚拟地址到物理地址之间的中间层，是处理器可寻址的内存空间的地址
    - 物理地址：CPU外部总线上寻址物理内存的地址信号
- 虚拟存储

![](imgs/0001-85.png)

- Linux 0.12只给每个程序划分了64MB的虚拟地址空间，也就是0x00000000 到 0x400,0000

![](imgs/0001-86.png)

利用二级或者外部存储空间，使程序能够不受时机物理内存容量的限制。虚拟内存空间要比时机物理内存容量大得多。

![](imgs/0001-87.png)

- 保护模式依然是 段：偏移 访问内存，但是为了保护段，需要添加段保护信息，所以就把曾经直接用来表示段基址的寄存器作为一个索引去访问一个大表格，每个表项就是一个内存段的各种信息，包括访问权限、地址等

![](imgs/0001-88.png)
![](imgs/0001-89.png)

- 段：偏移 这是永恒不变的道理
- GDT、LDT、IDT

![](imgs/0001-90.png)

- GDT和IDT不可获取，但是LDT可有可无。虽然英特尔建议用LDT，你也可以不听它的呀~

- 为了让CPU能够快速定位这三个表格，CPU还特定设置了硬件来记录其地址，那就是GDTR、LDTR、IDTR，因为这些表格都是在内存中的，那么无非就是存一个地址+表格大小，限定了这个表格

![](imgs/0001-91.png)

- LDT也是在GDT中的，LDT不可能在IDT，IDT也必须在GDT。IDT也不可能在LDT
- 任务状态段TSS也是在GDT中，可以在LDT肿么？Linux 0.12不得行哦~理论上是可以的，毕竟Intel大佬说可以。

![](imgs/0001-92.png)
![](imgs/0001-93.png)
![](imgs/0001-94.png)
![](imgs/0001-95.png)
![](imgs/0001-96.png)

- 分页其实方便了内存管理。分配容易，释放难。能够管理好零散的内存块，分页增强了分段的性能。当然没有分段就没有分页，分页地址变换也是建立在分段的基础上，不可能直接取代分段。典型的分页，每个物理页框4KB。分配内存的时候以4KB为单位进行分配

![](imgs/0001-97.png)

- 这里巧妙地安排页目录表和页表大小分别是4KB，刚好可以存1024个表项，这可不是偶然。

![](imgs/0001-98.png)
![](imgs/0001-99.png)

- Linux 0.12奇特之处，其实就算线性地址空间重叠了也没有毛病啊，反正你的空间你的，我的空间我的。互不干扰的。

## 系统时间

- jiffies变量用来统计系统启动以来系统中产生的总节拍数。该变量在系统启动时被初始化为0，接下来没进行一次时钟中断，jiffies自动加1。因此，知道了总的节拍数，然后再除以Hz，即可知系统的运行时间（jiffies/Hz）。
- 对于jiffies+Hz的含义，jiffies表示当前的系统时钟中断数，Hz表示一秒后的时钟中断的增加量，假设time=jiffies+Hz，正如上面所说 ，内核正是利用节拍数来计算系统时钟和系统运行时间的，则通过jiffies+Hz即可间接表示一秒钟。
- 如果系统中某个程序运行一段时间后，需要比较该运行时间是否超过一秒，即可通过比较time和程序运行后的jiffies值来判断是否超过一秒。当然此时，我们需要考虑jiffies变量的回绕问题，不可直接用if（time > jiffies）来比较，linux系统提供了4个宏定义来解决用户空间利用jiffies变量进行时间比较时可能产生的回绕现象

## Linux 引导

![](imgs/0001-100.png)
![](imgs/0001-101.png)
![](imgs/0001-102.png)
![](imgs/0001-103.png)

![](imgs/0001-104.png)
![](imgs/0001-105.png)
![](imgs/0001-106.png)

- 从0x7c00到0x000A,0000都是可以直接使用，不在BIOS部署的特定地址用途地址空间。640KB-50B

![](imgs/0001-107.png)

- system不是由setup.S加载，也是由bootsec.S加载。

![](imgs/0001-108.png)

## setup.S程序

![](imgs/0001-109.png)

- CPU在进入保护模式之前需要设定IDT表，因此在setup.S设定了一个长度为0的空表。

![](imgs/0001-110.png)

- 原来的启动扇区加载的地方用来存放使用BIOS中断获取到的参数

![](imgs/0001-111.png)
![](imgs/0001-112.png)
![](imgs/0001-113.png)

- 通过BIOS获取一大波参数，同时低级初始化一波设备

## head.S程序

![](imgs/0001-114.png)
![](imgs/0001-115.png)

- head.S代码的主要作用是初步初始化中断描述符表中的 256 项门描述符，检查A20地址线是否已经打开，测试系统是否含有数学协处理器。然后初始化内存页目录表，为内存的分页管理做好准备工作。最后跳转到system模块中的初始化程序 init/main.c 中继续执行。


## 初始化程序 - main.c 程序

- 初始化阶段
    - 首先如何分配使用系统物理内存
    - 调用内核各个部分的初始化函数分别对内存管理、中断处理、块设备、字符设备、进程管理以及硬盘和软盘等硬件进行初始化
    - 在完成这些初始化之后，系统各部分已经处于可运行状态
    - 程序手动移到进程0运行
    - 进程0调用`fork()`创建 init 进程
![](imgs/0001-116.png)

- init功能分为四个部分
    - 安装根文件系统
    - 显示系统信息
    - 运行系统初始资源配置rc中的命令
    - 执行登录shell程序

![](imgs/0001-117.png)

## getty 历史

- getty(get teletype writer)，取得电传打字机。
- 终端是一种字符型设备，它有多种类型，通常使用tty来简称各种类型的终端设备。tty是Teletype的缩写。Teletype是最早出现的一种终端设备，很象电传打字机，是由Teletype公司生产的。在Linux系统的设备特殊文件目录/dev/下
    - 串口端口终端（/dev/ttySn）
    - 控制终端（/dev/tty）
    - 伪终端（/dev/pty/）
    - 控制台终端（/dev/ttyn, /dev/console）
    - 虚拟终端（/dev/pts/n）
- tty(中断设备的统称)：tty一词源于teletypes，或者teletypewriters，原来指的是电传打字机，是通过串行线用打印机键盘通过阅读和发送信息的东西，后来这东西被键盘与显示器取代，所以现在叫终端比较合适。终端是一种字符型设备，它有多种类型，通常使用tty来简称各种类型的终端设备。
- pty(虚拟中断 pseudo-terminal)：如果我们远程telnet到主机或使用xterm时不也需要一个终端交互么？是的，这就是虚拟终端pty(pseudo-tty)
- pts/ptmx(pts/ptmx结合使用，进而实现pty)：pts(pseudo-terminal slave)是pty的实现方法，与ptmx(pseudo-terminal master)配合使用实现pty。
## 控制终端(/dev/tty)
    - 如果当前进程有控制终端（Controlling Terminal）的话，那么/dev/tty就是当前进程的控制终端的设备特殊文件。
    - 可以使用命令”ps –ax”来查看进程与哪个控制终端相连。对于你登录的shell，/dev/tty就是你使用的终端，设备号是（5,0）。
    - 使用命令 ”tty”可以查看它具体对应哪个实际终端设备。/dev/tty有些类似于到实际所使用终端设备的一个联接。
## 控制台终端(`/dev/ttyn`、`/dev/console`)
    - 在UNIX系统中，计算机显示器通常被称为控制台终端（Console）。它仿真了类型为Linux的一种终端（TERM=Linux），并且有一些设备特殊文件与之相关联：tty0、tty1、tty2等。
    - 当你在控制台上登录时，使用的是tty1。使用Alt+[F1—F6]组合键时，我们就可以切换到tty2、tty3等上面去。
    - tty1 –tty6等称为虚拟终端，而tty0则是当前所使用虚拟终端的一个别名，系统所产生的信息会发送到该终端上。
    - 因此不管当前正在使用哪个虚拟终端，系统信息都会发送到控制台终端上。
    - 你可以登录到不同的虚拟终端上去，因而可以让系统同时有几个不同的会话期存在。
    - 只有系统或超级用户root可以向/dev/tty0进行写操作，
## 伪终端(/dev/pty/)
    - 伪终端（Pseudo Terminal）是成对的逻辑终端设备，例如`/dev/ptyp3`和`/dev/ttyp3`（或者在设备文件系统中分别是`/dev/pty/m3`和`/dev/pty/s3`）。
    - 它们与实际物理设备并不直接相关。如果一个程序把ttyp3看作是一个串行端口设备，则它对该端口的读/写操作会反映在该逻辑终端设备对的另一个上面（ttyp3）, 而ttyp3则是另一个程序用于读写操作的逻辑设备。这样，两个程序就可以通过这种逻辑设备进行互相交流，而其中一个使用ttyp3的程序则认为自己正在与一个串行端口进行通信。这很象是逻辑设备对之间的管道操作。
    - 对于ttyp3（s3），任何设计成使用一个串行端口设备的程序都可以使用该逻辑设备。但对于使用ptyp3的程序，则需要专门设计来使用ptyp3（m3）逻辑设备。
    - 例如，如果某人在网上使用telnet程序连接到你的计算机上，则telnet程序就可能会开始连接到设备ptyp2（m2）上（一个伪终端端口上）。此时一个getty程序就应该运行在对应的ttyp2（s2）端口上。当telnet从远端获取了一个字符时，该字符就会通过m2、s2传递给 getty程序，而getty程序就会通过s2、m2和telnet程序往网络上返回”login:”字符串信息。这样，登录程序与telnet程序就通过“伪终端”进行通信。通过使用适当的软件，就可以把两个甚至多个伪终端设备连接到同一个物理串行端口上。
- 可见在重定向/dev/ptmx的时候在/dev/pts目录下多了个设备节点11，而当上面这个shell结束的时候再次ls /dev/pts目录，设备节点11又消失了。每open /dev/ptmx就会得到一个新的文件描述符，并且在/dev/pts/目录下生成一个与这个文件描述符对应的新的设备节点
## 串行端口终端(/dev/ttySn)
- 串行端口终端（Serial Port Terminal）是使用计算机串行端口连接的终端设备。
- 计算机把每个串行端口都看作是一个字符设备。有段时间这些串行端口设备通常被称为终端设备，因为那时它的最大用途就是用来连接终端。
- 这些串行端口所对应的设备名称是/dev/tts/0（或/dev /ttyS0）、/dev/tts/1（或/dev/ttyS1）等，设备号分别是（4,0）、（4,1）等，分别对应于DOS系统下的COM1、 COM2等。
- 若要向一个端口发送数据，可以在命令行上把标准输出重定向到这些特殊文件名上即可。例如，在命令行提示符下键入如下命令，会把单词”test”发送到连接在ttyS1（COM2）端口的设备上。
```
echo test > /dev/ttyS1
```

## /etc/motd

`/etc/motd`即messageoftoday（布告栏信息）,每次用户登录时,`/etc/motd`文件的内容会显示在用户的终端.系统管理员可以在文件中编辑系统活动消息,例如：管理员通知用户系统何时进行软件或硬件的升级、何时进行系统维护等.如果shell支持中文,还可以使用中文,这样看起来更易于了解.

> 注：window操作系统也有相关的功能，有的公司员工的工作机是统一管理，用的是windows ，当员工早上来登入工作机可能看到一些如提示信息，/etc/motd实现的作用跟它差不多。

## /etc/issue

/etc/issue文件的使用方法与/etc/motd文件相差不大,它们的主要区别在于：当一个网络用户或通过串口登录系统上时,/etc/issue的文件内容显示在login提示符之前,而/etc/motd内容显示在用户成功登录系统之后.（我们在用ctrl+alt+f1~f7登录到终端tty1~tty6时，会显示提示符字符串，这些字符串就是写在/etc/issue下，可以用vi /etc/issue打开看）

还有一个/etc/issue.net文件，它提供给telnet远程登录程序使用的。默认情况下/etc/issue文件和/etc/issue.net内容一样，如需要，可根据自己需要修改。

```
issue 内的各代码意义
本地端时间的日期；
/l 显示第几个终端机接口；
/m 显示硬件的等级 (i386/i486/i586/i686...)；
/n 显示主机的网络名称；
/o 显示 domain name；
/r 操作系统的版本 (相当于 uname -r)
/t 显示本地端时间的时间；
/s 操作系统的名称；
/v 操作系统的版本.
```

## printf系列可变参数本质

- 首先剧透，printf = vsprintf + write。
    - vsprintf进行字符串格式化
    - write写到终端
- 这里还需要编译器配合，本质上是编译器帮忙搞了一波内建功能buildin。虽然说参数可变，但是你编译的时候，参数四不四已经固定了？因为格式化字符串的内容和参数列表不可能在运行的时候改变的哦，这个要分清。就好像万精油一样，不管什么输出都可以用它，但是前提是，必须在编译之前用，编译后就固定了。这点其实就是泛型
- 本质上是编译器帮忙处理，识别了传递的参数个数啊，参数类型啊，然后帮忙字节对齐访问参数。之所以可变，全都是编译器累死累活帮忙。

![](imgs/0001-118.png)
![](imgs/0001-119.png)
![](imgs/0001-120.png)

```c
int vsprintf(char *buf, const char *fmt, va_list args)
{
    int len;
    int i;
    char * str;
    char *s;
    int *ip;
    int flags;        /* flags to number() */
    int field_width;    /* width of output field */
    int precision;        /* min. # of digits for integers; max
                   number of chars for from string */
    int qualifier;        /* 'h', 'l', or 'L' for integer fields */
    for (str=buf ; *fmt ; ++fmt) {
        if (*fmt != '%') {
            *str++ = *fmt;
            continue;
        }
        /* process flags */
        flags = 0;
        repeat:
            ++fmt;        /* this also skips first '%' */
            switch (*fmt) {
                case '-': flags |= LEFT; goto repeat;
                case '+': flags |= PLUS; goto repeat;
                case ' ': flags |= SPACE; goto repeat;
                case '#': flags |= SPECIAL; goto repeat;
                case '0': flags |= ZEROPAD; goto repeat;
                }
        /* get field width */
        field_width = -1;
        if (is_digit(*fmt))
            field_width = skip_atoi(&fmt);
        else if (*fmt == '*') {
            /* it's the next argument */
            field_width = va_arg(args, int);
            if (field_width < 0) {
                field_width = -field_width;
                flags |= LEFT;
            }
        }
        /* get the precision */
        precision = -1;
        if (*fmt == '.') {
            ++fmt;
            if (is_digit(*fmt))
                precision = skip_atoi(&fmt);
            else if (*fmt == '*') {
                /* it's the next argument */
                precision = va_arg(args, int);
            }
            if (precision < 0)
                precision = 0;
        }
        /* get the conversion qualifier */
        qualifier = -1;
        if (*fmt == 'h' || *fmt == 'l' || *fmt == 'L') {
            qualifier = *fmt;
            ++fmt;
        }
        switch (*fmt) {
        case 'c':
            if (!(flags & LEFT))
                while (--field_width > 0)
                    *str++ = ' ';
            *str++ = (unsigned char) va_arg(args, int);
            while (--field_width > 0)
                *str++ = ' ';
            break;
        case 's':
            s = va_arg(args, char *);
            len = strlen(s);
            if (precision < 0)
                precision = len;
            else if (len > precision)
                len = precision;
            if (!(flags & LEFT))
                while (len < field_width--)
                    *str++ = ' ';
            for (i = 0; i < len; ++i)
                *str++ = *s++;
            while (len < field_width--)
                *str++ = ' ';
            break;
        case 'o':
            str = number(str, va_arg(args, unsigned long), 8,
                field_width, precision, flags);
            break;
        case 'p':
            if (field_width == -1) {
                field_width = 8;
                flags |= ZEROPAD;
            }
            str = number(str,
                (unsigned long) va_arg(args, void *), 16,
                field_width, precision, flags);
            break;
        case 'x':
            flags |= SMALL;
        case 'X':
            str = number(str, va_arg(args, unsigned long), 16,
                field_width, precision, flags);
            break;
        case 'd':
        case 'i':
            flags |= SIGN;
        case 'u':
            str = number(str, va_arg(args, unsigned long), 10,
                field_width, precision, flags);
            break;
        case 'n':
            ip = va_arg(args, int *);
            *ip = (str - buf);
            break;
        default:
            if (*fmt != '%')
                *str++ = '%';
            if (*fmt)
                *str++ = *fmt;
            else
                --fmt;
            break;
        }
    }
    *str = '\0';
    return str-buf;
}
```

![](imgs/0001-121.png)
![](imgs/0001-122.png)
![](imgs/0001-123.png)

## 内核代码

- 内核，很多函数，在初始化期间并不会调用，典型的panic()，panic一调用，系统就JJ，它是针对特定场所提供的。所以，你必须要明白，内核初始化主函数执行过程中，切换到任务0。它初始化其实只是调用内核函数，预分配一些内存用来做缓存，或者外设初始化开始正常工作，硬盘初始化可以读写，软盘初始化等，这些初始化的目的就是为了给后面，正常程序使用做铺垫。初始化，本质，就是分配内存，用来存放对应模块状态或者给对应模块找个坑，让它之后的工作能够正常进行。
- 好比食堂开饭前，大叔大妈忙的啥？肯定是准备菜啊，那种菜摆哪个窗口基本固定(内核新特性=新开特色菜窗口)，但是你得有空间用来摆放菜啊，酱紫童鞋们去食堂，根据窗口标签，知道这个窗口提供什么菜。但是PC很傻很天真，它没有眼睛，你得明确告诉它，当前内核固定到某个地方获取全局参数，固定到某个地方调用函数。
- 辣么多内核函数，类别不同，参数不通，执行流不同，但是，都堆到一个文件里，内核镜像，启动的时候加载内核镜像，这个时候OS kernel就跑起来了。这其中编译器帮我们做了非常多的工作。
- 内核为什么要导出符号？就是那个键值对，“字符串=地址”的形式，就是为了给其他程序使用，你想调用啥就得到固定地址去折腾。可是平常内核模块没有要求我们这么折腾？那还不是编译器链接器，还有内核模块加载器的配合。知道了他们的工作，对底层又是一方不一样的透彻心扉。
- 但是呢？说这么多，到底该如何去领会？该怎么学？。。其实这个问题本质在于，你想学到什么程度？如果你只想理解基本原理，好的，你不用继续看了。因为已经没有啥高大上的原理了。从体系结构到os自举再到task运行，到这一章节之前已经搞定。剩下的章节，其实就是os的扩充，进程调度，怎么个使劲折腾CPU才爽快，文件系统，怎么个存锤子更方便高效等等，衍生出多种调度策略，多种文件系统。。可特么的这些东西目的就一个，高效利用资源。
- 可能某个模块复杂到家，需要你花一辈子时间去搞定，but，有必要么？这年头很多东西都谈扩展性，无非就是留了个接口而已

## 文件系统

![](imgs/0001-124.png)

- minix 文件系统
![](imgs/0001-125.png)
![](imgs/0001-126.png)

- MINIX1.0=inode结点+inode结点位图+磁盘块+磁盘块位图+超级块+引导块
- 整个磁盘设备被分为以1kb为单位的磁盘块，上图中的每一方格表示一磁盘块（i节点块数可变）。
- 引导扇区（boot sector）安装于硬盘的第一个扇区。引导块（boot block）包含一个非常小的引导记录和一个分区表。引导扇区本身512B，但是为了块对齐占用一块磁盘块也就是1KB。
- 每一个分区中的第一个块是超级块（superblock），它包含了定义其他文件系统结构的元数据，并将它们定位在分配给分区的物理磁盘上。占用一个磁盘块，每个超级块占用14字节。
- 节点位图块（inode bitmap block），它确定了哪个节点在使用以及哪个节点是空闲的。
- 节点（inodes），它们在磁盘上有它们自己的空间。每个节点包含了一个文件的信息，包括数据块的位置，即文件所属的区域。一个磁盘块可以表示`1024*8=8192`个i节点的使用情况。每个位代表一个磁盘块是否被占用。
- 区域位图（zone bitmap）跟踪记录数据区域的使用和释放。
- 数据区域（data zone），数据实际上存储的位置。
- 对于位图的两个类型来说，一个bit代表了一个特有的数据区域或者一个特有的节点。如果这个bit是0，这个区域或者节点是空闲的而且可供使用，但是如果这个bit是1，这个数据区域或者节点是在使用中的。
- 节点是什么？它是索引节点（index-node）的缩写，一个节点是在磁盘上的一个256字节的块，而且它存储文件相关的数据。这些数据包括文件的大小；文件的用户和所属组的用户ID；文件模式（即访问权限）；以及三个时间戳具体说明了时间，包括：文件最后访问时间，最后修改时间，以及节点中的数据最后修改时间。
- 节点也包含了：指向硬盘上文件数据所在的位置。在Minix和EXT1-3文件系统中，它是一个数据区域和块的列表。Minix文件系统节点支持9个数据块，7个直接指针和2个间接指针。如果你想了解的更多，这有一个很好的PDF详细描述了Minix文件系统结构，以及在Wikipedia上对节点指针结构的快速概述。

![](imgs/0001-127.png)
![](imgs/0001-128.png)
![](imgs/0001-129.png)
![](imgs/0001-130.png)
![](imgs/0001-131.png)
![](imgs/0001-132.png)

- inode 是 UNIX 操作系统中的一种数据结构，其本质是结构体，它包含了与文件系统中各个文件相关的一些重要信息。在 UNIX 中创建文件系统时，同时将会创建大量的 inode 。通常，文件系统磁盘空间中大约百分之一空间分配给了 inode 表。

![](imgs/0001-133.png)
![](imgs/0001-134.png)
![](imgs/0001-135.png)

- 硬连接不可跨文件系统且不能为目录创建硬链接。软连接就很随意。

![](imgs/0001-136.png)

## 高速缓存

- 缓解cpu与外设速率不匹配的情况

![](imgs/0001-137.png)
![](imgs/0001-138.png)
![](imgs/0001-139.png)
![](imgs/0001-140.png)
![](imgs/0001-141.png)
![](imgs/0001-142.png)
![](imgs/0001-143.png)
![](imgs/0001-144.png)
![](imgs/0001-145.png)
![](imgs/0001-146.png)
![](imgs/0001-147.png)

## 内存管理

- 分页管理一个页面对应的物理页框肯定是连续，但是页面间不一定连续。也就是内部连续，外部不一定连续。


![](imgs/0001-148.png)
![](imgs/0001-149.png)

## 构造工具

![](imgs/0001-150.png)

```c
/*
 *  linux/tools/build.c
 *
 *  (C) 1991  Linus Torvalds
 */
/*
 * This file builds a disk-image from three different files:
 *
 * - bootsect: max 510 bytes of 8086 machine code, loads the rest
 * - setup: max 4 sectors of 8086 machine code, sets up system parm
 * - system: 80386 code for actual system
 *
 * It does some checking that all files are of the correct type, and
 * just writes the result to stdout, removing headers and padding to
 * the right amount. It also writes some system data to stderr.
 */
/*
 * Changes by tytso to allow root device specification
 *
 * Added swap-device specification: Linux 20.12.91
 */
 #include <stdio.h>    /* fprintf */
 #include <string.h>
 #include <stdlib.h>    /* contains exit */
 #include <sys/types.h>    /* unistd.h needs this */
 #include <sys/stat.h>
 #include <linux/fs.h>
 #include <unistd.h>    /* contains read/write */
 #include <fcntl.h>
 #define MINIX_HEADER 32
 #define GCC_HEADER 1024
 #define SYS_SIZE 0x3000
 #define DEFAULT_MAJOR_ROOT 3
 #define DEFAULT_MINOR_ROOT 6
 #define DEFAULT_MAJOR_SWAP 0
 #define DEFAULT_MINOR_SWAP 0
/* max nr of sectors of setup: don't change unless you also change
 * bootsect etc */
 #define SETUP_SECTS 4
 #define STRINGIFY(x) #x
void die(char *str)
{
    fprintf(stderr, "%s\n", str);
    exit(1);
}
void usage(void)
{
    die("Usage: build bootsect setup system [rootdev] [> image]");
}
int main(int argc, char **argv)
{
    int i, c, id;
    char buf[1024];
    char major_root, minor_root;
    char major_swap, minor_swap;
    struct stat sb;
    if ((argc < 4) || (argc > 6))
        usage();
    if (argc > 4)
    {
        if (strcmp(argv[4], "FLOPPY"))
        {
            if (stat(argv[4], &sb))
            {
                perror(argv[4]);
                die("Couldn't stat root device.");
            }
            major_root = MAJOR(sb.st_rdev);
            minor_root = MINOR(sb.st_rdev);
        }
        else
        {
            major_root = 0;
            minor_root = 0;
        }
    }
    else
    {
        major_root = DEFAULT_MAJOR_ROOT;
        minor_root = DEFAULT_MINOR_ROOT;
    }
    if (argc == 6)
    {
        if (strcmp(argv[5], "NONE"))
        {
            if (stat(argv[5], &sb))
            {
                perror(argv[5]);
                die("Couldn't stat root device.");
            }
            major_swap = MAJOR(sb.st_rdev);
            minor_swap = MINOR(sb.st_rdev);
        }
        else
        {
            major_swap = 0;
            minor_swap = 0;
        }
    }
    else
    {
        major_swap = DEFAULT_MAJOR_SWAP;
        minor_swap = DEFAULT_MINOR_SWAP;
    }
    fprintf(stderr, "Root device is (%d, %d)\n", major_root, minor_root);
    fprintf(stderr, "Swap device is (%d, %d)\n", major_swap, minor_swap);
    if ((major_root != 2) && (major_root != 3) &&
            (major_root != 0))
    {
        fprintf(stderr, "Illegal root device (major = %d)\n",
                major_root);
        die("Bad root device --- major #");
    }
    if (major_swap && major_swap != 3)
    {
        fprintf(stderr, "Illegal swap device (major = %d)\n",
                major_swap);
        die("Bad root device --- major #");
    }
    for (i = 0; i < sizeof buf; i++) buf[i] = 0;
    if ((id = open(argv[1], O_RDONLY, 0)) < 0)
        die("Unable to open 'boot'");
    if (read(id, buf, MINIX_HEADER) != MINIX_HEADER)
        die("Unable to read header of 'boot'");
    if (((long *) buf)[0] != 0x04100301)
        die("Non-Minix header of 'boot'");
    if (((long *) buf)[1] != MINIX_HEADER)
        die("Non-Minix header of 'boot'");
    if (((long *) buf)[3] != 0)
        die("Illegal data segment in 'boot'");
    if (((long *) buf)[4] != 0)
        die("Illegal bss in 'boot'");
    if (((long *) buf)[5] != 0)
        die("Non-Minix header of 'boot'");
    if (((long *) buf)[7] != 0)
        die("Illegal symbol table in 'boot'");
    i = read(id, buf, sizeof buf);
    fprintf(stderr, "Boot sector %d bytes.\n", i);
    if (i != 512)
        die("Boot block must be exactly 512 bytes");
    if ((*(unsigned short *)(buf + 510)) != 0xAA55)
        die("Boot block hasn't got boot flag (0xAA55)");
    buf[506] = (char) minor_swap;
    buf[507] = (char) major_swap;
    buf[508] = (char) minor_root;
    buf[509] = (char) major_root;
    i = write(1, buf, 512);
    if (i != 512)
        die("Write call failed");
    close (id);
    if ((id = open(argv[2], O_RDONLY, 0)) < 0)
        die("Unable to open 'setup'");
    if (read(id, buf, MINIX_HEADER) != MINIX_HEADER)
        die("Unable to read header of 'setup'");
    if (((long *) buf)[0] != 0x04100301)
        die("Non-Minix header of 'setup'");
    if (((long *) buf)[1] != MINIX_HEADER)
        die("Non-Minix header of 'setup'");
    if (((long *) buf)[3] != 0)
        die("Illegal data segment in 'setup'");
    if (((long *) buf)[4] != 0)
        die("Illegal bss in 'setup'");
    if (((long *) buf)[5] != 0)
        die("Non-Minix header of 'setup'");
    if (((long *) buf)[7] != 0)
        die("Illegal symbol table in 'setup'");
    for (i = 0 ; (c = read(id, buf, sizeof buf)) > 0 ; i += c )
        if (write(1, buf, c) != c)
            die("Write call failed");
    close (id);
    if (i > SETUP_SECTS * 512)
        die("Setup exceeds " STRINGIFY(SETUP_SECTS)
            " sectors - rewrite build/boot/setup");
    fprintf(stderr, "Setup is %d bytes.\n", i);
    for (c = 0 ; c < sizeof(buf) ; c++)
        buf[c] = '\0';
    while (i < SETUP_SECTS * 512)
    {
        c = SETUP_SECTS * 512 - i;
        if (c > sizeof(buf))
            c = sizeof(buf);
        if (write(1, buf, c) != c)
            die("Write call failed");
        i += c;
    }
    if ((id = open(argv[3], O_RDONLY, 0)) < 0)
        die("Unable to open 'system'");
    if (read(id, buf, GCC_HEADER) != GCC_HEADER)
        die("Unable to read header of 'system'");
    if (((long *) buf)[5] != 0)
        die("Non-GCC header of 'system'");
    for (i = 0 ; (c = read(id, buf, sizeof buf)) > 0 ; i += c )
        if (write(1, buf, c) != c)
            die("Write call failed");
    close(id);
    fprintf(stderr, "System is %d bytes.\n", i);
    if (i > SYS_SIZE * 16)
        die("System is too big");
    return(0);
}
```

## bochs

- Bochs(box)采用模拟技术，不像VMware采用了虚拟化技术，仅模拟I/O操作，效率高。但是Bochs可以模拟出系统在仿真环境的具体状态和精确时序。因此多用来调试OS，模拟OS。
- Bochs是大佬在1994年开发的。运行在多平台，无论哪种平台都可以模拟x86 CPU。这是其他模拟软件无力的地方。虚拟化技术依赖于CPU。而这个纯属于模拟，效率低。
- Bochs运行必备资源

![](imgs/0001-151.png)
