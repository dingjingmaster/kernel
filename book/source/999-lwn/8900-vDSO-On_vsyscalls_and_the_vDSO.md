# On vsyscalls and the vDSO

“vsycall”和“vDSO”段是Linux中用于加速某些系统调用的两种机制。虽然它们的基本功能（提供对不需要在内核模式下运行的功能的快速访问）是相同的，但它们之间存在一些明显的差异。最近，vsycall被视为安全攻击的推动者，因此已经发布了一些补丁来逐步淘汰它。对这些补丁的讨论表明，社区对如何处理安全问题的分歧一如既往地强烈。

vsycall区域是这两种机制中较老的。它是作为执行特定系统调用的一种方式而添加的，这些调用不需要任何实际级别的特权即可运行。经典的例子是`gettimeofday()`；它所需要做的就是读取内核对当前时间的想法。有些应用程序频繁地调用`gettimeofday()`，以至于它们甚至关心一点点开销。为了解决这个问题，内核允许将包含当前时间的页面以只读方式映射到用户空间；该页还包含一个快速`gettimeofday()`实现。使用这个虚拟系统调用，C库可以提供一个快速的`gettimeofday()`，它实际上不必更改为内核模式。

vsycall有一些限制；除此之外，只有少数几个虚拟系统调用的空间。由于达到了这些限制，内核开发人员引入了更灵活的vDSO实现。快速浏览一下现代系统就会发现，这两种系统都仍在使用：

```
cat /proc/self/maps
...
7fffcbcb7000-7fffcbcb8000 r-xp 00000000 00:00 0            [vdso]
ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0    [vsyscall]
```

通过再次输入相同的命令并比较输出，可以看到当前讨论的关键：

```
7fff379ff000-7fff37a00000 r-xp 00000000 00:00 0             [vdso]
ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0     [vsyscall]
```

注意，vDSO区域已经移动，而vsycall页仍然在相同的位置。vsyscall页的位置在内核ABI中是固定的，但是vDSO区域——像用户空间内存布局中的大多数其他区域一样——在每次映射时都具有随机化的位置。

地址空间布局随机化是防御安全漏洞的一种形式。能够溢出堆栈的攻击者通常可以安排目标进程中的函数“返回”到任意地址。根据在该地址找到的指令，这个返回几乎可以导致任何事情发生。返回到C库中的`system()`函数就是一个明显的例子；它可以用来执行任意命令。但是，如果不知道C库在内存中的位置，那么攻击者就很难或不可能跳到有用的位置。

vsycall页中没有`system()`函数，但是有几个机器指令调用系统调用。只要稍作设置，这些指令就可以在堆栈溢出攻击中使用攻击者定义的参数调用任意系统调用——这不是理想的结果。因此，最好消除（或者至少随机化）vsycall页面的位置，以阻止这种类型的攻击。不幸的是，应用程序依赖于该页面的存在和确切地址，因此什么也做不了。

不过Andrew Lutomirski发现了一些可以做到的事情：从vsycall页面中删除所有有用的指令。一个是与vsyscall64 sysctl旋头相关联的，它实际上只对用户模式Linux有用（即使在那里也不能正常工作）；它被直接删除了。还有一些实际上并不是这样的系统调用指令：当系统时间保存正确的值时，如果跳转到它（并因此像代码一样执行），它看起来就像一个系统调用指令。为了解决这个问题，我们将变量移动到一个单独的页面中，并关闭了执行权限。

vsycall页中的剩余代码已被删除，并由一个特殊的陷阱指令替换。试图调用vsycall页面的应用程序将被捕获到内核中，然后内核将在内核空间中模拟所需的虚拟系统调用。结果是一个内核系统调用模拟了一个虚拟系统调用，这个虚拟系统调用被放在那里是为了首先避免内核系统调用。结果是一个“vsycall”，它的执行时间延长了几分之一微秒，但至关重要的是，它不会破坏现有的ABI。在任何情况下，只有当应用程序试图使用vsycall页而不是vDSO页时，才会看到减速。

当代的应用程序大多数时候不应该这样做，除了一个小问题：glibc仍然使用`time()`的vsycall版本。这个问题已经在glibc存储库中得到了修复，但修复可能暂时无法找到用户；同时，`time()`调用将比以前慢一些。这应该不是一个问题，但谁也不知道，所以Andy添加了一个配置选项来保留旧的做事方式。任何担心模拟vsycall页面开销的人都可以设置`CONFIG_UNSAFE_VSYSCALLS`以获得旧的行为。

没有人真正反对整个补丁系列，但是Linus讨厌配置选项的名字；他要求将其命名为`config_legacy_vsycalls`。或者，更好的是，这种改变可以无条件地进行。这导致了PaX开发人员对内核社区如何喜欢隐藏安全问题的相当可预见的反应，对此Linus说：
```
将旧的vdso称为“不安全”作为配置选项是愚蠢的。这是一个政治化的名字，除了你的政治议程，没有什么好的理由。而当我这么说的时候，你却只会说些关于安全的废话。
```
我只想说，从那时起，谈话就开始走下坡路了；有兴趣的人可以在上面引用的消息中跟踪线程链接。

从这个讨论中得出的一个有用的观点是，静态vsycall页面实际上并不是一个安全漏洞；它只是一种资源，可以使攻击者更容易利用系统中其他地方的漏洞。这个方面是否会使页面“不安全”或仅仅是“遗留”，留给读者作为练习。无论哪种方式，删除它都被认为是一个好主意，即使这样做可能会导致内核中真正的安全漏洞保持未修复；争论都是关于命名的。

在撰写本文时，补丁的最终版本还没有发布，但它们将采取的形式相当清晰。静态vsycall页面将不会以当前形式继续存在，仍然使用它的应用程序将继续工作，但会变得稍微慢一些。控制此行为的配置选项可能存在，也可能不存在，但是任何包含此更改的内核（可能是3.1或更高版本）的发行版也将具有不再尝试使用vsycall页面的C库。幸运的是，利用漏洞会变得更加困难。
