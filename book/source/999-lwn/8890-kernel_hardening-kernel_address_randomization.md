# Kernel address randomization

上周的 “内核页面”（Kernel Page）中有一个关于隐藏内核地址与用户空间的简短项目。许多开发者都对这种隐藏方式表示不满，认为它破坏了一些东西（例如 perf），而且没有提供任何真正的额外安全性。不过，攻击者最好不要知道内核数据结构的存放位置，这似乎已经成为一种共识。事实证明，要做到这一点，可能有比简单隐藏指针值更好的方法。

毫无疑问，访问内存中的内核布局对攻击者很有用。正如丹·罗森伯格所说：

```
我同意kptr_restrict是一个不完整的安全特性。然而，我不同意它完全没有用处的说法。实际上，在过去的一年中，每个公开的内核漏洞都利用/proc/kallsyms或其他内核地址泄漏来进行攻击。
```

隐藏内核地址意味着剥夺攻击者获得额外信息的权利，使他们的任务更加困难。这种方法的一个大问题是，大多数系统运行的是库存分发内核。从发行版的内核包中获取所需的地址信息并不是一项特别具有挑战性的任务。因此，在这些系统上，无论指针值是否允许泄漏到用户空间，内核的布局都没有什么神秘之处。

在讨论所有这些问题时，另一个想法出现了：为什么不在引导时随机化内核在内存中的位置呢？地址空间布局随机化长期以来一直被用来抵抗罐头攻击，但内核本身没有采取这种措施。既然内核映像是可重定位的，那么就没有理由总是需要在相同的地址加载它。如果内核在每次引导时为自己计算不同的偏移量，那么它可以在将指针值传递给用户空间之前从指针值中减去该偏移量。这些指针可以被诸如perf之类的工具使用，但是对于那些试图覆盖内核数据结构的人来说，它们将不再有帮助。

Dan一直在研究核空间随机化，并取得了一些成功；事实证明，简单地重新定位内核并不那么困难。尽管如此，他还是遇到了一些潜在的问题。第一个问题是，在引导过程开始时，可用的熵非常少，因此为内核生成一个足够随机的基址并不是完全直接的。似乎可以从实时时钟和时间戳计数器中获得足够的熵位，使攻击者难以在以后获得基址，但一个真正的随机数会更好。

其次，正如李纳斯指出的，内核不是无限可重定位的。有许多对齐要求限制了内核的位置，因此，根据Linus的说法，最多有8-12位的随机化可用。这意味着攻击者最多尝试几千次就可以找到正确的偏移量。考虑到计算机可以非常快地进行尝试，这就没有给站点管理员太多的响应时间。

然而，正如其他人指出的那样，这种随机性可能已经足够了。失败的漏洞利用尝试有很高的概率产生内核漏洞；即使管理员没有立即注意到错误，也应该在某个时候引起他们的注意。因此，秘密接管一个系统的能力已经消失了。除此之外，失败的漏洞利用可能会使整个系统瘫痪（特别是如果，就像许多RHEL系统的情况一样，设置了“panic on oops”标志），或者使系统处于无法进一步利用的状态。迫使攻击者猜测似乎有一个真正的优势。

但是，如果攻击者能够以某种方式找出给定系统在启动时使用的偏移量，那么这种优势就会消失。Dan注意到一种可能发生的方式：非特权的SIDT指令可以用来定位系统的中断描述符表。这个位置又可以用来计算内核的基偏移量。表的动态分配可以解决这个问题，但代价是要弄乱一些非常棘手的早期引导代码。不过，动态分配表可能还有其他优点；如果将表放在每个cpu的区域中，可能会使系统更具可伸缩性。

因此，这个问题是可以解决的，但是，毫无疑问，在其他地方，攻击者可能获得真正的内核空间地址。信息泄露到用户空间的方式太多了。堵住所有这些漏洞看起来像是一项从未真正完成的长期任务。然而，它有可能足够接近，以至于攻击者无法指望知道内核在运行系统中的真实位置。这可能是值得拥有的通过默默无闻获得的一点安全。

