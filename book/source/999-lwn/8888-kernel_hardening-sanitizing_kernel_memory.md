# Sanitizing kernel memory

> “Sanitizing kernel memory”指的是在计算机系统中对内核（kernel）使用的内存区域进行安全清理或覆盖的过程。内核是操作系统的核心部分，负责管理系统资源并与硬件通信。它会处理敏感数据，例如密码、加密密钥和其他关键信息。因此，在这些数据不再需要时，确保它们不会残留在内存中非常重要。通过对内核内存进行清理，可以防止未经授权的进程或用户访问这些残留数据，从而避免潜在的安全漏洞。

内存的内容包括大量至少对攻击者无用的数据，以及少量值得关注的数据。加密密钥、密码等都可能成为恶意攻击者的目标。通常情况下，内核会保护内存不被无权限进程访问，但各种内核漏洞有时会导致内存信息泄露。最近提出的一个修补程序可以在释放页面时对其进行 “清除”。

Larry Highsmith 修改了 PaX 项目的代码，为内核页面添加了一个标记，将其标记为 “敏感 ”页面。这样，这些页面在被释放时就会被清除，因此这些页面泄露的任何信息都将毫无用处。作为改变的部分理由，海史密斯提到了斯坦福大学题为 “粉碎你的垃圾”（Shredding Your Garbage）的论文： 的斯坦福大学论文 “粉碎你的垃圾：通过安全去分配减少数据寿命”，以及从断电系统中恢复内存的 “冷启动 ”攻击。

Highsmith 的补丁通过在释放内存时清除页面（但仅限于标记为敏感的内存），消除了通过内核漏洞或其他手段造成的释放内存内容泄漏情况。Highsmith 最初系列中的另外四个补丁将敏感标记应用于多个内核子系统（加密、审计和密钥处理）。

虽然内核黑客们普遍同意对内存进行消毒的想法，但对于海史密斯的首次尝试还是有一些异议。其中一个微不足道的反对意见在后来的补丁中得到了修正，那就是Signed-off-by一行没有给出他的全名（只有 “Larry H.”）。由于 PaX 项目是由化名为 “PaX 团队 ”的人开发的，因此无法满足内核签名的要求。对于以页面标志的形式占用稀缺资源，与会者提出了更实质性的反对意见。Alan Cox 指出，虚拟内存区域（VMA）标记也可以使用，或者在补丁中设置标记的地方可以直接清除内存：

```
[页面标志非常珍贵，数量很少，如果用完，我们将损失大量额外的内核内存。如果页面标志是免费的，那么这个问题就无关紧要了，但事实并非如此。因此，值得一问的是，究竟是记住 zap 缓冲区更难，还是正确设置和清除标志更难。
```

与会人员还谈到了与挂起和休眠相关的安全问题，Highsmith 声称有安全意识的用户可以完全禁用该功能。考克斯和帕维尔-马切克对此并不认同，他们指出现在的休眠代码可以对写入磁盘的image进行加密。考克斯还担心，把东西标记为敏感会让攻击者更容易得手：

```
如果你有一个叛逃模块，你就已经输了，只不过通过标记敏感内容，你让坏人的工作变得更容易了。这有点像人们将多种来源的地图和俯视图进行视觉叠加的方式，“擦除 ”后的秘密地点会让你眼前一亮，比不做标记更容易找到。
```

归根结底，内核处理的任何内存都可能是敏感的。一些应用程序--尤其是 GPG--会不遗余力地确保其内存不会被交换，并在不再需要时清除密钥和其他敏感数据。正如 Ingo Molnar 所说 “整个内核都包含'不应泄漏'的数据"。这就产生了一种新的方法：对于需要基于 sanitize_mem 启动时间参数的消毒页面的用户，只需在释放所有页面时将其清除即可。随后，Highsmith 发布了一个更小的补丁来实现这一方案。

此外，内核分配的对象小于一个页面，其中可能包含敏感数据。Highsmith 还提交了对 `kfree()` 和 `kmem_cache_free()` 的修改，以便在释放这些对象时将其清除。最终，在启用 `sanitize_mem` 的内核中应用这两个补丁后，所有空闲的内核内存都将被清除。当然，正如几位朋友指出的，在很多情况下，相关内存仍在使用中。

当然，内核如果对内存进行了消毒，就能更好地抵御内存内容的泄露，但根据所要防范的威胁，这可能还不够。针对内存内容的物理攻击（即 “冷启动”）仍可能有效--尽管自由内存无法恢复，而且其他类型的漏洞仍可能在使用中泄漏内存。Highsmith 介绍了对内核信息泄露的分析，该分析部分基于这份有趣的 CVE 和修复这些 CVE 的 git 提交列表。在这份清单中，有六七个信息泄露的例子本可以通过他的修改加以避免。

目前还没有收到进一步的反对意见，而且这些补丁的侵入性并不强，因此似乎有可能在 2.6.31 中使用。

```
为什么不将其作为默认行为呢？
当用户空间使用 sbrks 增加内存时，内核必须将清空的内存交给用户空间，否则会导致数据泄露。从性能角度看，在释放时清除内存可能比在分配内存时清除内存更优越。
我预计子页面内核分配的清除会对性能造成影响。但这种影响可以忽略不计，如果没有影响，那么可以将该补丁的这一部分作为可选参数。
用户空间内存受保护，而内核加密内存受保护，这将消除很大一部分攻击面......我是否遗漏了导致性能不佳的原因？
```

```
空闲的内存在分配时会在使用前被重写（如来自硬盘/网络的 DMA）或清零（如堆栈帧）。
将此作为默认行为将增加超写情况下的性能成本。不过，部分代价可以通过以下方式隐藏起来低优先级内存清理线程，使用适当的指令来避免填满数据缓存，就可以隐藏部分成本。
不过，这种代价的程度只能通过适当的基准测试来确定。至于代价是否可以接受，那就是另一个问题了......
免责声明：我不是内核黑客，所以我可能说得太多了。
```

```
在清零的情况下，释放时清零也会增加性能成本： 即使以某种方式避免了清零所带来的缓存和 CPU 成本，但仍会产生将零写入内存，然后再加载的内存带宽成本，以及在使用时将零加载到缓存的 CPU 延迟成本。相比之下，如果按需清零页面，零会被写入缓存，在很多情况下，用户程序可以从缓存中获得零，这样所需的 CPU 时间和内存带宽都更少。
```

```
我的想法是，在空闲时写入内存是很便宜的（尤其是你可以避免从内存中调入任何东西或从缓存中驱逐任何东西），而任何在写入内存之前读取内核交给它的内存的用户空间应用程序都是坏的。难道这些人没有 valgrind 吗？
```


