# Running the kernel in library mode

曾几何时，运行Linux内核的唯一方法是在一个方便的硬件上作为主要操作系统。但是，从那时起，其他操作模式已经成为可能：例如，内核可以通过虚拟化作为另一个内核的来宾运行，或者作为带有用户模式Linux （UML）端口的用户空间进程运行。一种不受支持的模式是将内核作为库运行，可以从应用程序中调用，但是由于一个补丁集刚刚在linux-kernel列表中首次出现，这种情况似乎即将改变。

这个补丁集由Hajime Tazaki发布，名为LibOS；它在最近的Netdev 0.1会议上被展示（幻灯片[slideshare]）。LibOS的结构就像是一个新的体系结构端口；它可以在内核树的arch/lib下找到。但是这个移植，在构建时，不会产生一个可引导的内核；相反，它会创建一个共享库，然后将其加载到正在运行的进程中。

有人可能想知道为什么这种操作模式会有用。尽管它并不局限于这种特殊用途，但LibOS目前的主要焦点是使Linux网络堆栈可用于用户空间应用程序。用户空间网络栈在Linux世界中并非闻所未闻；它们已经出现在某些性能敏感的设置中好几年了。使用LibOS，不需要编写（或移植）一个新的网络堆栈来在Linux进程中运行；内核的网络堆栈现在可以直接使用了。

不用说，不需要做一点工作就可以从用户空间调用网络堆栈。为了使这种模式成为可能，LibOS开发人员创建了一整套存根函数来替换网络代码使用的各种内核函数。实际上，补丁集的大部分由数千行存根函数组成。它们会做一些事情，比如用基于malloc（）的简单版本替换slab分配器，并且在大多数情况下，完全缩短了文件系统层。完成这些之后，剩下的就是网络堆栈了，它几乎可以让它在进程的地址空间中独立运行。

“几乎足够了”，因为仍然有一些任务留给调用应用程序。例如，`schedule()`没有存根实现；相反，调用代码必须在初始化过程中提供一个。这里的想法是，正在运行的应用程序可能希望对如何管理进程（很可能作为POSIX线程实现）施加一些控制。

目前有两个项目使用LibOS框架。用户空间网络（NUSE）完成了提供运行的用户空间网络堆栈的工作。使用NUSE，可以设置任意的网络拓扑、与其他用户空间机制（如DPDK）的接口，以便快速传输和接收数据包，等等。相反，NS-3系统是一个用于运行网络协议和实现测试的模拟框架。它可以在LibOS网络堆栈之上运行面向网络的应用程序，使用`LD_PRELOAD`技巧将调用重定向到网络系统调用。

使用这些工具可以做很多有趣的事情。出于性能原因在用户空间中运行网络的用户可以考虑使用它，尽管内核的堆栈尚未针对该设置进行性能优化。想要在生产环境中运行MPTCP这样的实验性协议的人可以使用LibOS（使用适当打补丁的内核构建）来获得该特性，而无需触及系统其余部分使用的网络堆栈。也有很多机会使用在用户模式下运行的网络堆栈运行调试工具。

虽然LibOS的工作一直专注于网络堆栈作为首要目标，但它的设计中没有任何限制它的网络。例如，如果想要隔离虚拟文件系统层，则主要是提出所需的额外存根函数的问题。

一个可能出现在脑海中的问题是：这与在内核中存在多年的用户模式Linux端口有什么不同？实际上，UML维护者Richard Weinberger对此很好奇。似乎有一些不同。UML是作为独立的应用程序运行的，而LibOS是作为其他应用程序调用的库运行的。甚至可以在同一个应用程序中同时运行多个LibOS实例。除此之外，在应用程序中隔离单个子系统的想法并不是UML设计的一部分。在更深入地研究了LibOS代码之后，Richard认为它带来了一些有趣的东西。

一个可能需要关注的领域是所有存根函数的维护。它们有很多，只要内核中相应的“真实”版本发生变化，它们就需要更新。很少有维护者在修改自己的子系统时认为他们必须更新libos。因此，libos很可能会在很多时候被破坏。

反过来，这意味着维护问题可能是LibOS在考虑合并到主流内核之前必须克服的主要障碍之一。如果LibOS经常被破坏，开发人员会犹豫是否使用它。如果LibOS的破坏导致了对子系统维护者在自己的代码上工作的抱怨，他们可能会通过要求删除LibOS来回应。为了避免这些缺陷，可能需要找到一些方法来自动创建这些存根函数。当考虑到使工作长期可维护性所需的条件时，创建内核的库模式版本可能会变得很容易。


