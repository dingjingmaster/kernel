# Two PaX features move toward the mainline

随着内核自我保护项目（KSPP）在其形成后的一个半月里不断发展，来自PaX项目的几个特性开始走向主流。用于协调KSPP工作的内核强化邮件列表上的反应是积极的，但是当这些特性被提议用于主线时，对它们的真正考验才会到来。最近发布了两个特定的补丁集，分别针对`PAX_REFCOUNT`和`PAX_MEMORY_SANITIZE`，我们将在这里介绍一下。

## `PAX_REFCOUNT`

由David Windsor发布的`PAX_REFCOUNT`补丁集背后的思想是检测和处理引用计数变量中的溢出。内核使用引用计数来跟踪已经分配的对象，随着对它们的引用的来来去去，增加或减少计数；当计数达到零时，内核释放这些对象。但是，如果内核中有一条路径，当对象引用被删除时，计数不会减少，攻击者可以使用该路径溢出并包装引用计数器，在实际上仍然存在对引用计数器的有效引用时，有效地将其设置为零。该对象将被释放，但仍将被具有引用的对象使用，从而导致`use-after-free`漏洞。

这不是第一次尝试在内核中添加这种溢出保护。但是，早在2012年，当Windsor发布了关于kref的一个相关想法时，这个想法就搁浅了，因为它如何处理溢出。就像最初的PaX补丁一样，Windsor的补丁会在引用计数达到`INT_MAX`时调用`BUG_ON()`，而不是增加它们。如果计数达到`INT_MAX`，这将导致内核崩溃，这是`Greg Kroah-Hartman`反对的：
```
所以如果这个失败了，你保证会让机器崩溃吗？你想说这是一个基于“安全”的修复？
人们想知道我为什么没有头发了……
```

但正如Windsor和其他人指出的那样，如果参考计数即将结束，就不可能实现明智的复苏。另一种方法可能是在计数器达到`INT_MAX`时不更改计数器（并在内核日志中添加警告），但这会导致内存泄漏。总的来说，至少在当时，Kroah-Hartman显然对整个想法持怀疑态度，甚至怀疑`krref wrap`可以被利用。然而，Kees Cook确实描述了漏洞利用的工作方式：
```
根据我所看到的，“正常”的漏洞利用遵循以下模式：

User1: alloc(), inc
user2:公司
User2：解码失败
*重复user2的动作直到换行*
user3:公司
User3: dec, free（）
User1：对已释放的内存进行操作
```

在最近发布的`PAX_REFCOUNT中`，Windsor基本上已经分解了PaX项目的补丁，并将它们应用到4.2.6稳定内核中，尽管他正在重新基于linux-next。他注意到grsecurity论坛上的一个帖子，其中详细记录了该功能。这个实现改变了内核对atomic_t类型的操作，这样就不会发生溢出；不允许超过INT_MAX的增量。此外，会导致溢出的进程会被发送SIGKILL，这样它们就不会造成进一步的破坏。Windsor认为，这一信号可能太严重了：
```
当检测到溢出时，SIGKILL被发送到有问题的进程。这对于最初的上游提交来说可能太激烈了。在发行版有时间吸收它并报告任何未寻址的溢出之前，使用WARN_ON可能更合适。
```
这些补丁还创建了一个`atomic_unchecked_t`类型，它的作用就像今天的`atomic_t`；它不检查溢出。事实上，大部分补丁是针对使用原子变量但不使用它们作为引用计数的各种子系统的；它们被切换为使用新的未检查类型。如果合并了补丁，原子变量的新用户将需要确定它们是否被用作引用计数，或者是否选择适当的原子类型。

到目前为止，对补丁的评论还很少，但是有人怀疑，当补丁被更广泛地发布时，转换所有这些原子类型所需的代码将会引起一些抱怨。可以想象为那些需要检查的变量创建一个新类型，但这需要不断保持警惕，以确保添加到内核的任何引用计数实际上使用了新类型。但是，这个问题在发布的补丁中仍然存在，因为需要仔细检查新的`atomic_unchecked_t`变量，以确保它们没有被用作引用计数。

## `PAX_MEMORY_SANITIZE`

减轻use- afterfree漏洞的影响或阻止各种信息泄漏的一种方法是通过向内存写入零或其他常量值来“清理”正在释放的内存。这就是PAX_MEMORY_SANITIZE特性背后的思想。Laura Abbott在12月21日发布了该功能的部分移植到内核加固中。

特别是，Abbott的补丁将清理功能添加到slab分配器（slab、slob和slub）中，但不像完整的`PAX_MEMORY_SANITIZE`功能那样用于伙伴分配器。这意味着“直接分配给伙伴分配器的分配（即大分配）没有被清理”。实际的清理是使用一个固定值（除x86-64之外的所有体系结构都使用0xff）完成的，该值在释放整个对象之前被写入。雅培计划在新的一年的某个时候考虑将消毒添加到伙伴分配器中。Abbott对PaX版本的特性所做的另一个更改是添加了一个选项来处理分配器缓慢路径中的清理。

Christoph Lameter抱怨说，该功能类似于板条中毒功能，所以应该使用这种机制。Abbott同意这些特性是相似的，但是他说，中毒是一个调试特性，这项工作的目标是内核加固，所以“保持调试特性和非调试特性分开，因此单独的选项和配置似乎更合适”。

当然，消毒的成本是性能。雅培说，她根据基准测量了3-20%的影响。但是，将该特性编译到内核中，但在运行时将其关闭（使用sanitize_slab=off引导选项）的影响可以忽略不计。

Lameter还建议使用`GFP_ZERO`标志将分配在返回之前归零。如果存在为所有分配设置该标志的模式，它将提供“隐含的清理”。但是这样做会将性能影响从自由路径转移到分配端，这通常对性能更敏感，正如Dave Hansen指出的那样。这也意味着未分配的内存在再次分配之前仍将存储前一个对象的潜在敏感内容。

Hansen建议，与其在整个对象中写入固定的清理值，不如写入零可能允许分配路径跳过置零步骤。这可能会减少一些性能影响，尽管在分配时进行归零会使对象的内存缓存处于热状态，正如Lameter指出的那样。但阿博特提到的归零还有另一个缺点：
```
使用非零内存可以更容易地确定错误来自访问经过消毒的内存，而不是其他情况。我不认为如果内存与其他数据值相比仅为零，那么该功能将不会那么强大。
```
总的来说，这两个补丁都相当受欢迎，但硬化名单可能是由那些倾向于看好这些变化的人组成的。根据去年内核峰会上的讨论，从理论上讲，主流开发人员应该更容易接受寻求减轻各种安全漏洞的补丁。如果这些PaX特性最终能够合并，那么还有一些更具侵入性的特性也可能试图挑战linux-内核邮件列表。界限在哪里——或者即使有界限——仍然不清楚，但是像这样的补丁可能有助于定义它。
