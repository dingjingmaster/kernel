# Post-init read-only memory

在2015内核峰会上，开发者们讨论了在内核中加入更多安全加固补丁的想法。作为这一努力的一部分，大家一致认为，重新审视过时的grsecurity补丁是有意义的。这项工作的第一个成果似乎是Kees Cook的初始化后只读内存补丁集。这项工作得到了很好的接受，但是它也突出了加固通用内核所涉及的一些困难。

成功利用漏洞的关键通常是说服内核写入一个意想不到的位置。看看，例如，这个最近的漏洞，它使用驱动程序的错误来覆盖vDSO区域的一部分；这反过来又使攻击者能够在内核模式下运行任意代码。防御这种攻击的一种方法是尽可能地减少允许内核写入的内存。为此，可以部署许多技术，从简单地将数据标记为只读到管理员模式访问预防。然而，有一类数据是由grsecurity开发人员确定的，而目前的技术却忽略了这类数据。

当内核启动时，它会设置大量的数据结构来描述它所运行的硬件以及更多的东西。在许多情况下，这些数据结构将永远不会再被更改，但是，由于它们驻留在可写内存中，它们仍然可以被错误的写操作更改。由Kees发布的post-init只读内存补丁集允许用特殊的`__read_only`注释标记这些数据结构。这将导致它们被放置到一个单独的ELF节中（".data..read_only"）。一旦内核完成了初始化过程，在该段中找到的所有数据都将被标记为只读，永远不会再被更改。到那时，像上面链接的vDSO覆盖这样的漏洞将不再有效。

这种变化似乎是一个明显的胜利：不变的数据被标记为只读，阻止了已知的漏洞利用，也许，也最大限度地减少了简单错误的影响。作为额外的好处，只读数据将保存在一起，从而导致更好的缓存行为。在不久的将来，它似乎是一个明显的合并候选者。这可能会实现，但是，首先，必须回答一个重要的问题：当硬件捕获内核试图写入（初始化后）标记为`__read_only`的内存时，应该发生什么？

## 当事情出错时

这个问题很重要，因为每当一个数据结构被标记为`__read_only`时，就会有潜在的危险：相关的开发人员可能忽略了这样一种情况，即在满月的日子里发生了一系列罕见的事件之后，必须更改该数据结构。或者可能存在不必要地修改数据结构的情况，可能存储已经存在的数据。这种情况在当前的内核中可以工作，但是如果写入的数据被设置为只读，则会中断。Mathias Krause描述了一个这样的经历，其中系统会在恢复序列中失败。正如他所指出的：“你可以想象，调试这种问题有点像PITA。”

理想的解决方案是让编译器捕捉在初始化序列之外修改`__read_only`数据的尝试，但目前这是不可能的。简单地将相关数据结构标记为`const`是行不通的；这些数据结构是在引导过程中写入的，正如PaX Team指出的那样，将它们设置为`const`为编译器提供了各种令人惊讶的、与优化相关的行为。当涉及到编译器时，令人惊讶的行为很少是一件好事。作为替代方案，Mathias建议使用专用的GCC模块来检测不适当的写入。人们似乎一致认为这是一个好主意，但没有这样的模块存在，创建一个模块需要时间。在可以创建检查器模块之前保持这个补丁集似乎是不可取的。

但是，如果没有这样的检查器，几乎肯定会出现内核试图写标记为`__read_only`的东西的情况，要么是因为它被标记为错误，要么是其他一些错误的结果。关于如何处理这类问题，已经提出了许多想法。

最明显的做法是简单地运行内核，对正在运行的进程和整个机器使用通常的结果。Andy Lutomirski支持这种方法，他说：“我们失败了，我们可能会受到攻击，让我们开始吧。”当然，这种方法的问题在于，它会使机器无法运行，可能还会出现一个追踪起来不那么有趣的错误。Ingo Molnar还担心，在大多数桌面情况下，用户永远不会看到oops信息，因此永远不会向开发人员报告。这凸显了在桌面系统上显示此类信息的一个老问题，但这个问题现在不太可能得到解决。

关闭系统的另一种选择是记录错误并尝试继续。Ingo建议直接跳过那些令人不快的指示，然后试着继续，但这个想法并没有走远；正如PaX Team所指出的那样，简单地放弃一个预期的写操作可能会导致一系列奇怪的问题，实际上可能会帮助攻击者进行攻击。相反，Linus建议内核可以将相关页面标记为可写，然后重试该指令。当然，这将从该页删除只读保护，但它将允许系统在为开发人员生成诊断信息的同时继续运行。人们可能不希望在生产系统上以这种方式工作，但对于开发人员来说，这可能是一个非常宝贵的选择。



最后一个难题可能是使用一个内核命令行操作来完全禁用只读标记。这将为遇到bug的用户提供一个选择，并且需要能够完成他们的工作，直到有适当的修复可用。



Kees表示，他目前的方法是默认采用“杀死机器”的方法。他已经实现了命令行选项，并表示Linus的“将页面标记为可写”的建议并不难添加。因此，下一个版本的补丁应该已经解决了目前为止表达的大多数问题。不过，合并可能是比较容易的部分；识别和标记真正的只读数据的任务可能是一个漫长且容易出错的事情，即使从grsecurity开发人员已经完成的工作开始也是如此。好消息是，这项工作将使内核更加安全，提供（可能难以察觉的）性能改进，并在此过程中发现一些错误。
