# CPU之分页机制

现代CPU结合使用分段和分页来实现虚拟内存管理功能。

分页(Paging)是一种将虚拟地址空间映射到物理地址空间的方法。它通过将内存分成固定大小的块(页)来实现虚拟内存的灵活管理。

## 分页模式

Intel CPU 支持以下分页模式

### 32位分页模式(传统分页)

- 页大小可设置4KB和4MB
- 使用两级页表结构：页目录(Page Directory)和页表(Page Table)

### PAE分页模式(Physical Adress Extension)

- 支持物理地址扩展到36位
- 增加了页目录指针表(Page Directory Pointer Table, PDPT)
- 支持4KB和2MB页大小

### 64位分页模式(IA-32e模式或x64模式)

- 48位虚拟地址空间，物理地址支持到52位
- 四级页表：页表级别为PML4 -> PDPT -> 页目录 -> 页表
- 支持4KB、2MB、1GB页大小

## 关键组建

### 虚拟地址结构

- 虚拟地址被分成多个字段，每个字段用于索引不同的页表级别

例如在64位分页中，虚拟地址可能被分为：
- PML4索引(9位)
- PDPT索引(9位)
- 页目录索引(9位)
- 页表索引(9位)
- 页内偏移(12位)

### 页表

每一级页表都是一个数组，数组的每个条目(Entry)指向下一层页表或物理内存页

页表条目包含标志位(如：有效位、读写位、用户/内核位)以及物理地址

### 控制寄存器

- CR3：存放目录的物理地址
- CR0.PG：分页使能位(PG=1开启分页)
- CR4.PAE：启用PAE模式的控制位

## 工作流程

### 启用分页

1. 操作系统将页表加载到内存中，并通过CR3寄存器指定根页表的物理地址
2. 设置CR0.PG位启用分页

### 地址翻译

- CPU根据虚拟地址的每个字段逐级索引页表
- 如果找到有效的页表条目，最终获得物理地址
- 如果未找到(例如：页表条目无效)，触发页错误(Page Fault)，由操作系统处理

### TLB(Translation Lookaside Buffer)

- 为提高性能，CPU会在TLB中缓存页表的部分映射关系
- 若TLB未命中，则重新访问页表

## 分页优点

- 内核隔离：为每个进程提供独立的虚拟地址空间
- 内存保护：通过标志位实现访问权限控制
- 地址空间扩展：支持虚拟地址空间大于物理内存
- 碎片化管理：避免外部碎片问题

## 分页流程示例

### x86分页流程示例

x86 保护模式开启 + 分页模式开启后，寻址过程分为两大阶段：
- 段地址转换
- 页地址转换。

段寻址：使用段寄存器(如：CS、DS、SS等)和段描述符表(GDT、LDT)将**逻辑地址**转为**线性地址**
分页机制：使用页表将**线性地址**映射到**物理地址**

具体流程如下：
1. 逻辑地址=[段选择子:偏移量]，段选择子包含了：索引(用于定位GDT或LDT中段描述符)；TI位(指示是GDT还是LDT)；RPL位(请求权限级别)
2. 根据段先则子(得到) --> 段描述符，段描述符中定义了段属性，包括：基址(Base Address)；段界限(Limit)；访问权限(如：只读/读写、执行等)
3. 根据偏移量得到**线性地址**(至此得到了线性地址)。
4. 分页开启时(CR0.PG=1)，线性地址需要进一步通过页表转为物理地址
5. 从CR3寄存器中读取到页目录基址(页目录存储在物理内存中)
6. 线性地址高10位(页目录索引 Page Directory Index, PDI)；线性地址中间10位(页表索引 Page Table Index, PTI)；线性地址低12位(页内偏移量 Page Offset)
7. CR3指向页目录表第一项，从线性地址高10位读取到指向的是CR3页目录表的第几项 --> 从线性地址中间10位得到页表的第几项 --> 西欧哪个线性地址最后12位得到最终物理地址

举例如下：

假设：
- 段选择子为0x08(对应GDT中第2个描述符)
- 偏移量位0x1234
- CR3 = 0x00100000(页目录物理地址)

段选择子是0x08(GDT中第一个描述符默认不使用)，根据描述符得到段基址，假设段基址是 0x00400000（另外还需根据选择子中设置的Limit、权限等 以及访问的偏移量 判断是否可以访问），偏移量 0x1234  ==> 得到线性地址是：0x00401234

线性地址: 0x00401234 分为三个部分：
`0000 0000 0100 0000 0001 0010 0011 0100`
- 页目录索引(高10位)：0000 0000 01b，表示页目录索引是1
- 页表索引(中10位)：  0000 0000 01b, 表示页表索引是1
- 页内偏移(低12位)：  0010 0011 0100b, 表示页内偏移 0x234(十进制564)

物理地址计算：
- CR3 = 0x00100000 = 0000 0000 0001 0000 0000 0000 0000 0000，页目录是一个4KB表，每项4字节，共1024项  ==> 得到页目录索引项
- 页目录索引为1，即访问第一项：页目录项地址 = 页目录基址 + (页目录索引 x 1) = 0x00100000 + 0x1 x 1 = 0x00100001，假设从中读取到页目录项地址：0x00200000(PDE 指向内容)  ==> 得到页表项
- 页表项解码，从 0x00200000 获取索引4的地址，假设指向： 0x00100000
- 计算物理地址，物理地址 = 页帧/表基址+ 页内偏移量 = 0x00100000 + 0x0234 = 0x00100234

> 注意：虚拟地址 ==> 物理地址，这一操作是CPU内存管理单元(MMU)在指令执行过程中转换的。操作系统负责设置端描述符、页目录表和页表，直到MMU完成正确的转换。

### X86 PAE模式

PAE(Physical Address Extension) 模式是x86处理器的一种内存寻址扩展技术，允许32位处理器支持超过4GB的物理内存。它通过增加页表的长度和修改分页机制，将物理地址从32位扩展为36位，从而支持最多64GB的物理内存。

#### PAE背景
在32位架构下，虚拟地址和物理地址均为32位：
- 虚拟地址空间：每个进程最多访问4GB
- 物理地址空间：最大支持4GB

随着硬件发展，计算机需要支持更多内存，但是直接增加地址位宽会影响兼容性。因此，Intel引入了PAE，作为一种过渡技术。

```
PAE仅在32-bit CPU使用，暂时没用到，所以不做总结。
```
...

