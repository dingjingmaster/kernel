# CPU 之 GDT

## 什么是GDT

GDT即全局描述符表(Global Descript Table)，是x86 系列CPU提供的一种内存分段机制，主要用于保护模式。

GDT是一个数组，每个数组元素称为一个段描述符，每个段描述符包含了一个段的基地址、段限长(Limit)、访问权限信息。

CPU有专门的寄存器保存GDT地址，这个寄存器就是GDTR(Global Descript Table Register)寄存器。

段描述符结构如下：
- 基地址：段的起始地址
- 段限长：定义段的长度
- 访问权限：控制段的访问类型(如：代码段、数据段、系统段) 和 特权级(Ring0 到 Ring3)

## GDT由来

### 8086

8086是20世纪70年代很重要的一款16位CPU，最大寻址空间为 1MB，时钟频率4.77MHz - 10MHz之间，主要支持基本的计算和数据处理。

> 正常情况下16位CPU可寻址范围是：`2^16 = 64KB`，而8086可最大寻址空间为 `1MB` 就是得益于使用了分段寻址模式。

8086采用分段寻址模式，这种模式结合了段寄存器和偏移量来访问内存。
8086四个段寄存器：
- CS(Code Segment): 指向当前代码段，配合IP(Intruction Pointer)指令指针寄存器使用
- DS(Data Segment): 指向当前数据段，配合AX、BX、CX、DX这些通用寄存器使用。默认情况下，数据操作会使用DS作为数据段
- SS(Stack Segment): 指向当前堆栈段，SS指向当前堆栈段，进行函数调用、局部变量存储等操作。配合SP(Stack Pointer)，指向堆栈的顶部。BP(Base Pointer)，常用于访问堆栈中的参数和局部变量。
- ES(Extra Segment): 用于额外的数据段，通常在字符串操作中使用。在字符串操作中于DI配合使用(DS:SI -- ES:DI)。

计算物理地址：
```
物理地址=(段寄存器的值 x 16) + 偏移量
```
或者说
```
物理地址=(段寄存器 左移4位) + 偏移量
```

寻址方式：
- 直接寻址：
  ```
  MOV AX, [0x0010]      ; 从当前段(DS)的偏移量0x0010读取数据到AX寄存器
  ```
- 间接寻址：
  ```
  MOV BX, [2000H]       ; 将 2000H 存入BX
  MOV AX, [BX]          ; 从BX寄存器指定的地址(DS:BX)读取数据到AX
  ```
- 基址寻址：
  ```
  MOV AX, [BX + 4]      ; 使用寄存器+偏移量结合来寻址
  ```
- 索引寻址：
  ```
  MOV AX, [SI + 2]      ; 使用索引寄存器(如DS:SI或ES:DI)于偏移量结合确定地址,
                        ; 常用于操作数组
  ```
- 相对寻址：相对寻址主要用于控制流的跳转，偏移量相对于指令指针(IP)计算。

### 80286

80286 和 8086 一样都是16位架构，只是主频比8086高(通常在6MHz到25MHz之间)，因为引入了保护模式，所以可以支持多达16MB的内存寻址。

80286段寄存器工作原理：
- 在80286保护模式下，每个段寄存器保存的是一个**段选择符**，此段选择符会指向全局描述符表(GDT)中的段描述符
- 每个段描述符包含段基地址、限长、权限信息

80286地址总线是24位，因此可最大寻址16MB(2^24=16MB)，而寄存器是16位的，因此每个段可寻址范围是64KB(2^16=64KB)，这样最多支持16个寄存器就可完成16MB寻址。

## GDT与GDTR

```
+------+------+------+------+
|      |      |      |      |
+-------------+-------------+
|             |             |  M
+-------------+-------------+
.                           .
.                           .
.                           .
+------+------+------+------+
|      |      |      |      |
+-------------+-------------+
|             |             |  N + 3
+-------------+-------------+
|      |      |      |      |
+-------------+-------------+
|             |             |  N + 2
+-------------+-------------+
|      |      |      |      |
+-------------+-------------+
|             |             |  N + 1
+-------------+-------------+
|      |      |      |      |
+-------------+-------------+
|             |             |  N
+-------------+-------------+
.                           .
.                           .
.                           .
+------+------+------+------+
|      |      |      |      |
+-----------UNUSED----------+
|             |             |  0
+-------------+-------------+

==========================    /|\
||          GDTR        ||  ___|
==========================
```
如上图所示，GDTR是保存GDT的寄存器，整个操作系统中只有一个全局描述符表，每个CPU会保留一个全局描述符表的副本(还要于主的全局描述符表保持一致)

GDT相关：
- GDT表的第一个元素(INDEX=0)不被处理器使用。当段寄存器指向其并不会引起异常(CS和SS除外)，但是要访问内存时候则会引起异常，此特性用于检测段寄存器是否被初始化。
- GDT表中每个元素占用8字节(64bit)
- 使用指令`SGDT`将当前GDTR指向的指针保存到指定内存，使用`LGDT`加载GDT到GDTR
- 80286最多支持8192个，因为段偏移最大64KB(取决于数据寄存器位数)，内阁元素8字节，则：64KB/8B = 8192

### GDTR

#### 32-bit GDTR

在16位、32位模式下，GDTR是一个48位寄存器，结构如下：
```
 48             16 15           0
+-----------------+--------------+
| Base(32bit)     | Limit(16bit) |
+-----------------+--------------+
```

#### 64-bit GDTR
```
 79             16 15           0
+-----------------+--------------+
| Base(32bit)     | Limit(16bit) |
+-----------------+--------------+
```

Base提供GDT的起始位置，Limit告诉CPU GDT的长度。


### 16-bit和32-bit GDT

GDT中元素格式如下：
```
63     56  55   52  51  48    47         40   39     32
+---------+-------+--------+----------------+-----------+
| Base    | Flags | Limit  | Access Byte    | Base      |
| 31   24 | 3   0 | 19  16 | 7          0   | 23     16 |
+---------+-------+--------+----------------+-----------+

31                      16   15                       0
+--------------------------+----------------------------+
| Base                     | Limit                      |
| 15                      0| 15                       0 |
+--------------------------+----------------------------+
```
各字段说明如下：
- Base：占3个部分，组成共32位线性地址，代表段的起始地址
- Limit：占2个部分，组成20位，代表段的大小限制
- Access Byte：占1个部分，组成8位，代表访问标志
- Flags：占1个部分，组成3位，标志位

Flags格式如下：
```
 3     2     1    0
+----+-----+----+------+
| G  | DB  | L  | Resv |
+----+-----+----+------+
```
各字段说明如下：
- G：内存粒度大小，如果置0表示Limit限制粒度为；如果置1表示Limit限制粒度位4KB大小
- DB：如果置0，表示定义了16位保护模式字段；如果置1，表示定义了32位保护模式字段
- L：如果置1，表示定义了64位保护模式字段，且置1后DB字段一定置0；置0则DB字段生效
- Resv：保留未使用

通用段描述符Access格式如下：
```
 7     6   5    4   3     2   1    0
+----+--------+----+----+----+----+----+
| P  | DPL    | S  | E  | DC | RW | A  |
+----+--------+----+----+----+----+----+
```

各字段说明如下：
- P：表示当前段是否存在于内存中，要使段可用必须置为1
- DPL：表示段的特权级别(两位) 0 - 3级，0表示最高特权级别(kernel)、3表示最低特权级别(用户程序)
- S：如果置1表示是系统段；如果置0表示代码段/数据段
- E：是否可执行，如果置1表示可执行的代码段；如果置0表示数据段
- DC：方向位
  - 如果是数据段：置0表示向上生长；置1表示向下生长
  - 如果是代码段：置0则只有DPL设置的级别环境下执行；置1则只有等于或高于DPL设置的级别才能执行此代码
- RW：可读写标志：
  - 如果是代码段：置0此段不可访问；置1此段可读。注意：代码段永远不可以执行写操作。
  - 如果是数据段：置0此段不可写；置1此段可写。注意：数据段永远可以执行读操作。
- A：是否可访问位。除非预先设置为1，否则CPU访问此段时候会设置它为1。假如此位值为0，而此描述符存储在只读内存页时候CPU会尝试将其置1而导致页错误。除非有其他需要，否则此位要置1。

系统段描述符Access格式如下：
```
 7     6    5   4    3    2    2   1
+----+--------+----+----------------+
| P  | DPL    | S  | Type           |
+----+--------+----+----------------+
```

各字段说明如下：
- Type：4位，系统段类型说明
    - 针对32位保护模式：
        - 0x1：16-bit TSS (可用)
        - 0x2：LDT
        - 0x3：16-bit TSS (正在使用)
        - 0x9：32-bit TSS (可用)
        - 0xB：32-bit TSS (正在使用)
    - 针对64位模式
        - 0x2：LDT
        - 0x9：64-bit TSS (可用)
        - 0xB：64-bit TSS (正在使用)


Limit字段说明：Limit由20位组成，定义了段内的最大可访问地址，以便限制对内存段的访问。
- 如果Flags的G位设置为0，则Limit字段以字节为单位，最大值位1MB(2^20字节)
- 如果Flags的G位设置为1，则Limit字段以4KB为单位，最大限长可达4GB(2^20 * 4KB = 4GB)
通过Limit字段，可以控制每个段的访问范围，防止越界访问。


### b4-bit GDT

```
 127                                                  96
+-------------------------------------------------------+
| Reserved                                              |
|                                                       |
+-------------------------------------------------------+

 95                                                    64
+-------------------------------------------------------+
| Base                                                  |
| 63                                                 32 |
+-------------------------------------------------------+

63     56  55   52  51  48    47         40   39     32
+---------+-------+--------+----------------+-----------+
| Base    | Flags | Limit  | Access Byte    | Base      |
| 31   24 | 3   0 | 19  16 | 7          0   | 23     16 |
+---------+-------+--------+----------------+-----------+

31                      16   15                       0
+--------------------------+----------------------------+
| Base                     | Limit                      |
| 15                      0| 15                       0 |
+--------------------------+----------------------------+
```

