# Wayland协议与运行模式

## 基本原则

Wayland 协议是一种面向对象的异步协议。所有请求都是对某个对象的方法调用。请求包括一个对象 ID，用于唯一标识服务器上的对象。每个对象都实现了一个接口，请求中包含一个操作码，用于标识要调用接口中的哪个方法。

协议是基于消息的。客户端向服务器发送的信息称为**请求**。从服务器发送给客户端的信息称为**事件**。一条消息有多个参数，每个参数都有特定的类型。

此外，协议还可以指定枚举，将名称与特定的数字枚举值联系起来。这些枚举值主要是描述性的：在导线格式层面，枚举值只是整数。但枚举还有一个次要目的，即增强类型安全性，或为语言绑定或其他类似代码添加上下文。只有在引入枚举属性之前编写的代码在引入枚举属性之后仍能正常工作的情况下，才支持后一种用法；换句话说，添加枚举不应该破坏 API，否则会危及向后兼容性。

枚举可以定义为一组整数，也可以定义为位字段。这可以通过枚举定义中的位域布尔属性来指定。如果该属性为真，则枚举将主要使用位操作进行访问，例如，当枚举的任意多个选择可以一起进行 OR 时；如果该属性为假，或者省略了该属性，则枚举参数只是一串数值。

枚举属性可用于 uint 或 int 参数，但如果枚举定义为位字段，则只能用于 uint 参数。

服务器会向客户端发回事件，每个事件由一个对象发出。事件可以是错误条件。事件包括对象 ID 和事件操作码，客户端可从中确定事件类型。事件既可以根据请求生成（在这种情况下，请求和事件构成一次往返），也可以在服务器状态发生变化时自发生成。
- 连接时会广播状态，状态发生变化时会发送事件。客户端必须监听这些变化并缓存状态。没有必要（或机制）查询服务器状态。
- 服务器会广播一些全局对象的存在，这些全局对象反过来也会广播它们的当前状态。

## 代码生成

`protocol/wayland.xml` 中定义了接口、请求和事件。该 xml 用于生成可供客户端和合成器使用的函数原型。

协议入口点以内联函数的形式生成，内联函数只是封装了 `wl_proxy_*` 函数。内联函数不是库 ABI 的一部分，语言绑定应根据 xml 为协议入口点生成自己的stub(存根)。

## Wire Format

协议通过 UNIX 域流套接字发送，其端点通常命名为 wayland-0（不过可以通过环境中的 `WAYLAND_DISPLAY` 进行更改）。从 Wayland 1.15 版开始，通过将 `WAYLAND_DISPLAY` 设置为服务器端点监听的绝对路径，实现可以选择支持位于文件系统任意位置的服务器套接字端点。

每个报文的结构都是 32 位字；值以主机的字节序表示。报文头有两个字：
- 第一个字是发件人的对象 ID(32 位)
- 第二个有 2 个 16 位的部分。高 16 位是以字节为单位的报文大小，低16位是请求/事件的操作码。

协议体描述请求/事件参数。每个参数总是以 32 位对齐。如果需要填充，则填充字节的值未定义。没有描述类型的前缀，但可从 xml 规范中隐含推断。

参数类型的表示方法如下：
- int, uint：值是32位由符号/无符号整数
- fixed：有符号 24.8 十进制数。这是一种带符号的十进制类型，提供一个符号位、23 位整数精度和 8 位十进制精度。在 C 应用程序接口方面，它是一个不透明的结构体，带有 double 和 int 之间的转换助手。
- string：以无符号的 32 位长度（包括空结束符）开始，接着是字符串内容，包括结束空字节，然后填充到 32 位边界。空值的长度为 0。
- object：32 位对象 ID。空值用 0 表示
- new_id：32 位对象 ID。一般情况下，新对象使用的接口会从 xml 中推断出来，但如果没有指定，new_id 前面会有一个指定接口名称的字符串和一个指定版本的 uint。
- array：以 32 位数组大小（字节）开头，然后是逐字数组内容，最后填充到 32 位边界。
- fd：文件描述符不存储在报文缓冲区中，而是存储在 UNIX 域套接字报文（`msg_control`）的辅助数据中。

协议没有规定辅助数据在数据流中的确切位置，但文件描述符的顺序与报文和报文中的 fd 参数在线路上的顺序相同。

特别是，这意味着流中的任何字节，甚至是报文头，都可以携带带有文件描述符的辅助数据。

客户端和编译器应将接收到的数据排成队列，直到有完整的报文需要处理，因为文件描述符可能比相应的数据字节更早或更晚到达。

## 接口

该协议包括几个用于与服务器交互的接口。如上所述，每个接口都提供请求、事件和错误（实际上只是特殊事件）。特定的合成器实现可能会提供自己的接口作为扩展，但有几个接口是必须存在的。

核心接口如下：
- wl_display：核心全局对象
- wl_registry：全局注册对象
- wl_callback：回调对象
- wl_compositor：合成器单例
- wl_shm_poll：共享内存池
- wl_shm：共享内存支持
- wl_buffer：wl_surface的内容
- wl_data_offer：传输的数据
- wl_data_source：传输的数据
- wl_data_device：数据传输设备
- wl_data_device_manager：数据传输接口
- wl_shell：创建桌面式界面
- wl_shell_surface：桌面式界面元数据
- wl_surface：屏幕
- wl_seat：输入设备组
- wl_pointer：指针式输入设备(比如：鼠标)
- wl_keyboard：键盘输入设备
- wl_touch：触摸屏输入设备
- wl_output：合成器输出区域
- wl_region：区域接口
- wl_subcompositor：子合成器
- wl_subsurface：子绘制界面的wl_surface接口

## 版本

每个接口都有版本，每个协议对象都实现了其接口的特定版本。对于全局对象，服务器支持的最大版本与全局对象一起发布，而创建的协议对象的实际版本则由传递给 `wl_registry.bind()` 的版本参数决定。对于非全局对象，其版本由创建对象推断。

为了保持正常，这对接口版本有一些影响： 
- 创建对象的层次结构必须是树状的。否则，从父对象推断对象版本就很难正确跟踪。
- 当一个接口的版本增加时，其父接口的版本也会增加（递归进行，直至到达全局接口）。
- 全局接口的版本号就像是其所有子接口的计数器。每当子接口被修改，全局父接口的版本号也会增加（见上文）。然后，子接口的版本号就与父全局接口的新版本号相同。

为了说明上述问题，请看 `wl_compositor` 接口。它有两个子接口，即 `wl_surface` 和 `wl_region`。在 wayland 1.2 版本中，`wl_surface` 和 `wl_compositor` 的版本都是 3。如果在 `wl_region` 接口中添加了新内容，`wl_region` 和 `wl_compositor` 都会被降级到版本 4。如果之后更改了 `wl_surface`，那么 `wl_compositor` 和 `wl_surface` 都将处于版本 5。这样，全局接口的版本就成了所有子接口的 “计数器”。这样就可以根据父接口的版本，非常简单地知道子接口的版本。子界面的最高版本小于或等于父界面的版本。

值得注意的是，上述版本控制方案有一个特殊的例外情况。`wl_display` 接口（以及 `wl_registry`）不能更改，因为它是核心协议对象，而且其版本从不对外公布，也没有请求不同版本的机制。

## 连接事件(connect time)

没有固定的连接设置信息，服务器会在连接时发出多个事件，以显示全局对象的存在和属性：输出、合成器、输入设备。

## 安全与认证

- 主要是访问底层缓冲区，需要新的 drm auth 机制（grant-to ioctl），是否需要检查 cmd 流吗？
- 获取服务器套接字取决于编译器类型，可能是系统范围内的名称，也可能是通过会话总线上的 fd 传递。

## 创建对象

每个对象都有一个唯一的 ID。ID 由创建对象的实体（客户端或服务器）分配。客户端分配的 ID 范围为 [1, 0xfeffffffff]，而服务器分配的 ID 范围为 [0xff000000, 0xffffffffff]。0 ID 保留用于表示空对象或不存在的对象。为提高效率，ID 被密集排列，即在 N-1 个 ID 被使用之前，不会使用第 N 个 ID。这种排序方式不仅是一种指导原则，而且是一种严格的要求，有一些协议实现严格执行了这一规则，其中包括无处不在的 libwayland。

## 合成器

合成器是一个全局对象，在连接时广播(发布)。

## 界面区域(Surface)

Surface管理一个矩形的像素网格，客户端创建这些像素网格用于在屏幕上显示其内容。客户端不知道自己的Surface的全局位置，也无法访问其他客户端的Surface。

一旦客户端完成了写像素，它就“提交”缓冲区；这允许合成器访问缓冲区并读取像素。当合成器完成后，它将缓冲区释放回客户端。

## 输入

一个seat代表一组输入设备，包括鼠标、键盘和触摸屏。它有键盘和指针焦点。seat是全局对象。指针事件以surface局部坐标传递。

当按钮被按下时，合成器维护一个隐式抓取，以确保相应的按钮释放事件被传递到相同的Surface。但客户没有办法直接抢焦点。相反，Surface可以映射为‘popup’，它结合了瞬态窗口语义和指针抓取。

为了避免竞争条件，可能触发进一步请求的输入事件（如按钮按下、键事件、指针移动）携带序列号，以及`wl_surface`等请求。`set_popup`要求指定触发事件的序列号。服务器为这些序列号维护一个单调递增的计数器。

输入事件还带有毫秒粒度的时间戳。它们的基数是未定义的，因此它们不能与系统时间（通过`clock_gettime`或`gettimeofday`获得）进行比较。但它们可以相互比较，例如用于识别按下两次或三次点击的按钮序列。

关于以下讨论：
- 键盘映射、change 事件
- wayland上的xkb
- wayland上的多指针

当surface是输入设备鼠标的焦点时，surface可以改变鼠标指针的图像。当鼠标指针进入一个surface时，Wayland不会自动改变指针图像，但希望应用程序设置它想要的光标来响应指针焦点和运动事件。基本原理是客户端必须在响应运动事件时管理界面内UI元素的指针图像的更改，所以我们将使其成为设置或更改指针图像的唯一机制。如果服务器在surface失去指针焦点后收到设置指针图像的请求，则忽略该请求。对于客户端来说，这看起来像是成功地设置了鼠标指针图像。

将鼠标指针图像设置为NULL会导致光标被隐藏。

当没有surface具有该设备的指针焦点时，合成器将把指针图像恢复为默认图像。

如果指针从一个设置了特殊指针图像的窗口移动到一个没有设置响应运动事件的图像的surface，该怎么办？新的surface将被固定在特殊的指针图像上。我们不能在离开一个surface时恢复指针图像，因为如果我们立即进入一个设置了不同图像的surface，鼠标指针图像将会闪烁。如果客户端在指针进入一个曲面时没有设置指针图像，则指针将保持在最后一个改变它的曲面所设置的图像中，甚至可能隐藏。这样的客户端很可能崩溃。

## 输出

输出是一个全局对象，在连接时发布，或者在它来来去去(输出设备反复插拔)时发布。
- 在一个大的（合成）坐标系中布局
- 基于xrandr之上的wayland
- 在合成器座标系统中需要获取位置
- 事件通知可用模式，请求移动和更改模式

## 客户端之间的数据分享

Wayland协议为客户端提供了一种共享数据的机制，允许实现复制粘贴和拖放。提供数据的客户机创建一个`wl_data_source`对象，而获取数据的客户机将把它看作`wl_data_offer`对象。该接口允许客户端就相互支持的mime类型达成一致，并通过通过协议传递的文件描述符来传输数据。

下一节将解释数据源和数据提供对象之间的协商。“数据设备”一节解释了如何使用实现复制粘贴和拖放支持的`wl_data_device`接口创建这些对象并将其传递给不同的客户机。

### 数据协商

向其他客户机提供数据的客户机将创建一个`wl_data_source`对象，并通过`wl_data_source`宣布它支持的数据格式的`mime`类型，发起请求。在接收端，数据提供对象将生成一个`wl_data_offer`。为每个支持的`mime`类型提供事件。

实际的数据传输发生在接收客户端发送`wl_data_offer`时。接收请求。此请求接受`mime`类型和文件描述符作为参数。这个请求将生成一个`wl_data_source`。在发送客户端上使用相同的参数发送事件，并期望后一个客户端使用所选择的`mime`类型将其数据写入给定的文件描述符。

### 数据设备

数据设备将`data_source`和`data_offer`粘合在一起。数据设备与`wl_seat`相关联，并由客户机使用`wl_data_device_manager`工厂对象获得，该工厂对象还负责创建数据源。

通过`wl_data_device.data_offer`事件通知客户端新的数据提供。生成此事件后，数据提供将公布可用的mime类型。在使用复制粘贴或拖放之前引入新的data_offer。

#### 选中

每个数据设备都有一个选择数据源。客户端使用设备管理器创建一个数据源对象，并可将其设置为给定数据设备的当前选择。每当当前选择发生变化时，键盘焦点所在的客户端就会收到一个 `wl_data_device.selection` 事件。该事件也会在客户端收到键盘焦点之前立即生成。

data offer是在选择事件之前通过 `wl_data_device.data_offer` 事件引入的。

#### 拖放

拖放操作通过 `wl_data_device.start_drag` 请求启动。该请求会导致指针抓取，并在数据设备上产生进入、移动和离开事件。数据源作为参数被提供给 `start_drag`，与之相关的数据要约被提供给 `wl_data_device.enter` 事件中指针下的客户端表面。在输入事件之前，会通过 `wl_data_device.data_offer` 事件向客户端提供数据。

客户机应通过调用 `wl_data_offer.accept` 请求向数据发送客户机提供反馈，并提供其接受的 `MIME` 类型。如果接收客户端不支持任何已公布的 `MIME` 类型，则应向 `accept` 请求提供 `NULL`。接受请求会导致发送客户端接收到带有所选 `mime` 类型的 `wl_data_source.target` 事件。

当拖动结束时，接收客户端会收到一个 `wl_data_device.drop` 事件，这时它应该使用 `wl_data_offer.receive` 请求来传输数据。

