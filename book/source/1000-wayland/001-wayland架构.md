# Wayland架构

了解 wayland 架构以及它与 X 有何不同的一个好方法，就是从输入设备开始跟踪一个事件，直到它影响的变化出现在屏幕上。

我们已知的x事件如下传递：

![](img/x-architecture.png)

1. 内核从输入设备获取事件，并通过 evdev 输入驱动程序发送给 X。内核通过驱动设备将不同设备的特定事件协议转换为标准的 Linux evdev 输入事件。
2. X 服务器会确定该事件会影响哪个窗口(一般是当前焦点窗口)，并将其发送给在该窗口上触发了相关事件的客户端。X 服务器实际上并不知道如何正确地完成这项工作，因为窗口在屏幕上的位置是由合成器(或者说窗口管理器)控制的，并可能以 X 服务器无法理解的多种方式（缩放、旋转、摇摆等）进行变换。
3. 客户端查看事件并决定要做什么。通常情况下，用户界面必须根据事件做出改变--可能是点击了一个复选框，或者指针进入了一个必须高亮显示的按钮。因此，客户端会向 X 服务器发送渲染请求。
4. X 服务器收到渲染请求后，会将其发送给驱动程序，让它对硬件进行编程以完成渲染。X 服务器还会计算渲染的边界区域，并将其作为 damage 事件发送给合成器。
5. damage 事件会告诉合成器该窗口发生了变化，它必须重新合成该窗口所在的屏幕部分。合成器负责根据其场景图和 X 窗口的内容渲染整个屏幕的内容。然而，它必须通过 X 服务器来渲染。
6. X 服务器接收到来自合成器的渲染请求，然后将合成器的后缓冲区复制到前缓冲区，或者进行翻页。在一般情况下，X 服务器必须执行这一步骤，以便考虑重叠窗口（可能需要剪切），并确定是否可以翻页。然而，对于始终全屏的合成器来说，这又是一次不必要的上下文切换。

如上所述，这中渲染过程存在一些问题。X 服务器不具备决定哪个窗口应接收事件的信息，也无法将屏幕坐标转换为窗口本地坐标。尽管 X 已将最终绘制屏幕的责任移交给了合成管理器，但 X 仍控制着前端缓冲区和模式设置。X 服务器过去需要处理的大部分复杂问题，现在都可以在内核或自带库中找到（KMS、evdev、mesa、fontconfig、freetype、cairo、Qt 等）。总的来说，X 服务器现在只是一个中间人，在应用程序和编译器之间多了一个步骤，在编译器和硬件之间多了一个步骤。

在 wayland 中，合成器是显示服务器。我们将 KMS 和 evdev 的控制权移交给合成器。wayland 协议允许合成器直接向客户端发送输入事件，并允许客户端直接向合成器发送damage事件： 

![](img/wayland-architecture.png)

1. 内核获取事件并将其发送给合成器。这与 X 的情况类似，非常好，因为我们可以重用内核中的所有输入驱动程序。
2. 合成器通过场景图来确定哪个窗口应该接收事件。场景图与屏幕上的内容相对应，而合成器可以理解应用于场景图中元素的变换。因此，合成器可以选择正确的窗口，并通过应用逆变换将屏幕坐标转换为窗口本地坐标。只要合成器能计算输入事件的逆变换，那么可应用于窗口的变换类型就会受到限制。
3. 在 X 的情况下，客户端收到事件后会更新 UI 作为响应。但在 wayland 案例中，渲染是在客户端进行的，客户端只需向合成器发送一个请求，指出更新的区域。
4. 合成器从客户端收到 damage 事件，然后重新合成屏幕。然后，合成器可以直接发出 ioctl，与 KMS 一起安排翻页。

