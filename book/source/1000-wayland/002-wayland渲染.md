# Wayland渲染

在上述概述中，我忽略了一个细节，那就是客户端在 wayland 下的实际渲染方式。通过移除 X 服务器，我们也移除了 X 客户端通常使用的渲染机制。不过，我们已经在 X 下的 DRI2 中使用了另一种机制：直接渲染。通过直接渲染，客户端和服务器共享一个视频内存缓冲区。客户端链接到一个渲染库（如：OpenGL），该库知道如何对硬件进行编程，并直接在缓冲区中进行渲染。反过来，合成器在合成桌面时，可以将缓冲区用作纹理。初始设置完成后，客户端只需告诉合成器使用哪个缓冲区，以及何时何地将新内容渲染到缓冲区中。

这样，应用程序就有两种更新窗口内容的方法：
1. 将新内容渲染到一个新的缓冲区中，并告诉合成器使用该缓冲区代替旧缓冲区。应用程序可以在每次需要更新窗口内容时分配一个新的缓冲区，也可以保留两个（或更多）缓冲区并在它们之间循环使用。缓冲区管理完全由应用程序控制。
2. 将新内容渲染到上次告诉合成器使用的缓冲区中。虽然可以直接渲染到与合成器共享的缓冲区中，但这可能会与合成器发生竞争。可能发生的情况是，重新绘制窗口内容可能会被合成器重新绘制桌面所中断。如果应用程序在清空窗口后、渲染内容前被中断，合成器将从空白缓冲区进行纹理绘制。其结果是，应用程序窗口将在空白窗口或半渲染内容之间闪烁。避免这种情况的传统方法是将新内容渲染到后置缓冲区，然后从后置缓冲区复制到合成器表面。后置缓冲区可以即时分配，其大小足以容纳新内容，应用程序也可以保留一个缓冲区。同样，这也是由应用程序控制的。

无论是哪种情况，应用程序都必须告诉合成器曲面的哪个区域有新内容。当应用程序直接渲染到共享缓冲区时，合成器需要注意到有新内容。但同样在交换缓冲区时，合成器不会认为有任何变化，它需要应用程序发出请求后才会重新绘制桌面。我们的想法是，即使应用程序向合成器传递了新的缓冲区，缓冲区中也可能只有一小部分内容是不同的，例如闪烁的光标。
