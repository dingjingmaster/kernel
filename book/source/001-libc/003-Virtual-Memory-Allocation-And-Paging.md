# 虚拟内存分配与分页

本章描述了在使用 GNU C 库的系统中，进程如何管理和使用内存。

GNU C库提供了多种函数，用于以不同方式动态分配虚拟内存。这些函数在通用性和效率方面有所不同。该库还提供了控制分页和分配实际内存的函数。

本章未讨论内存映射I/O。请参阅[内存映射I/O]。

## 进程内存概念

进程可用的最基本资源之一是内存。系统组织内存的方式多种多样，但在典型的系统中，每个进程都拥有一个线性虚拟地址空间，地址范围从零到某个巨大的最大值。该地址空间不必是连续的，即并非所有这些地址都能实际用于存储数据。

虚拟内存被划分为页面（典型大小为4k字节）。每个虚拟内存页面背后对应一个物理内存页面（称为帧）或某种二级存储，通常是磁盘空间。该磁盘空间可能是交换空间，也可能是普通磁盘文件。

实际上，全零页面有时根本没有物理内存或二级存储支持——仅有一个标记表明其为全零页面。

*同一物理内存帧或后端存储设备可以支持多个属于不同进程的虚拟页面*。例如，GNU C 库代码占用的虚拟内存通常就是这种情况。包含 printf 函数的同一物理内存帧会支持每个现有进程中包含 printf 调用的虚拟内存页面。

为了使程序能够访问虚拟页的任何部分，该页在此时必须由（“连接到”）一个实际内存帧支持。但由于虚拟内存通常远多于实际内存，页面必须定期在实际内存和后备存储器之间来回移动，当进程需要访问它们时进入实际内存，然后在不再需要时退回到后备存储器。这种移动称为分页。

当程序尝试访问当前未由实际内存支持的页面时，这被称为页面故障。当页面故障发生时，内核会暂停进程，将页面放入实际页面帧（这称为“页面加载”或“故障加载”），然后恢复进程，因此从进程的角度来看，该页面一直都在实际内存中。事实上，对进程而言，所有页面始终似乎位于物理内存中。

唯一例外是：一条指令的执行时间（通常仅需几纳秒）会突然变得长得多（因为内核通常需要进行I/O操作来完成页面加载）。对于对延迟敏感的程序，可通过[锁定页面]中描述的功能进行控制。

在每个虚拟地址空间内，进程必须跟踪哪些地址存储了什么内容，这个过程称为内存分配。分配通常让人联想到分配稀缺资源，但在虚拟内存的情况下，这不是主要目标，因为通常有比任何人需要的更多的内存。进程内的内存分配主要只是确保同一字节的内存不会用于存储两件不同的事物。

进程分配内存主要有两种方式：通过 exec 函数和程序化方式。实际上，fork 是一种第三种方式，但它并不太有趣。参见 [创建进程]。

exec 函数用于为进程创建虚拟地址空间，将基本程序加载到其中并执行该程序。这一操作由“exec”函数家族（如 execl）完成。该操作会读取一个程序文件（可执行文件），为其分配空间以加载可执行文件中的所有数据，加载数据后将控制权转移给该程序。这些数据主要包括程序的指令（文本部分），以及程序中的字面量、常量，甚至某些变量：具有静态存储类型的 C 变量（参见 [C 程序中的内存分配]）。

一旦程序开始执行，它将通过程序化分配获取额外内存。在使用 GNU C 库的 C 程序中，程序化分配分为两种类型：自动分配和动态分配。参见[C 程序中的内存分配]。

内存映射 I/O 是另一种动态虚拟内存分配形式。将内存映射到文件意味着声明进程地址空间中某一范围的内容应与指定的普通文件内容完全一致。系统会使虚拟内存初始化为文件内容，若修改内存，系统会将相同修改写入文件。需注意，由于虚拟内存和页面故障的特性，系统无需在程序访问虚拟内存之前进行文件读取操作或为其内容分配实际内存。参见[内存映射输入/输出]。

正如程序可以程序化地分配内存，它也可以程序化地释放（释放）内存。你不能释放由 exec 分配的内存。当程序退出或执行 exec 时，你可以说它的所有内存都被释放了，但由于在两种情况下地址空间都停止存在，这个问题实际上是无关紧要的。参见 [程序终止]。

进程的虚拟地址空间被划分为多个段。段是指一组连续的虚拟地址。其中三个重要的段是：
- 文本段包含程序的指令、字面量和静态常量。它由 exec 函数分配，并在虚拟地址空间的生命周期内保持相同的大小。
- 数据段是程序的运行存储区。它可以由 exec 函数预先分配并加载，进程可以通过调用函数来扩展或缩小它，具体方法请参见[调整数据段大小]。其下限是固定的。
- 栈段包含一个程序栈。当栈增长时，栈段也会随之增长，但当栈缩小时，栈段不会随之缩小。

## 为程序数据分配存储空间

本节介绍普通程序如何管理其数据的存储空间，包括著名的malloc函数以及GNU C库和GNU编译器特有的某些高级功能。

### C 程序中的内存分配

C 语言通过 C 程序中的变量支持两种内存分配方式：
- 静态分配是指在声明静态变量或全局变量时发生的情况。每个静态变量或全局变量都会定义一块固定大小的内存空间。该内存空间在程序启动时（作为 exec 操作的一部分）分配一次，且永远不会被释放。
- 自动分配发生在声明自动变量时，例如函数参数或局部变量。自动变量的内存空间在包含该声明的复合语句进入时分配，并在该复合语句退出时释放。在 GNU C 中，自动存储区的大小可以是变化的表达式。在其他 C 实现中，它必须是常量。
第三种重要的内存分配方式——动态分配——不支持 C 变量，但可通过 GNU C 库函数实现。

#### 动态内存分配

动态内存分配是一种技术，程序在运行过程中确定存储某些信息的位置。当所需的内存量或继续需要内存的时间长度取决于程序运行前未知因素时，就需要动态分配。

例如，你可能需要一块内存来存储从输入文件中读取的一行数据；由于行长没有限制，你必须动态分配内存，并在读取更多行内容时动态扩大内存大小。或者，你可能需要为输入数据中的每条记录或每个定义分配一个内存块；由于无法提前知道它们的数量，你必须在读取每条记录或定义时动态分配新的内存块。

使用动态分配时，内存块的分配是程序明确请求的操作。当你需要分配内存时，会调用函数或宏，并通过参数指定大小。若要释放内存空间，需调用另一个函数或宏。这些操作可随时进行，且次数不限。

动态分配不支持C变量；C语言中不存在“动态”存储类，且不存在值存储于动态分配内存空间的C变量。

获取动态分配内存的唯一途径是通过系统调用（通常是通过 GNU C 库函数调用），而引用动态分配内存的唯一方式是通过指针。由于动态分配不太方便，且实际的动态分配过程需要更多计算时间，程序员通常仅在静态分配或自动分配无法满足需求时才使用动态分配。

例如，如果你想动态分配一些空间来存储一个 struct foobar，你不能声明一个类型为 struct foobar 的变量，其内容是动态分配的空间。但你可以声明一个类型为 struct foobar * 的指针变量，并将其赋值为该空间的地址。然后你可以使用该指针变量的 ‘*’ 和 ‘->’ 运算符来引用该空间的内容：

```c
{
    struct foobar *ptr = malloc (sizeof *ptr);
    ptr->name = x;
    ptr->next = current_foobar;
    current_foobar = ptr;
}
```

### GNU 内存分配器

GNU C 库中的 malloc 实现源自 ptmalloc（pthreads malloc），而 ptmalloc 又源自 dlmalloc（Doug Lea malloc）。该 malloc 根据内存大小及用户可控制的某些参数，可能以两种不同方式分配内存。最常见的方式是从一个大型连续内存区域中分配内存块（称为 chunk），并管理这些区域以优化其使用并减少以不可用块形式存在的浪费。传统上，系统堆被设置为一个大型内存区域，但 GNU C 库的 malloc 实现维护多个此类区域以优化其在多线程应用程序中的使用。每个此类区域在内部被称为 arena。

与其他版本不同，GNU C 库中的 malloc 不会将块大小四舍五入为 2 的幂，无论是对于大块还是小块。相邻块可以在释放时合并，无论其大小如何。这使得该实现适用于各种分配模式，而不会因碎片化导致高内存浪费。多个区域的存在允许多个线程在不同区域同时分配内存，从而提升性能。另一种内存分配方式是用于非常大的块，即远大于一个页的大小。

此类请求通过 mmap（匿名或通过 /dev/zero；参见 [内存映射 I/O]）进行分配。此方法的优势在于，当这些块被释放时，它们会立即归还给系统。因此，不会出现大型块被较小块“锁定”的情况，即使在调用 free 后也不会浪费内存。mmap 的大小阈值是动态的，会根据程序的分配模式进行调整。可以使用 mallopt 通过 `M_MMAP_THRESHOLD` 静态调整阈值，也可以通过 `M_MMAP_MAX` 完全禁用 mmap 的使用；参见 [Malloc 可调参数]。

GNU 分配器的更详细技术描述保存在 GNU C 库维基中。参见 https://sourceware.org/glibc/wiki/MallocInternals。可以使用自定义的 malloc 代替 GNU C 库提供的内置分配器。参见 [替换 malloc]。

### 无限制分配

最通用的动态内存分配函数是 malloc。它允许你在任何时候分配任意大小的内存块，随时调整这些内存块的大小，并在任何时候单独释放这些内存块（或永远不释放）。

#### 内存分配基础

要分配一块内存，请调用 malloc 函数。该函数的原型定义在 stdlib.h 头文件中。

```c
void * malloc (size_t size);
```

该函数返回一个指向新分配的块的指针，该块的长度为指定的字节数。如果无法分配该块，则返回空指针（并设置 errno）。

> 在 GNU C 库中，当内存分配大小超过 PTRDIFF_MAX 时，malloc 函数始终会失败，以避免因程序对指针进行减法运算或使用有符号索引而引发的问题。其他实现可能在这种情况下成功分配内存，但这会导致后续行为未定义。

#### 释放malloc分配的内存

当您不再需要通过 malloc 函数分配的内存块时，请使用 free 函数释放该内存块，使其可再次被分配。该函数的原型定义在 stdlib.h 头文件中。

```c
void free (void *ptr);
```

有时，free 函数实际上可以将内存释放回操作系统并缩小进程大小。通常，它只能允许后续的 malloc 调用重新使用该空间。在此期间，该空间仍作为 malloc 内部使用的自由列表的一部分保存在程序中。
free 函数会保留 errno 的值，因此清理代码无需在调用 free 时担心保存和恢复 errno。尽管 ISO C 和 POSIX.1-2017 均未要求 free 函数保留 errno，但未来版本的 POSIX 计划要求其保留。
在程序结束时释放内存块毫无意义，因为当进程终止时，程序的所有内存空间都会被归还给系统。

#### 改变块大小

通常，在您必须开始使用该块时，您并不能确定最终需要多大的块。例如，该块可能是用于存储从文件中读取的行缓冲区；无论您最初将缓冲区设置多长，都可能遇到比缓冲区长度更长的行。您可以通过调用 realloc 或 reallocarray 函数来延长块的长度。这些函数在 stdlib.h 头文件中声明。

```c
void * realloc (void *ptr, size_t newsize);
void * reallocarray (void *ptr, size_t nmemb, size_t size);
```

realloc 函数将指向块的地址 ptr 的块大小更改为 newsize。由于块末尾之后的空间可能已被占用，realloc 可能需要将块复制到一个新的地址，以便获得更多的可用空间。realloc 的返回值是块的新地址。如果块需要移动，realloc 会复制旧内容。

若将 ptr 参数传入空指针，realloc 的行为与‘malloc (newsize)’相同。否则，若 newsize 为零，realloc 将释放该块并返回 NULL。否则，若 realloc 无法重新分配请求的大小，它将返回 NULL 并设置 errno；原块保持不变。

reallocarray 函数将指向 ptr 的内存块的大小调整为足够容纳 nmemb 个元素的向量，每个元素的大小为 size。它等同于‘realloc (ptr, nmemb * size)’，但 reallocarray 在乘法运算溢出时会安全地失败，通过将 errno 设置为 ENOMEM，返回空指针，并保持原始块不变。当分配的块的新大小是可能溢出的乘法运算结果时，应使用 reallocarray 而不是 realloc。

与 malloc 类似，realloc 和 reallocarray 可能在没有可用内存空间来扩大块大小时返回空指针。此时，原有块保持不变；它未被修改或重新定位。

> 在 GNU C 库中，如果新大小与旧大小相同，realloc 和 reallocarray 保证不会更改任何内容并返回您提供的相同地址。然而，POSIX 和 ISO C 允许这些函数在这种情况下重新定位对象或失败。

#### 分配初始化后的空间

```c
void * calloc (size_t count, size_t eltsize);
```

该函数分配一个足够大的内存块，用于存储一个包含 count 个元素的向量，每个元素的大小为 eltsize。在 calloc 返回之前，该内存块的内容会被清零。

#### 分配对齐的内存块

```c
void * aligned_alloc (size_t alignment, size_t size);
void * memalign (size_t boundary, size_t size);
int posix_memalign (void **memptr, size_t alignment, size_t size);
void * valloc (size_t size);
```

aligned_alloc 函数分配一个大小为 bytes 的内存块，其地址必须是 alignment 的倍数。alignment 必须是 2 的幂。

memalign 函数分配一个大小为 bytes 的内存块，其地址必须是 boundary 的倍数。boundary 必须是 2 的幂！memalign 函数的工作原理是先分配一个稍大的内存块，然后返回该块内位于指定边界处的地址。

posix_memalign 函数与 memalign 函数类似，它返回一个大小为 size 的缓冲区，且该缓冲区对齐到 alignment 的倍数。但它对参数 alignment 添加了一个要求：该值必须是 `sizeof (void *)` 的 2 的幂次方倍数。

使用valloc与使用memalign类似，只是将页面大小作为第一个参数的值传递。其实现方式如下：
```c
void* valloc (size_t size)
{
    return memalign (getpagesize (), size);
}
```

#### 内存分配器可调参数

您可以使用 mallopt 函数调整动态内存分配的一些参数。该函数是 SVID/XPG 标准的通用接口，定义在 malloc.h 文件中。

```c
int mallopt (int param, int value);
```

在调用 mallopt 时，param 参数指定要设置的参数，value 指定要设置的新值。根据 malloc.h 中定义，param 的可能选项包括：

