# 导言

C 语言本身不提供用于执行输入/输出、内存管理、字符串操作等常见操作的内置功能。相反，这些功能在标准库中定义，你需要将标准库编译并链接到你的程序中。

本文件所述的GNU C库定义了ISO C标准中规定的所有库函数，以及与POSIX和其他Unix操作系统衍生版本相关的特定功能，以及GNU系统特有的扩展功能。

本手册的目的是向您介绍如何使用GNU C库的各项功能。我们已指出哪些功能属于哪些标准，以帮助您识别可能在其他系统上无法移植的内容。但本手册的重点并非严格的可移植性。

## 标准与兼容性

本节讨论了GNU C库所基于的各种标准及其他来源。这些来源包括ISO C标准和POSIX标准，以及System V和Berkeley Unix的实现。

本手册的主要目的是向您介绍如何有效利用GNU C库的各项功能。但如果您关心程序与这些标准的兼容性，或希望程序能在GNU以外的操作系统上运行，这将影响您使用库的方式。本节将为您概述这些标准，以便您在手册其他部分提及这些标准时能够了解其含义。

## ISO C

GNU C 库与美国国家标准协会（ANSI）采纳的 C 标准兼容：美国国家标准 X3.159-1989——“ANSI C”，以及后来由国际标准化组织（ISO）采纳的标准：ISO/IEC 9899:1990，《编程语言——C》。我们在此将该标准称为 ISO C，因为这是在批准方面更具普遍性的标准。构成 GNU C 库的头文件和库设施是 ISO C 标准所规定的头文件和库设施的超集。

如果您对严格遵守 ISO C 标准有顾虑，建议在使用 GNU C 编译器编译程序时使用 ‘-ansi’ 选项。此选项会指示编译器仅从库头文件中定义 ISO 标准特性，除非您明确要求添加其他特性。

能够将库限制为仅包含 ISO C 特性非常重要，因为 ISO C 对库实现可以定义的名称施加了限制，而 GNU 扩展不符合这些限制。本手册不试图为您提供 ISO C 与较旧方言之间差异的完整细节。它提供如何编写可在多种 C 方言下便携运行的程序的建议，但不追求完整性。


## POSIX(The Portable Operating System Interface)

GNU C 库也与 ISO POSIX 标准系列兼容，该系列标准正式名称为《计算机环境可移植操作系统接口》（ISO/IEC 9945）。这些标准还以 ANSI/IEEE Std 1003 的形式发布。POSIX 主要源自各种版本的 Unix 操作系统。

POSIX 标准规定的库功能是 ISO C 标准要求的库功能的超集；POSIX 标准为 ISO C 函数规定了额外功能，并定义了新的附加函数。总体而言，POSIX 标准定义的额外要求和功能旨在为特定类型的操作系统环境提供底层支持，而非适用于多种多样操作系统环境的通用编程语言支持。

GNU C 库实现了 ISO/IEC 9945-1:1996 中规定的所有函数，即 POSIX 系统应用程序接口，通常简称为 POSIX.1。本标准对 ISO C 功能的主要扩展包括文件系统接口基本函数（见[文件系统接口]）、设备特定的终端控制函数（见[低级终端接口]）以及进程控制函数（见[进程]）。

ISO/IEC 9945-2:1993 标准（POSIX Shell和实用程序标准，即 POSIX.2）中的一些功能也在 GNU C 库中实现了。这些功能包括用于处理正则表达式和其他模式匹配功能的实用程序（参见[模式匹配]）。

### POSIX 安全性原则

本手册记录了GNU C库函数的各种安全属性，这些属性紧跟在函数原型之后，格式如下：
- Preliminary
- MT-Safe
- AS-Safe
- AC-Safe

这些属性是根据POSIX标准中为线程安全、异步信号安全和异步取消安全等安全上下文设定的标准进行评估的。以下是对这些属性的直观定义，旨在捕捉标准定义的含义。

#### MT-Safe

线程安全函数在存在其他线程的情况下仍可安全调用。MT 在 MT-Safe 中代表多线程。

MT-Safe并不意味着函数是原子性的，也不意味着它使用了POSIX向用户暴露的任何内存同步机制。即使依次调用MT-Safe函数，也可能无法得到MT-Safe的组合。例如，一个线程依次调用两个MT-Safe函数，并不能保证其行为等同于这两个函数的原子性执行，因为其他线程中的并发调用可能以破坏性方式干扰。

跨库接口进行的全局程序优化可能导致不安全的重新排序，因此不建议在 GNU C 库接口上进行内联操作。在全局程序优化下，已记录的 MT-Safety 状态无法得到保证。然而，定义在用户可见头文件中的函数设计上是安全的，可进行内联操作。

#### AS-Safe

异步信号安全函数（Async-Signal-Safe functions）可安全地从异步信号处理程序中调用。AS 在 AS-Safe 中代表异步信号（Asynchronous Signal）。

许多 AS-Safe 函数可能会设置 errno 或修改浮点环境，因为这些操作并不会使它们不适合在信号处理程序中使用。

然而，如果异步信号处理程序修改了线程局部状态，程序可能会出现异常行为，而信号处理机制无法保证保留这些状态。因此，调用可能设置 errno 或修改浮点环境的函数的信号处理程序必须保存其原始值，并在返回前恢复它们。

#### AC-Safe

异步取消安全（AC-Safe）函数在启用异步取消时可安全调用。AC-Safe中的AC代表异步取消。

POSIX标准仅定义了三个AC-Safe函数，即`pthread_cancel`、`pthread_setcancelstate`和`pthread_setcanceltype`。目前GNU C 库不提供这三个函数之外的任何保证，但会记录哪些函数目前是 AC-Safe。此文档供 GNU C 库开发人员使用。

与信号处理程序类似，取消清理例程必须配置其所需的浮点环境。这些例程不能假设浮点环境，尤其是在启用异步取消时。如果无法原子地配置浮点环境，则可能遇到内部不一致的环境。

#### MT-Unsafe, AS-Unsafe, AC-Unsafe

在上述安全上下文中调用这些函数是不安全的。在这些上下文中调用它们会导致未定义的行为。

未明确标记为在安全上下文中安全的函数应被视为不安全的。

#### Preliminary

Preliminary 属性，这意味着这些特性在未来版本的 GNU C 库中可能无法保证。

此类初步属性是基于对当前实现的属性评估得出的，而非基于当前及未来标准所规定和允许的内容。

尽管我们努力遵守标准，但在某些情况下，我们的实现即使在标准未要求安全性的情况下也是安全的，而在其他情况下，我们的实现不符合标准的安全要求。后者很可能是缺陷；前者，当标记为“初步”时，不应依赖：未来标准可能要求进行与当前实现提供的额外安全性属性不兼容的更改。

此外，POSIX标准并未对安全提供详细定义。我们假设，当POSIX提到“安全调用”时，其含义是：只要程序未引发未定义行为，“安全调用”函数将按规范行为运行，且不会导致其他函数偏离其规范行为。我们选择使用其对安全性的宽松定义，并非因为这些是最佳定义，而是因为选择它们可使本手册与 POSIX 保持一致。

请注意，这些是初步定义和注释，定义的某些方面仍在讨论中，可能需要澄清或修改。

随着时间的推移，我们计划将初步的安全注释演变为稳定的承诺，其稳定性与我们的接口定义相当。在这一过程中，我们将移除安全注释中的“初步”关键字。然而，只要该关键字存在，这些注释不应被视为对未来行为的承诺。

安全注释中出现的其他关键字将在后续章节中定义。

### 不安全特性

在某些上下文中不安全调用的函数会使用关键字进行注释，以说明其导致调用不安全的特性。本节中的AS-Unsafe特性表示当异步信号启用时，这些函数绝不能安全调用。

AC-Unsafe特性表示当异步取消启用时，这些函数绝不能安全调用。本节中不存在MT-Unsafe标记。

#### lock

标记为锁的AS-Unsafe功能在持有非递归锁时可能被信号中断。如果信号处理程序调用另一个使用相同锁的此类函数，则会导致死锁。

标记为 AC-Unsafe 特征的锁定函数，如果被异步取消，可能无法释放本应在执行未被异步线程取消中断时释放的锁。一旦锁被占用，尝试获取该锁的操作将无限期阻塞。

#### corrupt

标记为“corrupt”的AS-Unsafe功能可能在被其他此类功能中断或中断其他此类功能时，导致数据结构损坏并出现异常行为。

与标记为“lock”的功能不同，这些功能会通过递归锁定来避免多线程安全问题，但这并不足以阻止信号处理程序观察到部分更新的数据结构。进一步的损坏可能源于被中断的功能未能察觉信号处理程序所做的更新。

标记为“corrupt”的AC-Unsafe特性函数可能使数据结构处于损坏的、部分更新的状态。后续对该数据结构的访问可能导致异常行为。

#### heap

标记为“堆”的函数可能会调用malloc/free函数家族中的堆内存管理函数，其安全性仅与这些函数相当。因此，本说明等同于：

| AS-Unsafe lock | AC-Unsafe lock fd mem |

#### dlopen

标记为 dlopen 的函数使用动态加载器将共享库加载到当前执行映像中。这涉及打开文件、将其映射到内存中、分配额外内存、解析符号、应用重定位等操作，所有这些操作都在持有内部动态加载器锁的情况下进行。
这些锁足以使这些函数成为 AS-Unsafe 和 AC-Unsafe的，但可能还会出现其他问题。目前，这是为 dlopen 引发的所有潜在安全问题保留的占位符。

#### plugin

标记为插件的函数可能执行来自插件的代码，这些插件可能位于 GNU C 库之外。此类插件函数被假定为多线程安全（MT-Safe）、非线程安全（AS-Unsafe）和非调用安全（AC-Unsafe）。此类插件的示例包括栈展开库、名称服务切换（NSS）和字符集转换（iconv）后端。

尽管作为示例提到的插件均通过dlopen加载，但“插件”关键字并不暗示动态加载器或libdl接口的直接参与，这些由dlopen覆盖。例如，如果一个函数加载模块并查找其中部分函数的地址，而另一个函数仅调用已解析的函数，则前者将标记为 dlopen，而后者将标记为插件。当单个函数同时执行所有这些操作时，则两者均被标记。

#### i18n

标记为 i18n 的函数可能会调用 gettext 家族的国际化函数，其安全性仅与这些函数相当。因此，本说明等同于：
| MT-Safe env | AS-Unsafe corrupt heap dlopen | AC-Unsafe corrupt |

#### timer

带有定时器标记的函数会使用闹钟功能或其他类似机制为系统调用或长时间运行的操作设置超时时间。在多线程程序中，存在超时信号被发送到不同线程的风险，从而无法中断目标线程。除了是多线程不安全（MT-Unsafe）外，此类函数始终是异步不安全（AS-Unsafe），因为在信号处理程序中调用它们可能干扰被中断代码中设置的定时器，同时也是异步取消不安全（AC-Unsafe），因为无法通过安全方式保证在异步取消情况下较早设置的定时器会被重置。

### 条件安全特性

对于某些在特定上下文中调用会导致函数不安全的特性，除了完全避免调用该函数外，还存在已知的方法来规避安全问题。

以下列出的关键字指代此类特性，每个关键字的定义均说明了为消除该关键字所指的安全问题，整个程序需要如何进行约束。仅当通过应用已文档化的约束条件，彻底解决导致函数不安全的所有原因后，该函数在相应上下文中才可安全调用。

#### init

标记为 init 的 MT-Unsafe 功能在首次调用时会执行 MT-Unsafe 初始化。

在单线程模式下至少调用一次此类函数可消除该函数被视为 MT-Unsafe 的特定原因。若不存在其他导致该状态的原因，则可在其他线程启动后安全地调用该函数。

标记为 init 的 AS-Unsafe 或 AC-Unsafe 功能使用内部 `libc_once` 机制或类似机制来初始化内部数据结构。如果信号处理程序中断此类初始化程序，并且调用任何也执行 `libc_once` 初始化的函数，则在线程库已加载的情况下会导致死锁。

此外，如果初始化程序在被信号中断或取消之前尚未完成，而该信号的处理程序需要相同的初始化，则部分或全部初始化可能被重复执行，导致资源泄漏甚至内部数据损坏。

需要调用标记为 init 的 AS-Unsafe 或 AC-Unsafe 功能的应用程序应确保在配置信号处理程序或启用取消之前完成初始化，以避免与 `libc_once` 相关的 AS-Safety 和 AC-Safety 问题。

#### race

标记为“race”的函数（作为多线程安全问题）以可能导致数据竞争或其他形式的破坏性干扰的方式操作对象，这些干扰源于并发执行。在某些情况下，对象由用户传递给函数；在其他情况下，函数使用这些对象向用户返回值；还有一些情况下，这些对象甚至不会暴露给用户。

我们认为，作为（间接）参数传递给函数的对象的访问是无数据竞争的。确保对象无数据竞争是调用者的责任。如果用户在处理此类对象时未采取POSIX要求的措施来避免数据竞争，导致函数行为异常，我们不会将该函数标记为MT-Unsafe或AS-Unsafe。作为一般规则，如果函数文档中说明其会读取（通过引用传递）的对象或修改该对象，用户应使用内存同步原语避免数据竞争，就像他们直接访问该对象而非调用库函数时所做的那样。FILE流是这一规则的例外，因为POSIX要求库在处理此类特定不透明类型对象的许多函数中防范数据竞争。我们认为这是为用户提供的便利，而非适用于其他类型的普遍要求。

为了提醒用户某些参数的保护是他们的责任，我们将对接受特定类型对象作为参数的函数进行注释。我们对用户传递的对象的界定如下：类型对用户可见且用户预期直接访问的对象（如内存缓冲区、字符串和各种用户可见的结构类型）无需在函数中添加竞争注释。

这会与通用要求产生冗余，且很少有人会对库在访问可直接由用户访问的对象时缺乏内部保护措施感到意外。

对于不透明或类似不透明的对象（即仅通过传递给库函数进行操作的对象，例如 FILE、DIR、obstack、iconv_t），可能对库内部访问协调有额外期望。我们将对那些接受此类对象但默认不负责同步访问的函数进行注释，注释格式为“race: 参数名称”。例如，FILE流的解锁函数将被注释，但那些默认对FILE流进行隐式锁定的函数则不会被注释，即使该隐式锁定可按流basis禁用。

无论哪种情况，我们都不会将可能以不安全方式访问用户提供的对象的函数视为 MT-Unsafe，只要用户未能确保访问是明确定义的。普遍认为，用户应负责防止对库代为访问的用户提供的对象发生数据竞争。

然而，此用户责任不适用于由库自身控制的对象，例如用于从某些调用返回值的内部对象和静态缓冲区。当库未对其进行并发使用保护时，这些情况被视为 MT-Unsafe 和 AS-Unsafe（尽管 AS-Unsafe 下的竞争标记将因与 MT-Unsafe 下的标记重复而省略）。与用户暴露对象的情况类似，标记后可跟随冒号和标识符。标识符将所有操作某个未受保护对象的函数进行分组；用户可通过创建与该标识符关联的非递归互斥锁，并在调用该标识符下标记为存在竞争条件的任何函数时始终持有该互斥锁，来避免与未受保护的并发访问相关的MT-Safety问题，这与标识符若为用户控制的对象时应采取的措施一致。非递归互斥锁避免了 MT-Safety 问题，但它用一个 AS-Safety 问题替换了另一个，因此在异步信号中的使用仍未定义。

当标识符与用于存储返回值的静态缓冲区相关时，互斥锁必须在调用者使用该缓冲区期间一直持有。许多返回静态缓冲区指针的函数提供了可重入变体，这些变体将返回值存储在调用者提供的缓冲区中。在某些情况下，例如 tmpname，变体并非通过调用替代入口点选择，而是通过传递一个非空指针到用于存储返回值的缓冲区来选择。这些变体在多线程程序中通常更可取，尽管其中一些由于其他内部缓冲区而并非 MT-安全，这些缓冲区也附有竞争条件注释。

#### const

标记为 const 的函数因 MT-Safety 问题会非原子地修改内部对象，而这些对象更应被视为常量，因为 GNU C 库的大部分访问操作在没有同步的情况下进行。与导致内部对象的读取者和写入者均被视为 MT-Unsafe 和 AS-Unsafe 的竞争条件不同，此标记仅适用于写入者。写入者调用时仍保持MT-和AS-不安全，但其修改的对象必须为const，这使得读取者可被视为MT-Safe和AS-Safe（只要不存在其他导致其不安全的因素），因为当对象实质上为常量时，缺乏同步不再是问题。

跟随 const 标记的标识符将单独作为安全注释出现在读取器中。希望绕过此安全问题以调用写入器的程序，可使用与该标识符关联的非递归 rwlock，并对标记为 const 并跟随该标识符的函数调用加写锁保护，对仅标记为该标识符的函数调用加读锁保护。非递归锁定消除了多线程安全问题，但用一个异步安全问题替换了另一个，因此在异步信号中的使用仍未定义。

#### sig

标记为 sig 的函数作为 MT-Safety 问题（这意味着存在相同的 AS-Safety 问题，为简洁起见省略）可能会临时安装一个信号处理程序用于内部目的，这可能会干扰其他对信号的使用，这些使用在冒号后标识。
此安全问题可通过确保在调用期间不会发生其他信号使用来绕过。建议在调用所有使用同一临时信号的函数时持有非递归互斥锁；在调用前阻塞该信号并在调用后重置其处理程序。

在异步取消的情况下，无法安全地保证原始信号处理程序被恢复，因此标记为 AC-Unsafe 的函数也属于此类。

除了为解决 MT- 和 AS-Safety 问题而推荐的措施外，为避免取消问题，建议禁用异步取消并安装一个清理处理程序，以将信号恢复到预期状态并释放互斥锁。

#### term

标记为“term”的函数可能以推荐的方式更改终端设置，即：调用 tcgetattr，修改某些标志，然后调用 tcsetattr；这会创建一个窗口，在此期间其他线程所做的更改可能会丢失。

因此，标记为“term”的函数是MT-Unsafe。同一时间窗口还可能导致异步信号所做的更改丢失。这些函数也是AS-Unsafe，但相应的标记被省略，因为它是多余的。

因此，建议使用终端的应用程序避免与终端进行并发和可重入交互，即不在信号处理程序中使用终端，或阻塞可能使用终端的信号，并在调用这些函数和与终端交互时保持锁定。此锁还应用于与标记为 race:tcattr(fd) 的函数进行互斥，其中 fd 是控制终端的文件描述符。调用者可为简化使用单个互斥锁，或为每个终端使用一个互斥锁，即使它们由不同文件描述符引用。

标记为term的AC-Safety问题的函数应在临时更改终端设置后将其恢复到原始状态，但如果被取消，它们可能无法做到这一点。

除了推荐的用于解决MT-和AS-Safety问题的措施外，为了避免取消问题，建议禁用异步取消并安装一个清理处理程序，以将终端设置恢复到原始状态并释放互斥锁。

### 其他安全注意事项

可以为函数附加额外的关键字，这些关键字表示某些特性不会使函数的调用变得不安全，但在某些类型的程序中可能需要考虑这些特性：

#### locale

标记为 locale 的函数作为 MT-Safety 问题，会从 locale 对象中读取数据，且不进行任何形式的同步。标记为 locale 的函数在与 locale 更改并发调用时，可能表现出与执行期间任何活跃 locale 都不对应的行为，而是这些 locale 的不可预测混合。
我们并未将这些函数标记为 MT-Unsafe 或 AS-Unsafe，因为修改 locale 对象的函数会被标记为 const:locale 并视为不安全。
由于后者是不安全的，因此在多个线程运行或启用异步信号时不应调用它们，因此在这些上下文中，locale 可以被视为有效常量，这使得前者是安全的。

#### env

标记为 env 的函数作为 MT-Safety 问题，通过 getenv 或类似函数访问环境，且没有安全保护措施来确保在并发修改环境时的安全性。

然而，我们并未将这些函数标记为 MT-Unsafe 或 AS-Unsafe，因为所有修改环境的函数都标记为 const:env 并被视为不安全。

由于后者是不安全的，因此在多个线程运行或启用异步信号时不应调用它们，因此在这些上下文中环境可以被视为有效地保持恒定，这使得前者是安全的。

#### hostid

标记为 hostid 的 MT-Safety 问题函数从系统范围内的数据结构中读取机器的“主机 ID”。这些数据结构通常无法原子地修改。由于预期“主机 ID”通常不会发生变化，因此读取该数据结构的函数（gethostid）被视为安全，而修改该数据结构的函数（sethostid）则标记为 const:hostid，这表明如果调用该函数，可能需要特别注意。在这种特定情况下，特别注意意味着需要进行系统范围（而不仅仅是进程内）的协调。

#### sigintr

标记为 sigintr 的函数存在 MT-Safety 问题，这些函数在没有安全保障的情况下访问 `_sigintr` 内部数据结构，这可能导致在并发修改时出现安全问题。
然而，我们并未将这些函数标记为 MT-Unsafe 或 AS-Unsafe，因为修改此数据结构的函数均标记为 const:sigintr 并被视为不安全。由于这些函数不安全，因此在多个线程运行或异步信号启用时不应调用它们，从而使该数据结构在这些上下文中可视为有效常量，从而使前者安全。

#### fd

标记为 fd 的函数若存在 AC-Safety 问题，可能在异步线程取消中断其执行时泄漏文件描述符。

分配或释放文件描述符的函数通常会标记为该类型。

即使尝试通过清理区域来保护文件描述符的分配和释放，分配新描述符并将其编号存储在清理区域可释放的位置也无法作为单个原子操作完成。同样，释放描述符并将其从负责释放的数据显示结构中移除也无法原子地完成。总会存在一个时间窗口，在此期间描述符无法被释放，因为它尚未存储在清理处理程序的参数中，或者它已经在释放之前被移除了。释放后无法再移除描述符：一个打开的描述符可能意味着描述符仍需关闭，或者它已经关闭但被另一个线程或信号处理程序重新分配。

此类泄漏可通过临时禁用异步线程取消来内部避免，但会带来性能开销。然而，由于调用分配或释放函数的调用者必须自行处理此问题，以避免自身层级出现相同泄漏，因此库假设调用者已妥善处理该问题更为合理，而非强加一个在高层级已解决问题时冗余、在未解决时又不足的性能开销。

此说明本身不会导致函数被视为 AC-Unsafe。然而，此类内存泄漏的累积效应可能对某些程序构成问题。若出现此情况，建议在调用此类函数期间暂停异步取消。

#### mem

标记为 mem 的函数可能因异步线程取消中断其执行而导致内存泄漏，这属于 AC-Safety 问题。
该问题与文件描述符类似：没有原子接口可在分配内存并将其地址存储到清理处理程序的参数中，或释放内存并从该参数中移除其地址，同时至少暂时禁用异步取消（而这些函数并未这样做）。
此说明本身并不会导致函数被视为普遍 AC-不安全。
然而，此类泄漏的累积效应可能对某些程序造成严重影响，因此在调用此类函数期间可能需要禁用异步取消。

#### cwd

标记为 cwd 的函数可能在执行过程中临时更改当前工作目录，这可能导致其他线程或异步信号/取消处理程序中相对路径名以意外方式解析。
这不足以将此类函数标记为 MT- 或 AS-Unsafe，但当此行为可选（例如 nftw 中的 FTW_CHDIR）时，避免使用该选项可能是使用完整路径名或文件描述符相对（例如 openat）系统调用的良好替代方案。

#### !posix

此注释作为功能的MT、AS或AC安全注释，表明该功能的安全状态与POSIX标准中规定的状态不同。例如，POSIX并未要求功能必须是安全的，但我们的实现是安全的，反之亦然。
目前，缺少此注释并不意味着我们文档中记录的安全属性与POSIX对相应功能规定的强制性安全属性完全一致。

#### :identifier

注释有时会跟随标识符，旨在将多个函数分组，例如以不安全的方式访问数据结构的函数（如 race 和 const），或提供更具体的信息，例如在标记为 sig 的函数中命名信号。未来可能还会将其应用于 lock 和 corrupt。
在大多数情况下，标识符将命名一组函数，但它也可能命名全局对象或函数参数，或与它们相关的可识别属性或逻辑组件，使用如 :buf(arg) 表示与参数 arg 关联的缓冲区，或 :tcattr(fd) 表示文件描述符 fd 的终端属性。
标识符最常见的用途是提供需要由同一同步原语保护的函数和参数的逻辑组，以确保在给定上下文中安全运行。

#### /condition

某些安全注释可能是条件性的，即它们仅在涉及参数、全局变量甚至底层内核的布尔表达式评估为真时才生效。例如，/hurd 或 /!linux!bsd 表示前面的标记仅在底层内核为 HURD 时生效，或在底层内核既不是 Linux 也不是 BSD 内核时生效。`/!ps` 和 `/one_per_line` 表示前面的标记仅在参数 ps 为 NULL，或全局变量 one per line 不为零时适用。
当所有使函数不安全的标记都带有此类条件，且所有指定的条件均不成立时，则该函数可被视为安全。

## libc库的使用

### 头文件

```c
#include "头文件"
#include <头文件>
```

### 宏函数

### 预留名

### 功能测试宏

编译源文件时可用的具体功能集由您定义的功能测试宏决定。

如果您使用‘gcc -ansi’编译程序，则仅获得ISO C库功能，除非您通过定义一个或多个功能宏显式请求额外功能。有关GCC选项的更多信息，请参阅《GNU CC手册》中的“GNU CC命令选项”一节。

您应通过在源代码文件开头使用‘#define’预处理指令来定义这些宏。这些指令必须位于任何系统头文件的#include之前。最好将它们作为文件中的第一行，仅在注释之后。您也可以使用GCC的‘-D’选项，但最好让源文件以自包含的方式明确表示其含义。

该系统旨在使库能够符合多个标准。尽管不同标准常被描述为彼此的超集，但它们通常因兼容性问题而无法共存——较大标准要求使用较小标准保留给用户程序的函数名称。这并非单纯的吹毛求疵——在实际应用中确实存在此类问题。例如，一些非 GNU 程序定义了名为 getline 的函数，这些函数与本库的 getline 毫无关联。如果所有功能都被无差别地启用，这些程序将无法编译。

这不应用于验证程序是否符合有限标准。它不足以实现此目的，因为它无法防止你包含标准之外的头文件，或依赖标准中未定义的语义。

#### _POSIX_SOURCE

如果你定义了这个宏，那么POSIX.1标准（IEEE标准1003.1）中的功能将可用，同时还包括所有ISO C标准提供的功能。

如果将宏 `_POSIX_C_SOURCE` 定义为正整数，则 `_POSIX_SOURCE` 的状态不起作用。

#### _POSIX_C_SOURCE

将此宏定义为正整数以控制可用的 POSIX 功能。此宏的值越大，可用的功能越多。

如果将此宏定义为大于或等于 1 的值，则可使用 1990 年版 POSIX.1 标准（IEEE 标准 1003.1-1990）中的功能。

如果将此宏定义为大于或等于 2 的值，则 1992 年版 POSIX.2 标准（IEEE 标准 1003.2-1992）中的功能将被启用。

如果你将此宏定义为大于或等于199309L的值，则1993年版POSIX.1b标准（IEEE标准1003.1b-1993）的功能将被启用。

如果你将此宏定义为大于或等于199506L的值，则1995版POSIX.1c标准（IEEE标准1003.1c-1995）的功能将被启用。

如果你将此宏定义为大于或等于 200112L 的值，则 2001 年版 POSIX 标准（IEEE 标准 1003.1-2001）的功能将被启用。

如果你将此宏定义为大于或等于 200809L 的值，则 2008 版 POSIX 标准（IEEE 标准 1003.1-2008）的功能将被启用。

`_POSIX_C_SOURCE` 的更大值将启用未来扩展。POSIX 标准制定过程将根据需要定义这些值，而 GNU C 库应在这些值标准化后的一段时间内支持它们。1996 年版的 POSIX.1（ISO/IEC 9945-1: 1996）规定，若将 `_POSIX_C_SOURCE` 定义为大于或等于 199506L 的值，则 1996 年版的 POSIX 功能将被启用。一般来说，在 GNU C 库中，对标准的 bug 修复会在指定基础版本时包含在内；例如，POSIX.1-2004 将始终与 200112L 的值一起包含。

#### _XOPEN_SOURCE和_XOPEN_SOURCE_EXTENDED

如果你定义了这个宏，X/Open 可移植性指南中描述的功能将被包含。这是 POSIX.1 和 POSIX.2 功能的超集，事实上 `_POSIX_SOURCE` 和 `_POSIX_C_SOURCE` 会自动被定义。

如果同时定义了宏 `_XOPEN_SOURCE_EXTENDED`，将提供更多功能。这些额外函数将使所有必要于 X/Open Unix 品牌的函数均可使用。

如果宏 `_XOPEN_SOURCE` 的值为 500，则包含迄今为止描述的所有功能以及来自单一 Unix 规范（SUS）第 2 版的某些新定义。值 600（对应于第六次修订版）包含来自 SUSv3 的定义，而使用 700（第七次修订版）则包含来自 SUSv4 的定义。

#### _LARGEFILE_SOURCE

如果定义了此宏，将提供一些额外函数，用于弥补先前所有标准中存在的某些不足。具体而言，可使用 fseeko 和 ftello 函数。若缺少这些函数，ISO C 接口（fseek、ftell）与低级 POSIX 接口（lseek）之间的差异将导致问题。

此宏作为大型文件支持扩展（LFS）的一部分引入。

#### _LARGEFILE64_SOURCE

如果你定义了这个宏，将提供一组额外的函数，使32位系统能够使用超过通常2GB限制的文件。如果系统不支持如此大的文件，则该接口不可用。在自然文件大小限制大于2GB的系统（即64位系统）上，新函数与被替换的函数完全相同。

新功能通过一组新的类型和函数实现，这些新类型和函数替换了原有的类型和函数。这些新对象的名称中包含“64”以表明其用途，例如off_t与off64_t，以及fseeko与fseeko64。

此宏作为大型文件支持扩展（LFS）的一部分引入。它是过渡期接口，用于64位偏移量尚未普遍使用的阶段（参见_FILE_OFFSET_BITS）。

#### _FILE_OFFSET_BITS

此宏用于确定应使用哪个文件系统接口，一个接口将取代另一个接口。而`_LARGEFILE64_SOURCE`使64位接口作为额外接口可用，`_FILE_OFFSET_BITS`则允许64位接口取代旧接口。

如果 `_FILE_OFFSET_BITS` 被定义为 32，则使用 32 位接口，且在 32 位系统上，off_t 等类型具有 32 位大小。

如果该宏被定义为 64，则大文件接口将替换旧接口。即，这些函数不会以不同名称提供（如 `_LARGEFILE64_SOURCE` 所示）。相反，旧函数名称现在引用新函数，例如对 fseeko 的调用现在确实调用 fseeko64。
如果该宏未定义，当前默认值为 32，但由于需要更新 time_t 以确保 Y2038 兼容性，该默认值计划更改，因此应用程序不应依赖默认值。

该宏仅应在系统提供处理大文件的机制时选择。在 64 位系统上，该宏无效，因为 `*64` 函数与普通函数完全相同。

该宏作为大型文件支持扩展（LFS）的一部分引入。

#### _TIME_BITS

定义此宏以控制 time_t 的位数，从而控制所有 time_t 派生类型以及所有相关函数原型的位数。
1. 如果 `_TIME_BITS` 未定义，time_t 的位数取决于架构。目前在大多数架构上默认为 64 位。尽管在某些传统架构（如 i686、ARM）上默认为32 位，但这计划将发生变化，应用程序不应依赖此默认值。
2. 如果 `_TIME_BITS` 被定义为 64，则 time_t 被定义为 64 位整数。在传统上 time_t 为 32 位的平台上，对适当系统调用的调用取决于系统运行的 Linux 内核版本。对于 Linux 内核版本高于 5.1 的系统，将使用支持 64 位时间的系统调用。否则，将使用回退代码与旧版（即 32 位）系统调用。在这种平台上，GNU C 库还将定义 `__USE_TIME64_REDIRECTS` 以指示声明是否已扩展为不同的声明（通过重新定义符号名称或使用符号别名）。例如，如果符号 `clock_gettime` 扩展为 `__glock_gettime64`。
3. 如果 `_TIME_BITS 被定义为` 32，则 time_t 被定义为 32 位整数（在支持的情况下）。这不推荐，因为 32 位 time_t 在 2038 年将停止工作。
4. 对于其他任何用例，将引发编译时错误。 `_TIME_BITS` 和 `_TIME_BITS=64` 仅在 `_FILE_OFFSET_BITS=64` 也被定义时才能定义。

通过使用此宏，某些端口可获得对 64 位时间的支持，从而免受 Y2038 问题的影响。

#### _ISOC99_SOURCE

如果定义了此宏，则包含 ISO C99 的特性。由于这些特性默认已包含，因此此宏主要在编译器使用较早的语言版本时相关。

#### _ISOC11_SOURCE

如果定义了此宏，则包含 ISO C11 对 ISO C99 的扩展。

#### _ISOC23_SOURCE

如果定义了此宏，则包含 ISO C23 对 ISO C11 的扩展。GNU C 库仅支持该草案标准中的部分功能。旧名称 _ISOC2X_SOURCE 同样被支持。

#### _ISOC2Y_SOURCE

如果定义了此宏，则包含 ISO C2Y 对 ISO C23 的扩展。GNU C 库仅支持该草案标准中的部分功能。

#### __STDC_WANT_LIB_EXT2__

如果你将此宏定义为 1，则启用 ISO/IEC TR 24731-2:2010（动态分配函数）中的功能。GNU C 库仅支持该技术报告中的一部分功能。

#### __STDC_WANT_IEC_60559_BFP_EXT__

如果你定义了这个宏，则启用了ISO/IEC TS 18661-1:2014（C语言的浮点数扩展：二进制浮点数运算）中的部分功能。GNU C库仅支持该技术规范中的部分功能。

#### __STDC_WANT_IEC_60559_FUNCS_EXT__

如果你定义了这个宏，ISO/IEC TS 18661-4:2015（C语言浮点扩展：补充函数）中的功能将被启用。GNU C库仅支持该技术规范中的一部分功能。

#### __STD_WANT_IEC_60559_TYPES_EXT__

如果你定义了这个宏，则启用了ISO/IEC TS 18661-3:2015（C语言浮点扩展：交换和扩展类型）中的功能。GNU C库仅支持该技术规范中的一部分功能。

#### __STD_WANT_IEC_60559_EXT__

如果你定义了这个宏，ISO C23 标准中在附录 F 中定义的特性将被启用。这将影响 totalorder 函数的声明以及与 NaN 负载相关的函数的声明。

#### _GNU_SOURCE

如果你定义了这个宏，所有内容都将被包含：ISO C89、ISO C99、POSIX.1、POSIX.2、BSD、SVID、X/Open、LFS 以及 GNU 扩展。在 POSIX.1 与 BSD 发生冲突的情况下，POSIX 定义具有优先权。

#### _DEFAULT_SOURCE

如果你定义了这个宏，大多数功能都会被包含，除了X/Open、LFS和GNU扩展：这样做会启用2008版POSIX中的功能，以及某些BSD和SVID功能，而无需单独的特征测试宏来控制它们。请注意，编译器选项也会影响包含的功能：
- 如果使用严格符合标准的选项，超出编译器语言版本范围的功能将被禁用，尽管可以通过功能测试宏启用它们。
- 由编译器选项启用的功能不会被功能测试宏覆盖。

#### _ATFILE_SOURCE

如果定义了此宏，则会包含额外的 `*at` 接口。

#### _FORTIFY_SOURCE

如果将此宏定义为 1，则会在各种库函数中添加安全强化措施。如果定义为 2，则会应用更严格的检查。如果定义为 3，GNU C 库还可能使用一些检查，这些检查可能会带来额外的性能开销。参见第 D.2 节 [函数调用的强化]，第 1197 页。

#### _DYNAMIC_STACK_SIZE_SOURCE

如果定义了此宏，则会定义正确的（但非编译时常量）MINSIGSTKSZ、SIGSTKSZ 和 PTHREAD STACK MIN。

#### _REENTRANT、_THREAD_SAFE

这些宏已过时。它们与定义 `_POSIX_C_SOURCE` 并赋值为 199506L 具有相同的效果。 一些非常老的 C 标准库需要定义其中一个宏，以确保基本功能（例如 getchar）在多线程环境下是安全的。

我们建议您在新的程序中使用 `_GNU_SOURCE`。如果您未向 GCC 指定 ‘-ansi’ 选项或其他符合性选项（如 -std=c99），且未显式定义这些宏，其效果与将 `_DEFAULT_SOURCE` 设置为 1 相同。

当您定义一个功能测试宏以请求更大范围的功能时，同时定义该功能子集的功能测试宏是无害的。例如，如果您定义了 `_POSIX_C_SOURCE`，那么同时定义 `_POSIX_SOURCE` 也不会产生任何影响。同样地，如果你定义了 `_GNU_SOURCE`，那么同时定义 `_POSIX_SOURCE` 或 `_POSIX_C_SOURCE` 也不会产生任何影响。


