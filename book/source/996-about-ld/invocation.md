# 调用

GNU链接器旨在涵盖广泛的情况，并尽可能与其他链接器兼容。因此，您有很多选择来控制它的行为。

## 命令行选项

链接器支持大量的命令行选项，但在实际操作中，它们很少用于任何特定的上下文中。例如，ld的一个常用用法是在一个受支持的标准Unix系统上链接标准Unix对象文件。在这样的系统中，链接文件hello.o：

```shell
ld -o output /lib/crt0.o hello.o -lc
```

这条指令告诉链接器，使用 /lib/crt0.o、htllo.o 以及库libc.a生成一个名为output的文件。

一些命令行选项可以在命令行中的任何位置指定。但是，引用文件的选项，如‘-l’或‘-T’，会在命令行中出现该选项时读取文件，因此需要注意目标文件和其他文件选项之间的依赖关系。使用不同的参数重复非文件选项没有进一步的效果，可能会覆盖先前出现的该选项（命令行上更左边的那些）。

必要参数指要链接在一起的目标文件或归档文件。它们可以跟在命令行选项后面、前面，也可以与命令行选项混合在一起，除非对象文件参数不能放在选项和它的参数之间。

链接器至少包含一个对象文件作为输入，否则链接器不会生成任何文件，并报错：'no input files'

如果链接器不能识别目标文件的格式，它将假定它是一个链接器脚本。这种方式指定的脚本会作为链接器主链接脚本的补充，使用'-T'选项则会完全替换默认链接器脚本。

对于名称为单个字母的选项，选项参数必须紧跟选项字母而不加空格，或者作为单独的参数紧接在需要它们的选项后面。

对于名称由多个字母组成的选项，可以在选项名称前加一个或两个破折号；例如，‘-trace-symbol’和‘--trace-symbol’是等价的。注意，这条规则有一个例外。以小写“o”开头的多个字母选项前面只能有两个破折号。这是为了减少与‘-o’选项的混淆。例如，‘-magic’将输出文件名设置为‘magic’，而‘--magic’将设置输出文件的NMAGIC标志。

多字母选项的参数必须用等号与选项名分开，或者作为单独的参数紧接在需要它们的选项后面。例如，‘--trace-symbol foo’和‘--trace-symbol=foo’是等价的。接受多个字母选项名称的唯一缩写。

注意：如果链接器是通过编译器驱动程序（例如‘gcc’）间接调用的，那么所有的链接器命令行选项都应该以‘-Wl’作为前缀，（或任何适合特定编译器驱动程序的前缀），像这样：

```shell
gcc -Wl,--start-group foo.o bar.o -Wl,--end-group
```

这一点很重要，因为某些情况编译器驱动程序可能会静默地删除链接器选项，从而导致错误的链接。当通过驱动程序传递需要值的选项时，也可能出现混淆，因为在选项和参数之间使用空格作为分隔符，并导致驱动程序仅将选项传递给链接器并将参数传递给编译器。在这种情况下，最简单的是使用单字母和多字母选项的连接形式，例如：
```shell
gcc foo.o bar.o -Wl,-eENTRY -Wl,-Map=a.map
```

以下是链接器可接受的命令行选项

### 链接器命令行选项

#### @file 

从文件中读取命令行选项。选项read被插入到原来的@file选项的位置。如果文件不存在，或者无法读取，那么该选项将被按字面处理，而不会被删除。

file中的选项以空格分隔。通过将整个选项用单引号或双引号括起来，可以将空白字符包含在选项中。任何字符（包括反斜杠）都可以通过在要包含的字符前加上反斜杠来包含。文件本身可能包含额外的@file选项；任何这样的选项都将被递归地处理。

#### -a keyword

HP/UX兼容性支持此选项。关键字参数必须是字符串‘archive’， ‘shared’或‘default’之一。‘-aarchive’在功能上等同于‘-Bstatic’，其他两个关键字在功能上等同于‘-Bdynamic’。此选项可以使用任意次数。

#### --audit AUDITLIB

将AUDITLIB添加到动态节的DT_AUDIT项中。不检查AUDITLIB是否存在，也不会使用库中指定的DT_SONAME。如果多次指定，DT_AUDIT将包含一个冒号分隔的审计接口列表。如果链接器在搜索共享库时发现具有审计项的对象，它将在输出文件中添加相应的DT_DEPAUDIT项。这个选项只有在支持rtld-audit接口的ELF平台上才有意义。

#### -b input-format(--format=input-format)

ld可以配置为支持一种以上的目标文件。如果您的ld是以这种方式配置的，那么您可以使用‘-b’选项在命令行中为跟随该选项的输入对象文件指定二进制格式。即使将ld配置为支持其他对象格式，您通常也不需要指定它，因为应该将ld配置为期望每台机器上最常用的格式作为默认输入格式。input-format为文本字符串，BFD库支持的特定格式的名称。（您可以使用‘objdump -i’列出可用的二进制格式）。

如果要用不寻常的二进制格式链接文件，则可能需要使用此选项。您还可以使用‘-b’显式切换格式（当链接不同格式的目标文件时），通过在特定格式的每组目标文件之前包含‘-b input-format’。

默认格式取自环境变量gnuttarget。参见环境变量。还可以使用TARGET命令从脚本中定义输入格式。

#### -c MRI-commandfile(--mri-script=MRI-commandfile)

为了与MRI产生的链接器兼容，ld接受用另一种受限制的命令语言编写的脚本文件，这些脚本文件在MRI兼容脚本文件中进行了描述。引入带有选项‘-c’的MRI脚本文件；使用‘-T’选项运行用通用old脚本语言编写的链接器脚本。如果MRI-cmdfile不存在，ld将在‘-L’选项指定的目录中查找它。

#### -d -dc -dp

这三个选项是等价的；为了与其他链接器兼容，支持多个表单。即使指定了可重定位的输出文件（使用‘-r’），它们也会为通用符号分配空间。脚本命令`FORCE_COMMON_ALLOCATION`具有相同的效果。

#### --depaudit AUDITLIB(-P AUDITLIB)

将AUDITLIB添加到动态节的`DT_DEPAUDIT`项中。不检查`AUDITLIB`是否存在，也不会使用库中指定的`DT_SONAME`。如果多次指定，`DT_DEPAUDIT`将包含一个冒号分隔的审计接口列表。这个选项只有在支持rtld-audit接口的ELF平台上才有意义。提供-P选项是为了Solaris兼容性。

#### --enable-linker-version

启用`LINK_VERSION`链接器脚本指令，在输出部分数据中描述。如果在一个链接器脚本中使用了这个指令，并且这个选项已经启用，那么一个包含链接器版本的字符串将被插入到当前点。

注意-该选项在链接器命令行上的位置非常重要。它只会影响命令行中紧随其后的链接器脚本，或者内置于链接器中的链接器脚本。

#### --disable-linker-version

 禁用`LINK_VERSION`链接器脚本指令。不插入版本信息字符串(默认选项)。

#### --enable-non-contiguous-regions

此选项可避免在输入部分与匹配的输出部分不匹配时生成错误。链接器试图将输入部分分配给匹配输出部分的子序列，只有在没有足够大的输出部分时才会生成错误。当几个非连续的内存区域可用并且输入部分不需要特定的内存区域时，这是有用的。输入部分的求值顺序不会改变，例如：

```
MEMORY {
    MEM1 (rwx) : ORIGIN = 0x1000, LENGTH = 0x14
    MEM2 (rwx) : ORIGIN = 0x1000, LENGTH = 0x40
    MEM3 (rwx) : ORIGIN = 0x2000, LENGTH = 0x40
}
SECTIONS {
    mem1 : { *(.data.*); } > MEM1
    mem2 : { *(.data.*); } > MEM2
    mem3 : { *(.data.*); } > MEM3
}

with input sections:
.data.1: size 8
.data.2: size 0x10
.data.3: size 4

results in .data.1 affected to mem1, and .data.2 and .data.3
affected to mem2, even though .data.3 would fit in mem3.
```
此选项与INSERT语句不兼容，因为它改变了输入节映射到输出节的方式。

#### --enable-non-contiguous-regions-warnings

当`——enable-non-continuous-regions`允许在部分映射中可能出现意外匹配时，此选项启用警告。


#### -e entry(--entry=entry)

使用entry作为程序开始执行的显式符号，而不是默认的入口点。如果没有名为entry的符号，链接器将尝试将entry解析为一个数字，并使用该数字作为入口地址(该数字将以10为基数进行解释；你可以使用前导‘0x’来表示基数16，或者使用前导‘0’来表示基数8)。

#### --exclude-libs lib,lib,...

指定不应从中自动导出符号的存档库列表。库名可以用逗号或冒号分隔。指定`——exclude-libs ALL`将所有归档库中的符号从自动导出中排除。此选项仅适用于链接器的i386 PE目标端口和ELF目标端口。对于i386 PE，在.def文件中显式列出的符号仍然被导出，不管这个选项是什么。对于ELF目标端口，受此选项影响的符号将被视为隐藏。

#### --exclude-modules-for-implib module,module,...

指定目标文件或存档成员的列表，其中不应自动导出符号，但应将其批量复制到链接期间生成的导入库中。模块名可以用逗号或冒号分隔，并且必须与ld打开文件时使用的文件名完全匹配；对于归档成员，这只是成员名，但对于对象文件，列出的名称必须包括并精确匹配用于指定链接器命令行上的输入文件的任何路径。此选项仅适用于链接器的i386 PE目标端口。在.def文件中显式列出的符号仍然会导出，无论是否使用此选项。

#### -E(--export-dynamic) --no-export-dynamic

在创建动态链接的可执行文件时，使用-E选项或--export-dynamic选项会导致链接器将所有符号添加到动态符号表中。动态符号表是在运行时从动态对象中可见的符号集。

如果您不使用这些选项中的任何一个（或使用--no-export-dynamic选项来恢复默认行为），动态符号表通常只包含那些被链接中提到的某个动态对象引用的符号。

如果您使用dlopen来加载需要引用程序定义的符号的动态对象，而不是其他动态对象，那么在链接程序本身时可能需要使用此选项。

如果输出格式支持，还可以使用动态列表来控制应该将哪些符号添加到动态符号表中。参见‘--dynamic-list’的描述。

注意，这个选项是针对ELF目标端口的。PE目标支持从DLL或EXE导出所有符号的类似功能；参见下面‘--export-all-symbols’的描述。

#### --export-dynamic-symbol=glob

当创建动态链接的可执行文件时，与glob匹配的符号将被添加到动态符号表中。在创建共享库时，对匹配glob的符号的引用不会绑定到共享库中的定义。当创建共享库且未指定‘-Bsymbolic’或‘--dynamic-list’时，此选项不适用。这个选项只有在支持共享库的ELF平台上才有意义。

#### --export-dynamic-symbol-list=file

为文件中的每个模式指定一个‘--export-dynamic-symbol’。文件格式与版本节点相同，没有作用域和节点名。

#### -EB

链接大端对象。这会影响默认的输出格式。

#### -EL

链接小端对象。
 
#### -f name(--auxiliary=name)

当创建一个ELF共享对象时，将内部`DT_AUXILIARY`字段设置为指定的名称。这告诉动态链接器，共享对象的符号表应该用作共享对象名称的符号表上的辅助过滤器。

如果稍后将程序链接到此筛选器对象，那么在运行该程序时，动态链接器将看到`DT_AUXILIARY`字段。如果动态链接器解析了过滤器对象中的任何符号，它将首先检查共享对象名称中是否有定义。如果有，将使用它来代替过滤器对象中的定义。共享对象名称不需要存在。因此，共享对象名称可用于提供某些功能的替代实现，可能用于调试或特定于机器的性能。

此选项可以指定多次。`DT_AUXILIARY`项将按照它们在命令行中出现的顺序创建。

#### -F name(--filter=name)

在创建ELF共享对象时，将内部`DT_FILTER`字段设置为指定的名称。这告诉动态链接器，正在创建的共享对象的符号表应该用作共享对象名称的符号表上的过滤器。

如果稍后将程序链接到此筛选器对象，那么，当您运行程序时，动态链接器将看到`DT_FILTER`字段。动态链接器将像往常一样根据过滤器对象的符号表解析符号，但它实际上会链接到共享对象名称中找到的定义。因此，过滤器对象可用于选择由对象名称提供的符号子集。

一些旧的链接器在整个编译工具链中使用`-F`选项来指定输入和输出对象文件的对象文件格式。GNU链接器为此目的使用其他机制：`-b`、`--format`、`--oformat`选项、链接器脚本中的`TARGET`命令和`gnuttarget`环境变量。当不创建一个ELF共享对象时，GNU链接器将忽略`-F`选项。

#### -fini=name

当创建一个ELF可执行或共享对象时，通过将`DT_FINI`设置为函数的地址，在可执行或共享对象被卸载时调用NAME。默认情况下，链接器使用`_fini`作为要调用的函数。

#### -g

忽略。为其它工具提供兼容性

#### -G value(--gpsize=value)

使用GP寄存器设置要优化的对象的最大大小为size。这只对对象文件格式有意义，例如MIPS ELF，它支持将大小对象放入不同的节中。对于其他对象文件格式，这将被忽略。

#### -h name(-soname=name)

在创建ELF共享对象时，将内部`DT_SONAME`字段设置为指定的名称。当可执行文件与具有`DT_SONAME`字段的共享对象链接时，当可执行文件运行时，动态链接器将尝试加载由`DT_SONAME`字段指定的共享对象，而不是使用给定给链接器的文件名。

#### -i

执行增量链接（与选项‘-r’相同）。

#### -init=name

当创建一个ELF可执行对象或共享对象时，通过将`DT_INIT`设置为函数的地址，在加载可执行对象或共享对象时调用`NAME`。默认情况下，链接器使用`_init`作为要调用的函数。

#### -l namespace(--library=namespace)

将由namespec指定的归档文件或目标文件添加到要链接的文件列表中。此选项可以使用任意次数。如果namespec的格式是：filename， ld将在库路径中搜索名为filename的文件，否则将在库路径中搜索名为libnamespec.a的文件。

在支持共享库的系统上，ld也可以搜索libnamespec.a以外的文件。具体来说，在ELF和SunOS系统上，ld将在目录中搜索名为libnamespec的库。所以在搜索libnamespec.a之前。（按照惯例，.so扩展名表示共享库。）注意，此行为不适用于：filename，它总是指定一个名为filename的文件。

链接器只会在命令行中指定的位置搜索存档文件一次。如果存档文件定义了一个符号，而该符号在命令行存档文件之前出现的某个对象中是未定义的，则链接器将包括来自存档文件的适当文件。但是，稍后在命令行上出现的对象中的未定义符号不会导致链接器再次搜索存档。

您可以在命令行中多次列出相同的归档文件。

这种类型的存档搜索是Unix链接器的标准。但是，如果您在AIX上使用ld，请注意它与AIX链接器的行为不同。

#### -L searchdir(--library-path=searchdir)

将路径searchdir添加到ld将搜索存档库和ld控制脚本的路径列表中。您可以多次使用此选项。目录按照在命令行中指定的顺序进行搜索。在命令行中指定的目录将在默认目录之前搜索。-L选项无论出现的顺序都生效。-L选项不影响搜索链接器脚本的方式，除非指定了-T选项。

如果searchdir以=或$SYSROOT开头，那么这个前缀将被SYSROOT前缀取代，由‘--SYSROOT ’选项控制，或者在配置链接器时指定。

搜索的默认路径集（没有使用‘-L’指定）取决于ld使用的仿真模式，在某些情况下还取决于它是如何配置的。

也可以使用`SEARCH_DIR`命令在链接脚本中指定路径。以这种方式指定的目录将在命令行中出现链接器脚本的位置进行搜索。

#### -m emulation

模拟仿真链接器。您可以使用‘--verbose’或‘-V’选项列出可用的模拟。

如果未使用‘-m’选项，则从ldemulate环境变量（如果定义了该变量）获取仿真。

否则，默认模拟取决于链接器的配置方式。

#### --remap-inputs=pattern=filename(--remap-inputs-file=file)

这些选项允许在链接器尝试打开输入文件之前更改它们的名称。选项`--remmap -inputs=foo.o=bar.o`将导致任何加载名为foo.o的文件都变为尝试加载一个名为bar.o的文件。在第一个文件名中允许使用通配符模式，因此`--remap-inputs=foo*.o=bar.o`将重命名任何与`foo*.o`匹配的输入文件为`bar.o`。

选项`--remap-inputs-file=filename`的另一种形式允许从文件中读取重新标记。文件中的每一行都可以包含一个重新映射。空行将被忽略。从散列字符（'#'）到行尾的任何内容都被认为是注释，也会被忽略。映射模式可以用空格或等号（'='）字符与文件名分开。

这些选项可以被指定多次。它们的内容会累积。重新标识将按照它们在命令行中出现的顺序进行处理，如果它们来自文件，则按照它们在文件中出现的顺序进行处理。如果匹配成功，则不再执行该文件名的进一步检查。

如果替换文件名是`/dev/null`或只是`NUL`，那么重新映射实际上会导致输入文件被忽略。这是一种方便的方法，可以从复杂的构建环境中删除输入文件。

请注意，此选项与位置相关，并且仅影响命令行中紧随其后的文件名。因此:
```shell
ld foo.o --remap-inputs=foo.o=bar.o
```

将不起作用，而：
```shell
ld --remap-inputs=foo.o=bar.o foo.o
```
将把输入文件foo.o重命名为bar.o

> 注意：这些选项也会影响链接器脚本中INPUT语句引用的文件。但是，由于链接器脚本是在读取整个命令行之后处理的，所以命令行上的重新映射选项的位置并不重要。

如果启用了verbose选项，那么将报告任何匹配的映射，尽管在重新映射的文件名出现之前需要再次在命令行上启用verbose选项。

如果启用了 `-Map` 或 `--print-map`选项，则映射输出中将包含重新映射列表

#### -M(--print-map)

将链接映射打印到标准输出。链接映射提供了有关链接的信息，包括以下内容：
- 其中对象文件被映射到内存。
- 如何分配常见的符号。
- 链接中包含的所有存档成员，并提及导致存档成员被引入的符号。
- 赋给符号的值。如果符号的值是通过引用同一符号的前一个值的表达式来计算的，那么在链接映射中可能不会显示正确的结果。这是因为链接器丢弃中间结果，只保留表达式的最终值。在这种情况下，链接器将显示用方括号括起来的最终值。例如，一个链接器脚本包含：
    ```
    foo = 1
    foo = foo * 4
    foo = foo + 8
    ```
    如果使用-M选项，将在链接映射中产生以下输出：
    ```
    0x00000001                foo = 0x1
    [0x0000000c]              foo = (foo * 0x4)
    [0x0000000c]              foo = (foo + 0x8)
    ```
- GNU属性是如何合并的：当链接器合并输入`.note.gnu.property`节的时候将变成一个输出`.note.gnu.property`节，一些属性被删除或更新。这些操作将在链接映射中报告。例如:
    ```
    Removed property 0xc0000002 to merge foo.o (0x1) and bar.o (not found)
    ```
    这表明在合并foo.o中的属性时，将从输出中删除属性0xc0000002，其属性0xc0000002值为0x1，bar.o中没有属性0xc0000002。
    ```
    Updated property 0xc0010001 (0x1) to merge foo.o (0x1) and bar.o (0x1)
    ```
    这表明在合并foo.o中的属性时，输出中的属性0xc0010001值被更新为0x1。其0xc0010001属性值为0x1，bar.o，中其0xc0010001属性值为0x1。
- 在一些ELF目标上，由`--relax`插入的修复程序列表
    ```
    foo.o: Adjusting branch at 0x00000008 towards "far" in section .text
    ```
    这表明foo.o中的分支位于0x00000008，针对text部分中的符号“far”，已被取代。
#### --print-map-discarded --no-print-map-discarded

打印（或不打印）链接图中丢弃和垃圾收集部分的列表。默认开启。

#### --print-map-locals --no-print-map-locals

打印（或不打印）链接映射中的本地符号。局部符号将在其名称之前打印文本‘(Local)’，并将在给定部分中的所有全局符号之后列出。临时局部符号（通常以‘.L’开头）将不包含在输出中。默认为关闭。

#### -n --nmagic

关闭部分的页面对齐，并禁用针对共享库的链接。如果输出格式支持Unix风格的幻数，则将输出标记为NMAGIC。

#### -N --omagic

将文本和数据部分设置为可读和可写。此外，不要对数据段进行页面对齐，并禁用针对共享库的链接。如果输出格式支持Unix风格的幻数，则将输出标记为OMAGIC。注意：尽管PE-COFF目标允许可写的文本部分，但它不符合Microsoft发布的格式规范。

#### --no-omagic

这个选项消除了-N选项的大部分效果。它将文本部分设置为只读，并强制数据段与页面对齐。注意-此选项不启用针对共享库的链接。为此使用-Bdynamic。

#### -o output(--output=output)

使用output作为ld生成的程序的名称；如果未指定此选项，则默认使用a.out名称。脚本命令OUTPUT也可以指定输出文件名。

注意-链接器将在开始写入输出文件之前删除它。即使链接由于错误而无法完成，它也会这样做。

注意：链接器将检查以确保输出文件名与任何输入文件名不匹配，但仅此而已。特别是，如果输出文件可能覆盖源文件或其他一些重要文件，它不会报错。因此，在构建系统中，建议使用-o选项作为链接器命令行上的最后一个选项。例如：
```shell
ld -o $(EXE) $(OBJS)
ld $(OBJS) -o $(EXE)
```
如果由于某种原因没有定义‘EXE’变量，则链接器命令的第一个版本可能最终会删除一个目标文件（‘OBJS’列表中的第一个文件），而链接器命令的第二个版本将生成错误消息而不删除任何内容。

#### --dependency-file=depfile

写一个依赖文件到depfile。该文件包含一个适用于make的规则，该规则描述了输出文件以及为生成输出文件而读取的所有输入文件。输出类似于带有‘-M -MP’的编译器的输出（参见使用GNU编译器集合中的选项控制预处理器）。请注意，没有像编译器的‘-MM’这样的选项来排除“系统文件”（这在链接器中不是一个指定良好的概念，不像编译器中的“系统头文件”）。因此，“--dependency-file”的输出总是特定于产生它的安装的确切状态，不应该在没有仔细编辑的情况下复制到分布式的makefiles中。

#### -O level

如果level是一个大于零的数值，则会优化输出。这可能需要更长的时间，因此可能应该只对最终的二进制文件启用。目前这个选项只影响ELF共享库的生成。链接器的未来版本可能会更多地使用此选项。目前，对于该选项的不同非零值，链接器的行为也没有区别。同样，这可能会随着未来的版本而改变。

#### -plugin name

在链接过程中涉及一个插件。name参数是插件的绝对文件名。通常这个参数是由编译器自动添加的，当使用链接时间优化时，但用户也可以添加自己的插件，如果他们愿意的话。

注意，编译器生成插件的位置与ar、nm和ranlib程序搜索插件的位置是不同的。为了使这些命令能够使用基于编译器的插件，必须首先将其复制到`${libdir}/bfd-plugins`目录中。所有基于gcc的链接器插件都是向后兼容的，因此只需复制最新的插件就足够了。

#### --push-state

--push-state允许保留控制输入文件处理的标志的当前状态，以便它们都可以通过一个相应的--pop-state选项恢复。

这些选项包括：-Bdynamic、-Bstatic、-dn、-dy、-call_shared、-non_shared、-static、-N、-N、--whole-archive、--no-whole-archive、-r、-Ur、--copy-dt-needed-entries、--no-copy-dt-needed-entries、--as-needed、--no-as-needed和-a。

此选项的一个目标是pkg-config的规范。当与--libs选项一起使用时，所有可能需要的库都被列出，然后可能一直被链接。最好返回如下内容：
```
-Wl,--push-state,--as-needed -libone -libtwo -Wl,--pop-state
```

#### --pop-state

撤消-push-state的作用，恢复控制输入文件处理的标志的先前值。

#### -q(--emit-relocs)

将重定位节和内容保留在完全链接的可执行文件中。链接后分析和优化工具可能需要这些信息，以便对可执行文件进行正确的修改。这将导致更大的可执行文件。

此选项目前仅在ELF平台上受支持。

#### --force-dynamic

强制输出文件具有动态节。该选项特定于VxWorks目标。

#### -r(--relocatable)

生成可重新定位的输出，即，生成一个输出文件，该文件反过来可以作为ld的输入。这通常称为部分链接。作为一个副作用，在支持标准Unix幻数的环境中，该选项还将输出文件的幻数设置为OMAGIC。如果未指定此选项，则生成一个绝对文件。当链接c++程序时，此选项不会解析对构造函数的引用；要做到这一点，使用‘-Ur’。

当输入文件的格式与输出文件不同时，只有在该输入文件不包含任何重定位时才支持部分链接。不同的输出格式可以有进一步的限制；例如，一些基于a.out的格式根本不支持与其他格式的输入文件的部分链接。

当可重定位输出包含需要链接时间优化（LTO）的内容和不需要LTO的内容时，将创建一个`.gnu_object_only`节来包含一个可重定位的对象文件，就好像‘-r’应用于所有不需要LTO的可重定位输入一样。当处理带有`.gnu_object_only`节的可重定位输入时，链接器将提取`.gnu_object_only`节作为单独的输入。

请注意，由于‘-r’将来自不同输入文件的某些部分组合在一起，因此可能会对最终可执行库或共享库中的代码大小和位置产生负面影响。

这个选项的作用与‘-i’相同。

#### -R filename(--just-symbols=filename)

从文件名中读取符号名称及其地址，但不重新定位它或将其包含在输出中。这允许您的输出文件符号地引用在其他程序中定义的内存的绝对位置。您可以多次使用此选项。
为了与其他ELF链接器兼容，如果-R选项后面跟着目录名，而不是文件名，则将其视为-rpath选项。

#### --rosegment、--no-rosegment

尝试确保只创建一个只读的非代码段。只有在与-z separate-code选项结合使用时才有用。生成的二进制文件应该比单独使用-z分隔代码时要小。如果没有这个选项，或者如果指定了--no-rosegment， -z separate-code选项将创建两个只读段，一个在代码段之前，一个在代码段之后。

这些选项的名称具有误导性，但选择它们是为了使链接器与LLD和GOLD链接器兼容。

这些选项只有ELF目标支持。

#### -s(--strip-all)

从输出文件中省略所有符号信息。

#### -S(--strip-debug)

从输出文件中省略调试器符号信息（但不是所有符号）。

#### --strip-discarded、--no-strip-discarded

省略（或不省略）在丢弃的节中定义的全局符号。默认开启。

#### -plugin-save-temps

永久存储插件“临时”中间文件。

#### -t(--trace)

在ld处理输入文件时打印它们的名称。如果‘-t’被输入两次，那么档案中的成员也会被打印出来。‘-t’输出对于生成链接中涉及的所有目标文件和脚本的列表很有用，例如，在为链接器错误报告打包文件时。

#### -T scriptfile(--script=scriptfile)

使用scriptfile作为链接器脚本。这个脚本替换了ld的默认链接器脚本（而不是添加到它中），除非脚本包含INSERT，所以commandfile必须指定描述输出文件所需的一切。参见链接器脚本。

如果scriptfile在当前目录中不存在，ld将在前面的‘-L’选项指定的目录中查找它。

出现在-T选项之前的命令行选项会影响脚本，但出现在-T选项之后的命令行选项不会。

如果多个‘-T’选项正在增加当前脚本，则会累积多个‘-T’选项，否则将使用最后一个非增加的-T选项。

#### -dT scriptfile(--default-script=scriptfile)

使用scriptfile作为默认的链接器脚本。参见链接器脚本。

该选项类似于`--script`选项，不同之处在于，脚本的处理将延迟到处理完命令行其余部分之后。这允许放置在命令行`--default-script`选项之后的选项影响链接器脚本的行为，当用户不能直接控制链接器命令行时，这一点很重要。（例如，因为命令行是由另一个工具构建的，例如‘gcc’）。

#### -u symbol(--undefined=symbol)

强制符号作为未定义符号输入到输出文件中。例如，这样做可能会触发从标准库中链接其他模块。‘-u’可以与不同的选项参数一起重复，以输入其他未定义的符号。这个选项相当于EXTERN链接器脚本命令。

如果使用该选项强制将其他模块拉入链接，并且如果符号保持未定义是错误的，则应该使用选项--require-defined。

#### --require-defined=symbol

要求在输出文件中定义该符号。该选项与--undefined相同，不同之处在于如果symbol未在输出文件中定义，则链接器将发出错误并退出。通过同时使用EXTERN、ASSERT和DEFINED，在链接器脚本中也可以达到同样的效果。此选项可以多次使用以需要额外的符号。

#### -Ur

对于不使用构造函数或析构函数的程序，或基于ELF的系统，此选项相当于-r：它生成可重定位的输出，即：对于其他二进制文件，-Ur选项类似于-r，但它也解析对构造函数和析构函数的引用。
对于那些-r和-Ur行为不同的系统，在本身与-Ur链接的文件上使用-Ur不起作用；构造函数表构建完成后，就不能再添加它了。仅对最后一个部分链接使用-Ur，对其他部分使用-r。

#### --orphan-handling=MODE

控制孤立部分的处理方式。孤儿节是在链接器脚本中没有特别提到的部分。

MODE可以是以下任意值：
- place: 按照孤立部分中描述的策略，将孤立部分放置到合适的输出部分中。选项“--unique”也会影响section的放置方式。
- discard: 所有孤儿节都将被丢弃，将它们放置在‘/DISCARD/’节中。
- warn: 链接器将把孤儿节放置在适当的位置，并发出警告。
- error: 如果发现任何孤立节，链接器将退出并显示错误。

> 默认不设置此配置项

#### --unique[=SECTION]

为每个匹配section的输入节创建一个单独的输出节，或者如果缺少可选通配符section参数，则为每个孤立输入节创建一个单独的输出节。孤儿节是在链接器脚本中没有特别提到的部分。您可以在命令行中多次使用此选项；它可以防止在链接器脚本中合并具有相同名称的输入节，从而覆盖输出节的赋值。

#### -v(--version、-V)

显示ld的版本号。-V选项还列出支持的模拟。另请参见命令行选项中--enable-link -version的描述，它可用于将链接器版本字符串插入到二进制文件中。

#### -x(--discard-all)

删除所有本地符号

#### -X(--discard-locals)

删除所有临时本地符号。(这些符号以系统特定的本地标签前缀开头，通常是'.L‘表示ELF系统，'L'表示传统的a.out系统)。

#### -y symbol(--trace-symbol=symbol)

打印出现符号的每个链接文件的名称。这个选项可以被给定任意次数。在许多系统中，必须在前面加上下划线。

当您的链接中有一个未定义的符号，但不知道引用来自何处时，此选项非常有用。

#### -Y path

将path添加到默认库搜索路径中。这个选项是为了Solaris兼容性而存在的。

#### -z keyword

可识别的关键字有：
- 'call-nop=prefix-addr'、'call-nop=suffix-nop'、'call-nop=prefix-byte'、'call-nop=suffix-byte'：在通过GOT槽转换对本地定义函数foo的间接调用时，指定1字节的NOP填充。call-nop=prefix-addr产生0x67调用foo。call-nop=suffix-nop产生0x90调用foo。call-nop=prefix-byte生成字节调用foo。call-nop=suffix-byte生成call foo字节。支持i386和x86_64。
- 'cet-report=none'、'cet-report=warning'、'cet-report=error'：在input `.note.gnu`中指定如何报告丢失的`GNU_PROPERTY_X86_FEATURE_1_IBT`和`GNU_PROPERTY_X86_FEATURE_1_SHSTK`属性。属性部分。`Cet-report=none`是默认值，它将使链接器不报告输入文件中丢失的属性。`Cet-report=warning`将使链接器对输入文件中缺少的属性发出警告。`Cet-report=error`将使链接器对输入文件中缺少的属性发出错误。注意，ibt将关闭丢失的`GNU_PROPERTY_X86_FEATURE_1_IBT`属性报告，shstk将关闭丢失的`GNU_PROPERTY_X86_FEATURE_1_SHSTK`属性报告。支持Linux/i386和Linux/x86_64。
- 'combreloc'、'nocombreloc'：组合多个动态重定位节和排序以改进动态符号查找缓存。如果‘nocombreloc’，不要这样做。
- 'common'、'nocommon'：在可重定位链接期间生成`STT_COMMON`类型的公共符号。如果`nocommon`使用`STT_OBJECT`类型。
- 'common-page-size=value'：设置最常用的页面大小为value。如果系统使用这种大小的页面，将对内存映像布局进行优化，以最小化内存页面
- 'defs'：报告常规对象文件中未解析的符号引用。即使链接器正在创建非符号共享库，也会执行此操作。这个选项与'-z undefs' 相反。
- 'dynamic-undefined-weak'、'nodynamic-undefined-weak'：在构建动态对象时，如果未定义的弱符号是从常规对象文件引用的，并且没有通过符号可见性或版本控制强制在本地引用，则将其设置为动态。如果是“nodynamic-undefined-weak”，不要将它们设置为动态的。如果两个选项都没有给出，目标可能默认使用其中一个选项，或者动态选择其他未定义的弱符号。并非所有目标都支持这些选项。
- 'execstack'：将对象标记为需要可执行堆栈。
- 'global'：此选项仅在构建共享对象时才有意义。它使此共享对象定义的符号可用于随后加载的库的符号解析。
- 'globalaudit'：此选项仅在构建动态可执行文件时才有意义。该选项通过在`DT_FLAGS_1`动态标记中设置`DF_1_GLOBAUDIT`位，将可执行文件标记为需要全局审计。全局审计要求对应用程序加载的所有动态对象运行通过`--deaudit`或`-P`命令行选项定义的任何审计库
- 'ibtplt'：生成Intel间接分支跟踪（IBT）使能PLT条目。支持Linux/i386和Linux/x86_64。
- 'ibt'：在`.note.gnu`中生成`GNU_PROPERTY_X86_FEATURE_1_IBT`。属性部分，以指示与IBT的兼容性。这也意味着ibtplt。支持Linux/i386和Linux/x86_64。
- 'indirect-extern-access'、'noindirect-extern-access'：在`.note.gnu`中生成`GNU_PROPERTY_1_NEEDED_INDIRECT_EXTERN_ACCESS`。属性节以指示目标文件需要规范函数指针，并且不能与副本重定位一起使用。此选项还意味着没有外部保护数据和没有copyreloc。支持i386和x86-64。
- 'initfirst'：此选项仅在构建共享对象时才有意义。它标记对象，以便它的运行时初始化将在同时带入进程的任何其他对象的运行时初始化之前发生。类似地，对象的运行时结束将发生在任何其他对象的运行时结束之后。
- 'interpose'：指定动态加载器应修改其符号搜索顺序，以便此共享库中的符号可以插入所有其他没有这样标记的共享库。
- 'unique'、'nounique'：在生成共享库或其他可动态加载的ELF对象时，将其标记为（默认情况下）只应该加载一次，并且只在主名称空间中（使用dlmopen时）。这主要用于标记基本库，如libc， libpthread等，这些库通常不能正常工作，除非它们是自身的唯一实例。这种行为可以被dlmopen调用者覆盖，并且不适用于某些加载机制（例如审计库）。
- 'lam-u48'：在`.note.gnu`中生成`GNU_PROPERTY_X86_FEATURE_1_LAM_U48`。属性节以指示与Intel `LAM_U48`的兼容性。支持Linux/x86_64。
- 'lam-u57'：在`.note.gnu`中生成`GNU_PROPERTY_X86_FEATURE_1_LAM_U57`。属性节以指示与Intel `LAM_U57`的兼容性。支持Linux/x86_64。
- 'lam-u48-report=none'、'lam-u48-report=warning'、'lam-u48-report=error'：在input `.note.gnu`中指定如何报告丢失的`GNU_PROPERTY_X86_FEATURE_1_LAM_U48`属性。`Lam-u48-report=none`，这是默认值，将使链接器不报告输入文件中丢失的属性。`Lam-u48-report=warning`将使链接器对输入文件中缺少的属性发出警告。`Lam-u48-report=error`将使链接器对输入文件中缺少的属性发出错误。支持Linux/x86_64。
- 'lam-u57-report=none'、'lam-u57-report=warning'、'lam-u57-report=error'：在input `.note.gnu`中指定如何报告丢失的`GNU_PROPERTY_X86_FEATURE_1_LAM_U57`属性。`Lam-u57-report=none`，默认值，将使链接器不报告输入文件中丢失的属性。`Lam-u57-report=warning`将使链接器对输入文件中缺少的属性发出警告。`Lam-u57-report=error`将使链接器对输入文件中丢失的属性发出错误。支持Linux/x86_64。
- 'lam-report=none'、'lam-report=warning'、'lam-report=error'：在input `.note.gnu`中指定如何报告丢失的`GNU_PROPERTY_X86_FEATURE_1_LAM_U48`和`GNU_PROPERTY_X86_FEATURE_1_LAM_U57`属性。`Lam-report=none`是默认值，它将使链接器不报告输入文件中丢失的属性。`Lam-report=warning`将使链接器对输入文件中缺少的属性发出警告。`Lam-report=error`将使链接器对输入文件中缺少的属性发出错误。支持Linux/x86_64。
- 'lazy'：在生成可执行库或共享库时，标记它以告诉动态链接器将函数调用解析推迟到调用函数时（惰性绑定），而不是在加载时。惰性绑定是默认的。
- 'loadfltr'：指定在运行时立即处理对象的筛选器。
- 'max-page-size=value'：将支持的最大内存页大小设置为value。
- 'mark-plt'、'nomark-plt'：用动态标记标记PLT表项，`DT_X86_64_PLT`，`DT_X86_64_PLTSZ`和`DT_X86_64_PLTENT`。由于该选项在`R_X86_64_JUMP_SLOT`重定位的`r_addend`字段中存储非零值，因此产生的可执行文件和共享库与动态链接器不兼容，例如那些在旧版本的glibc中没有更改在`R_X86_64_GLOB_DAT`和`R_X86_64_JUMP_SLOT`重定位中忽略`r_addend`的可执行文件和共享库，它们不会忽略`R_X86_64_JUMP_SLOT`重定位的`r_addend`字段。支持x86_64。
- 'muldefs'：允许多个定义
- 'nocopyreloc'：禁用链接器生成的`.dynbss`变量，以取代共享库中定义的变量。可能导致动态文本重定位。
- 'nodefaultlib'：指定动态加载器搜索此对象的依赖项时应忽略任何默认库搜索路径。
- 'nodelete'：指定不应在运行时卸载对象
- 'nodlopen'：指定对象不可由dlopen访问。
- 'nodump'：指定对象不可以使用dldump转储
- 'noexecstack'：将对象标记为不需要可执行堆栈。
- 'noextern-protected-data'：在构建共享库时，不要将受保护的数据符号视为外部的。此选项覆盖链接器后端默认值。它可用于解决编译器生成的受保护数据符号的错误重定位。其他模块对受保护数据符号的更新对生成的共享库是不可见的。支持i386和x86-64。
- 'noreloc-overflow'：禁用重新定位溢出检查。如果在运行时没有动态重定位溢出，则可使用此选项禁用重定位溢出检查。支持x86_64。
- 'memory-seal'、'nomemory-seal'：指示可执行库或共享库应该对所有PT_LOAD段进行密封，以避免进一步的操作（例如更改保护标志，段大小或删除映射）。这是一个需要系统支持的安全加固。这会在`.note.gnu`中生成`GNU_PROPERTY_MEMORY_SEAL`。属性节
- 'now'：在生成可执行库或共享库时，标记它以告诉动态链接器在程序启动时或通过dlopen加载共享库时解析所有符号，而不是将函数调用解析延迟到函数第一次调用时。
- 'origin'：指定对象在路径中需要‘$ORIGIN’处理
- 'pack-relative-relocs'、'nopack-relative-relocs'：在位置无关的可执行和共享库中生成紧凑的相对重定位。它将`DT_RELR`、`DT_RELRSZ`和`DT_RELRENT`表项添加到动态`section`中。在构建依赖于位置的可执行输出和可重定位输出时，它将被忽略。`Nopack-relative-relocs`是默认值，它禁用紧凑的相对重定位。当链接到GNU C库时，对共享C库的`GLIBC_ABI_DT_RELR`符号版本依赖被添加到输出中。支持i386和x86-64。
- 'relro'、'norelro'：在对象中创建一个`ELF PT_GNU_RELRO`段头。这指定了一个内存段，如果支持，在重定位后应该使其只读。指定“common-page size”小于系统页面大小将使此保护失效。如果‘ norelro ’，不要创建一个ELF `PT_GNU_RELRO`段。
- 'report-relative-reloc'：报告由链接器生成的动态相对重定位。支持Linux/i386和Linux/x86_64。
- 'sectionheader'、'nosectionheader'：生成节头。如果使用‘nosectionheader’，则不要生成节头。Sectionheader是默认的。
- 'separate-code'、'noseparate-code'：在对象中创建单独的代码PT_LOAD段头。这指定了一个内存段，该段应该只包含指令，并且必须位于与任何其他数据完全分离的页面中。如果使用‘noseparate-code’，不要创建单独的PT_LOAD段。
- 'shstk'：在`.note.gnu`中生成`GNU_PROPERTY_X86_FEATURE_1_SHSTK`。属性部分以指示与Intel Shadow Stack的兼容性。支持Linux/i386和Linux/x86_64。
- 'stack-size=value'：指定一个ELF PT_GNU_STACK段的堆栈大小。指定零将覆盖任何默认的非零大小的PT_GNU_STACK段创建。
- 'start-stop-gc'、'nostart-stop-gc'：当‘--gc-sections’生效时，如果SECNAME可表示为C标识符，并且链接器合成了`__start_SECNAME`或`__stop_SECNAME`，则从保留节到`__start_SECNAME`或`__stop_SECNAME`的引用将导致所有名为SECNAME的输入节也被保留。‘-z start-stop-gc’禁用这种效果，允许对部分进行垃圾收集，就好像没有定义特殊的合成符号一样。‘-z start-stop-gc’对对象文件或链接器脚本中`__start_SECNAME`或`__stop_SECNAME`的定义没有影响。这样的定义将防止链接器分别提供合成的`__start_SECNAME`或`__stop_SECNAME`，因此垃圾收集对这些引用进行特殊处理。
- 'start-stop-visibility=value'：为合成的`__start_SECNAME`和`__stop_SECNAME`符号指定ELF符号可见性（参见输入部分示例）。值必须恰好是‘default’、‘internal’、‘hidden’或‘protected’。如果没有给出‘-z start-stop-visibility’选项，则使用‘protected’以与历史实践兼容。然而，强烈建议在新程序和共享库中使用‘-z start-stop-visibility=hidden’，这样这些符号就不会在共享对象之间导出，这通常不是我们想要的。
- 'text'、'notext'、'textoff'：如果设置了`DT_TEXTREL`，即，如果位置无关或共享对象在只读段中有动态重定位，则报告错误。如果‘notext’或‘textoff’，不要报告错误。
- 'undefs'：在创建可执行文件或创建共享库时，不要报告来自常规对象文件的未解析符号引用。这个选项与‘-z defs’相反。
- 'unique-symbol'、'nounique-symbol'：避免在符号字符串表中出现重复的局部符号名。添加'.number'如果使用‘unique-symbol’，则为重复的本地符号名称。唯一符号是默认值。
- 'x86-64-baseline'、'x86-64-v2'、'x86-64-v3'、'x86-64-v4'：指定`.note.gnu.property`段中所需的x86-64 ISA级别。`x86-64-baseline`生成`GNU_PROPERTY_X86_ISA_1_BASELINE`。`x86-64-v2`生成`GNU_PROPERTY_X86_ISA_1_V2`。`x86-64-v3`生成`GNU_PROPERTY_X86_ISA_1_V3`。`x86-64-v4`生成`GNU_PROPERTY_X86_ISA_1_V4`。支持Linux/i386和Linux/x86_64。
- 'isa-level-report=none'、'isa-level-report=all'、'isa-level-report=needed'、'isa-level-report=used'：指定如何在输入可重定位文件中报告x86-64 ISA级别。`isa-level-report=none`，这是默认值，将使链接器不在输入文件中报告x86-64 ISA级别。`isa-level-report=all`将在输入文件中生成所需和使用的x86-64 ISA级别的链接器报告。`isa-level-report=needed`将使链接器报告输入文件中所需的x86-64 ISA级别。`isa-level-report=used`将使链接器报告输入文件中使用的x86-64 ISA级别。支持Linux/i386和Linux/x86_64。
为了Solaris兼容性，忽略其他关键字。

#### -(archives-)、--start-group archives --end-group

档案应该是存档文件的列表。它们可以是显式文件名，也可以是‘-l’选项。

重复搜索指定的归档，直到没有创建新的未定义引用。通常，归档文件只按照命令行中指定的顺序搜索一次。如果需要该存档中的符号来解析由稍后出现在命令行上的存档中的对象引用的未定义符号，则链接器将无法解析该引用。通过对档案进行分组，它们将被反复搜索，直到所有可能的参考文献都被解决。

使用此选项会带来很大的性能成本。最好只在两个或多个档案之间存在不可避免的循环引用时使用它。

#### --accept-unknown-input-arch、--no-accept-unknown-input-arch

告诉链接器接受架构无法识别的输入文件。假设用户知道他们在做什么，并且故意想要链接这些未知的输入文件。在2.14版本之前，这是链接器的默认行为。从2.14版本开始的默认行为是拒绝这样的输入文件，因此添加了‘--accept-unknown-input-arch ’选项来恢复旧的行为。

#### --as-needed、--no-as-needed

这个选项影响命令行--as-needed选项之后提到的动态库的`ELF DT_NEEDED`标记。通常，链接器会为命令行中提到的每个动态库添加`DT_NEEDED`标记，而不管该库是否实际需要。`--as-needed`导致`DT_NEEDED`标记仅在链接中满足常规对象文件中非弱未定义符号引用的库时才被触发，或者，如果在其他所需库的`DT_NEEDED`列表中没有找到该库，则从其他所需动态库中找到非弱未定义符号引用。在相关库之后出现在命令行上的目标文件或库不会影响是否需要该库。这类似于从归档中提取目标文件的规则。`--no-as-needed`恢复默认行为。

注意：在基于Linux的系统上，`--as-needed`选项也会影响`--rpath`和`--rpath-link`选项的行为。

#### --add-needed、--no-add-needed

这两个选项已被弃用，因为它们的名称与`--as-needed`和`--no-as-needed`选项相似。它们已被`--copy-dt-needed-entries`和`--no-copy-dt-needed-entries`所取代。

#### -assert keyword

对于SunOS兼容性，此选项将被忽略。

#### -Bdynamic、-dy、-call_shared

链接到动态库。这只有在支持共享库的平台上才有意义。此选项通常是此类平台上的默认选项。该选项的不同变体是为了与各种系统兼容。您可以在命令行中多次使用此选项：它会影响库搜索它后面的-l选项。

#### -Bgroup

在动态部分的`DT_FLAGS_1`表项中设置`DF_1_GROUP`标志。这将导致运行时链接器仅在组内执行此对象及其依赖项中的查找。`--unresolved-symbols=report-all`是隐含的。这个选项只有在支持共享库的ELF平台上才有意义。

#### -Bstatic、-dn、-non_shared、-static

不要链接到共享库。这只有在支持共享库的平台上才有意义。该选项的不同变体是为了与各种系统兼容。您可以在命令行中多次使用此选项：它会影响库搜索它后面的-l选项。该选项还意味着`--unresolved-symbols=report-all`。此选项可与`-shared`一起使用。这样做意味着正在创建共享库，但必须通过从静态库中拉入条目来解析库的所有外部引用。

#### -Bsymbolic

创建共享库时，将对全局符号的引用绑定到共享库中的定义（如果有的话）。通常，链接到共享库的程序有可能覆盖共享库中的定义。这个选项只有在支持共享库的ELF平台上才有意义。

#### -Bsymbolic-functions

创建共享库时，将对全局函数符号的引用绑定到共享库中的定义（如果有的话）。这个选项只有在支持共享库的ELF平台上才有意义。

#### -Bno-symbolic

此选项可以取消先前指定的‘-Bsymbolic’和‘-Bsymbolic-functions’。

#### --dynamic-list=dynamic-list-file

为链接器指定动态列表文件的名称。这通常用于创建共享库来指定一个全局符号列表，这些符号的引用不应该绑定到共享库中的定义，或者创建动态链接的可执行文件来指定一个应该添加到可执行文件中的符号表的符号列表。这个选项只有在支持共享库的ELF平台上才有意义。

#### --dynamic-list-data

将所有全局数据符号包含到动态列表中。

#### --dynamic-list-cpp-new

为c++操作符new和delete提供内置动态列表。它主要用于构建共享的libstdc++。

#### --dynamic-list-cpp-typeinfo

为c++运行时类型标识提供内置动态列表。

#### --check-sections、--no-check-sections

要求链接器在分配段地址后不要检查它们是否有任何重叠。通常，链接器将执行此检查，如果发现任何重叠，它将生成适当的错误消息。链接器不知道，也不考虑覆盖层中的部分。可以通过使用命令行开关`--check-sections`来恢复默认行为。对于可重定位的链接，通常不检查区段重叠。在这种情况下，你可以使用`--check-sections`选项强制检查。

#### --copy-dt-needed-entries、--no-copy-dt-needed-entries

这个选项影响命令行中提到的ELF动态库中`DT_NEEDED`标记所引用的动态库的处理。通常，链接器不会为输入动态库中的`DT_NEEDED`标记中提到的每个库的输出二进制文件添加`DT_NEEDED`标记。然而，在命令行上指定`--copy-dt-needed-entries`后，任何跟随它的动态库都将添加它们的`DT_NEEDED`项。可以使用`--no-copy-dt-needed-entries`恢复默认行为。

此选项还对动态库中符号的分辨率有影响。使用`--copy-dt-needed-entries`命令行中提到的动态库将被递归搜索，在它们的`DT_NEEDED`标记之后搜索到其他库，以便解析输出二进制文件所需的符号。然而，在默认设置下，搜索紧随其后的动态库将停止搜索动态库本身。不会遍历`DT_NEEDED`链接来解析符号。

#### --cref

输出一个交叉引用表。如果正在生成链接器映射文件，则将交叉引用表打印到映射文件中。否则，它将被打印在标准输出上。

表的格式故意很简单，以便在必要时可以很容易地被脚本处理。符号被打印出来，按名称排序。对于每个符号，给出一个文件名列表。如果定义了符号，列出的第一个文件是定义的位置。如果符号被定义为一个公共值，那么接下来出现这种情况的任何文件都会出现。最后列出引用该符号的所有文件。

#### --ctf-variables、--no-ctf-variables

CTF debuginfo格式支持一个部分，该部分对程序中发现的变量的名称和类型进行编码，这些变量不会出现在任何符号表中。这些变量显然不能被传统的调试器通过地址查找，因此用于它们的类型和名称的空间通常是浪费的：类型通常很小，但名称通常很小。`--ctf-variables`导致生成这样一个节。可以使用`--no-ctf-variables`恢复默认行为。

#### --ctf-share-types=method

调整CTF中翻译单元之间共享类型的方法。

“share-unconflicted”：将所有没有模糊定义的类型放入共享字典中，以便调试器可以轻松访问它们，即使它们只出现在一个翻译单元中。这是默认值。

“share-duplicated”：只将出现在多个翻译单元中的类型放入共享字典中：只有一个定义的类型放入每个翻译单元的字典中。在多个翻译单元中定义不明确的类型总是进入每个翻译单元的字典。这往往会使CTF变大，但可能会减少共享字典中的CTF数量。对于非常大的项目，这可能会加快打开CTF的速度，并在运行时节省CTF消费者的内存。

#### --no-define-common

此选项禁止将地址分配给通用符号。脚本命令`INHIBIT_COMMON_ALLOCATION`具有相同的效果。请参见其他链接器脚本命令。

‘--no-define-common’选项允许将给Common符号分配地址的决定与输出文件类型的选择分离；否则，不可重定位的输出类型强制为通用符号分配地址。使用‘--no-define-common’允许从共享库引用的Common符号仅在主程序中被分配地址。这消除了共享库中未使用的重复空间，并且当有许多动态模块具有用于运行时符号解析的专用搜索路径时，还可以防止解析到错误的重复时出现任何可能的混乱。

#### --force-group-allocation

该选项使链接器像普通输入节一样放置节组成员，并删除节组。这是最终链接的默认行为，但此选项可用于更改可重定位链接（'-r'）的行为。脚本命令`FORCE_GROUP_ALLOCATION`具有相同的效果。请参见其他链接器脚本命令。

#### --defsym=symbol=expression

在输出文件中创建一个全局符号，包含表达式给出的绝对地址。您可以根据需要多次使用此选项，以便在命令行中定义多个符号。在这种情况下，表达式支持有限形式的算术：您可以给出十六进制常量或现有符号的名称，或者使用+和-来添加或减去十六进制常量或符号。如果需要更精细的表达式，请考虑在脚本中使用链接器命令语言。注意：符号、等号（"="）和表达式之间不应有空白。

链接器按顺序处理‘--defsym’参数和‘-T’参数，在‘-T’之前放置‘--defsym’将在处理‘-T’中的链接器脚本之前定义符号，而在‘-T’之后放置‘--defsym’将在处理链接器脚本之后定义符号。这种差异对使用‘--defsym’符号的链接器脚本中的表达式有影响，正确的顺序取决于您想要实现的目标。

#### --demangle[=style]、--no-demangle

这些选项控制是否在错误消息和其他输出中更改符号名称。当链接器被告知进行转换时，它会尝试以一种可读的方式呈现符号名：如果它们被目标文件格式使用，它会去掉前导下划线，并将c++转换为用户可读的符号名。不同的编译器有不同的混杂风格。可选的demangling style参数可用于为编译器选择适当的demangling样式。除非设置了环境变量‘COLLECT_NO_DEMANGLE’，否则链接器将默认进行demangle。这些选项可用于覆盖默认值。

#### -Ifile、--dynamic-linker=file

设置动态链接器的名称。这只有在生成动态链接的ELF可执行文件时才有意义。默认的动态链接器通常是正确的；不要使用这个，除非你知道你在做什么。

#### --no-dynamic-linker

在生成可执行文件时，省略在加载时使用的动态链接器的请求。这只对包含动态重定位的ELF可执行文件有意义，并且通常需要能够处理这些重定位的入口点代码。

#### --embedded-relocs

这个选项类似于--emit-relocs选项，不同之处在于这些relocs存储在特定于目标的部分中。该选项仅由‘BFIN’， ‘CR16’和M68K目标支持。

#### --disable-multiple-abs-defs

不允许使用`-R`或`-just-symbols`调用包含在文件名中的符号的多个定义

#### --fatal-warnings、--no-fatal-warnings

将所有警告视为错误。可以使用选项--no-fatal-warnings恢复默认行为。

#### -w、--no-warnings

不要显示任何警告或错误消息。这将覆盖致命警告。当知道输出二进制文件不能工作，但仍然需要创建它时，可以使用此选项。

#### --force-exe-suffix

确保输出文件具有.exe后缀。

如果成功构建的完全链接输出文件没有.exe或.dll后缀，则此选项强制链接器将输出文件复制到具有.exe后缀的相同名称之一。当在Microsoft Windows主机上使用未修改的Unix makefile时，此选项很有用，因为某些版本的Windows不会运行映像，除非它以.exe后缀结尾。

#### --gc-sections、--no-gc-sections

启用未使用输入段的垃圾收集。对于不支持此选项的目标，将忽略此选项。可以通过在命令行上指定‘--no-gc-sections’来恢复默认行为（不执行此垃圾收集）。请注意，支持COFF和PE格式目标的垃圾收集，但目前认为其实现是实验性的。

“--gc-sections”通过检查符号和重定位来决定使用哪些输入段。包含条目符号的部分和所有包含命令行未定义符号的部分将被保留，包含动态对象引用的符号的部分也将被保留。请注意，在构建共享库时，链接器必须假定引用了任何可见符号。一旦确定了这组初始节，链接器就会递归地将重定位所引用的任何节标记为已使用。

此选项可以在进行部分链接时设置（使用选项‘-r’启用）。在这种情况下，必须通过“--entry”、“--undefined”或“--gc-keep-exported”选项之一或通过链接器脚本中的entry命令显式指定保留的符号的根目录。

作为一个GNU扩展，带有`SHF_GNU_RETAIN`标志的ELF输入段将不会被垃圾收集。

#### --print-gc-sections、--no-print-gc-sections

列出垃圾收集所删除的所有节。清单以stderr打印。此选项仅在通过‘--gc-sections’)选项启用垃圾收集时有效。可以通过在命令行上指定‘--no-print-gc-sections’来恢复默认行为（不列出被删除的部分）。

#### --gc-keep-exported

当启用“--gc-sections”时，此选项可防止对包含具有默认可见性或受保护可见性的全局符号的未使用输入段进行垃圾收集。此选项旨在用于可执行文件，否则无论所包含符号的外部可见性如何，未引用的部分都将被垃圾收集。注意，这个选项在链接共享对象时不起作用，因为它已经是默认行为。此选项仅支持ELF格式目标。

#### --print-output-format

输出默认输出格式的名称（可能受到其他命令行选项的影响）。这是将出现在`OUTPUT_FORMAT`链接器脚本命令中的字符串

#### --print-memory-usage

打印使用memory Command命令创建的内存区域的已用大小、总大小和已用大小。这对于嵌入式目标非常有用，可以快速查看空闲内存量。输出的格式有一个标题，每个区域有一行。它是人类可读的，也很容易被工具解析。下面是一个输出示例：

```
Memory region         Used Size  Region Size  %age Used
             ROM:        256 KB         1 MB     25.00%
             RAM:          32 B         2 GB      0.00%
```

#### --help

#### --target-help

#### -Map=mapfile

将链接映射打印到文件mapfile。请参阅上面-M选项的说明。如果mapfile只是字符-那么映射将被写入标准输出。

将目录指定为mapfile将导致将链接器映射作为目录内的文件写入。通常，目录中文件的名称是作为附加.map的输出文件的基本名称计算的。但是，如果使用了特殊字符%，那么它将被输出文件的完整路径所替换。此外，如果%符号后面有任何字符，则.map将不再追加。

#### --no-keep-memory

ld通常通过在内存中缓存输入文件的符号表来优化内存使用速度。这个选项告诉ld根据需要重新读取符号表来优化内存使用。如果ld在链接大型可执行文件时耗尽了内存空间，则可能需要这样做。

#### --no-undefined、-z defs

报告常规对象文件中未解析的符号引用。即使链接器正在创建非符号共享库，也会执行此操作。开关--[no-]allow-shlib-undefined控制报告在链接的共享库中发现的未解析引用的行为。

这个选项的效果可以通过使用-z undefs来恢复。

#### --allow-multiple-definition、-z muldefs

通常，当一个符号被定义多次时，链接器将报告一个致命错误。这些选项允许多个定义，第一个定义将被使用。

#### --allow-shlib-undefined、--no-allow-shlib-undefined

允许或禁止共享库中未定义的符号。这个开关类似于——no-undefined，除了它决定未定义符号在共享库中而不是在常规对象文件中时的行为。它不影响如何处理常规目标文件中的未定义符号。

默认行为是，如果使用链接器创建可执行文件，则报告共享库中引用的任何未定义符号的错误，但如果使用链接器创建共享库，则允许错误发生。

允许在链接时指定的共享库中未定义的符号引用的原因是：
- 在链接时指定的共享库可能与加载时可用的共享库不同，因此该符号实际上可能在加载时是可解析的。
- 有一些操作系统，例如BeOS和HPPA，共享库中未定义的符号是正常的。
例如，BeOS内核在加载时修补共享库，以选择最适合当前体系结构的函数。例如，它被用来动态地选择一个适当的memset函数。

#### --error-handling-script=scriptname

如果提供了这个选项，那么每当遇到错误时，链接器将调用scriptname。然而，目前只支持两种错误：缺失符号和缺失库。两个参数将被传递给script：关键字“ undefined-symbol ”或“ missing-lib ”和未定义符号或缺失库的名称。其目的是脚本将向用户提供关于在哪里可以找到符号或库的建议。脚本完成后，将显示正常的链接器错误信息。

此选项的可用性由配置时间开关控制，因此在特定实现中可能不存在。

#### --no-undefined-version

通常，当符号的版本未定义时，链接器将忽略它。此选项禁止使用版本未定义的符号，并将发出致命错误。

#### --default-symver

为未版本化的导出符号创建并使用默认符号版本（soname）。

#### --default-imported-symver

为未版本化的导入符号创建并使用默认符号版本（soname）。

#### --no-warn-mismatch

通常，如果您试图将由于某种原因而不匹配的输入文件链接在一起，可能是因为它们是为不同的处理器或不同的字节序编译的，那么ld将给出一个错误。这个选项告诉ld它应该静默地允许这种可能的错误。只有在采取了某些特殊操作以确保链接器错误不适当的情况下，才应谨慎使用此选项。

#### --no-warn-search-mismatch

通常，如果在库搜索过程中发现不兼容的库，ld将给出警告。此选项使警告静音。

#### --no-whole-archive

关闭--whole-archive选项对后续归档文件的影响。

#### --noinhibit-exec

保留可执行输出文件，只要它仍然可用。通常，如果链接器在链接过程中遇到错误，它将不会产生输出文件；当它发出任何错误时，它退出而不写入输出文件。

#### -nostdlib

只搜索命令行上明确指定的库目录。在链接器脚本中指定的库目录（包括在命令行上指定的链接器脚本）将被忽略。

#### --oformat=output-format

ld可以配置为支持一种以上的目标文件。如果您的ld是以这种方式配置的，您可以使用‘——oformat ’选项来指定输出对象文件的二进制格式。即使将ld配置为支持其他对象格式，您通常也不需要指定它，因为应该将ld配置为在每台机器上生成最常用的格式作为默认输出格式。output-format是一个文本字符串，BFD库支持的特定格式的名称。（您可以使用‘ objdump -i ’列出可用的二进制格式。）脚本命令OUTPUT_FORMAT也可以指定输出格式，但是这个选项会覆盖它。

#### --out-implib file

在文件中创建一个与链接器生成的可执行文件相对应的导入库。DLL或ELF程序)。这个导入库（应该被称为`*.dll`）`.a`或`*.a`（对于dll）可以用来将客户端链接到生成的可执行文件；这种行为使得可以跳过单独的导入库创建步骤(例如。dll工具)。此选项仅适用于连接器的i386 PE和ELF目标端口。

#### -pie、--pic-executable

创建一个独立于位置的可执行文件。目前仅在ELF平台上支持此功能。位置无关的可执行文件由动态链接器重新定位到操作系统为它们选择的虚拟地址，该地址在不同的调用之间可能不同。它们在ELF文件头中被标记为ET_DYN，但在许多方面与共享库不同。特别是，PIE中定义的符号默认情况下不能被另一个对象覆盖，因为它们可以在共享库中覆盖。

#### -no-pie

创建一个与位置相关的可执行文件。这是默认值

#### -qmagic

为了Linux兼容性，忽略此选项。

#### -Qy

为了兼容性，SVR4忽略此选项

#### --relax、--no-relax

具有机器依赖效果的选项。此选项仅在少数目标上支持。参见ld和H8/300。参见ld和Xtensa处理器。参见ld和68HC11和68HC12。参见ld和PowerPC 32位ELF支持。

在某些平台上，--relax选项执行特定于目标的全局优化，当链接器在程序中解析寻址时，这些优化成为可能，例如放松寻址模式、合成新指令、选择当前指令的较短版本以及组合常量值。

在某些平台上，这些链接时全局优化可能会导致无法对结果可执行文件进行符号调试。这是已知的松下MN10200和MN10300系列处理器的情况。

在支持该功能的平台上，选项--no-relax将禁用该功能。

在不支持该功能的平台上，二者都可以设置，但会被忽略。

#### --retain-symbols-file=filename

仅保留文件文件名中列出的符号，丢弃所有其他符号。文件名只是一个平面文件，每行有一个符号名。此选项在逐渐累积大型全局符号表以节省运行时内存的环境（如VxWorks）中特别有用。

‘--retain-symbols-file’不会丢弃未定义的符号或重定位所需的符号。

你只能在命令行中指定一次‘--retain-symbols-file ’。它覆盖了‘-s’和‘-S’。

#### -rpath=dir

在运行时库搜索路径中添加一个目录。这在将ELF可执行文件与共享对象链接时使用。所有-rpath参数都被连接并传递给运行时链接器，运行时链接器使用它们在运行时定位共享对象。

-rpath选项也用于定位链接中显式包含的共享对象所需的共享对象；请参见-path-link选项的说明。只有配置了--with-sysroot选项的本地链接器和交叉链接器才支持以这种方式搜索-rpath。

如果在链接一个ELF可执行文件时没有使用-rpath，那么如果定义了环境变量LD_RUN_PATH，将使用它的内容。

-rpath选项也可以在SunOS上使用。默认情况下，在SunOS上，链接器将从给出的所有-L选项中形成一个运行时搜索路径。如果使用-rpath选项，运行时搜索路径将只使用-rpath选项，忽略-L选项。这在使用gcc时非常有用，因为gcc会添加许多-L选项，这些选项可能位于NFS挂载的文件系统上。

为了与其他ELF链接器兼容，如果-R选项后面跟着目录名，而不是文件名，则将其视为-rpath选项。

#### -rpath-link=dir

rpath-link选项指定要搜索的第一组目录。此选项可以通过提供以冒号分隔的名称列表或多次出现来指定目录名序列。

#### --section-ordering-file=script

此选项用于使用输入节到输出节的额外映射来扩展当前链接器脚本。该文件必须使用与普通链接器脚本相同的SECTIONS语法，但除了将输入节放入输出节之外，它不应该做任何事情。参见章节命令

节排序脚本的第二个约束是，它只能引用当前使用的链接器脚本已经定义的输出节。（即默认的链接器脚本或命令行上指定的脚本）。然而，片段排序脚本的好处是，输入部分被映射到输出部分的开始部分，因此它们可以确保输出部分中各部分的顺序。例如，假设默认的链接器脚本是这样的：
```
SECTIONS {
  .text : { *(.text.hot) ; *(.text .text.*) }
  .data : { *(.data.big) ; *(.data .data.*) }
}
```
然后如果使用像这样的节排序文件：
```
.text : { *(.text.first) ; *(.text.z*) }
.data : { foo.o(.data.first) ; *(.data.small) }
```
这相当于这样的链接器脚本：
```
SECTIONS {
  .text : { *(.text.first) ; *(.text.z*) ; *(.text.hot) ; *(.text .text.*) }
  .data : { foo.o(.data.first) ; *(.data.small) ; *(.data.big) ; *(.data .data.*) }
}
```

节排序文件的优点是，它可以用来对那些对用户重要的节进行排序，而不必担心任何其他节、内存区域或其他任何东西。

#### -shared、-Bshareable

创建共享库。目前只支持ELF、XCOFF和SunOS平台。在SunOS上，如果没有使用-e选项，并且链接中有未定义的符号，那么链接器将自动创建一个共享库。

#### --sort-common、--sort-common=ascending、--sort-common=descending

该选项告诉ld在将通用符号放入适当的输出部分时，按升序或降序排列对它们进行排序。所考虑的符号对齐是16字节或更大、8字节、4字节、2字节和1字节。这是为了防止由于对齐约束而导致符号之间的间隙。如果没有指定排序顺序，则假定降序。

#### --sort-section=name

该选项将对链接器脚本中的所有通配符部分模式应用`SORT_BY_NAME`。

#### --sort-section=alignment

该选项将对链接器脚本中的所有通配符部分模式应用SORT_BY_ALIGNMENT。

#### --spare-dynamic-tags=count

这个选项指定在ELF共享对象的.dynamic部分中留下的空槽的数量。后处理工具（如预链接器）可能需要空槽。默认值是5。

#### --split-by-file[=size]

类似于--split-by-reloc，但在达到大小时为每个输入文件创建一个新的输出部分。如果没有指定，Size默认为1。

#### --split-by-reloc[=count]

尝试在输出文件中创建额外的部分，以便文件中的单个输出部分不包含超过计数的重定位。这在使用COFF对象文件格式生成巨大的可重定位文件以下载到某些实时内核时非常有用；因为COFF不能在一个section中表示超过65535的重定位。注意，对于不支持任意节的对象文件格式，这将无法工作。链接器不会拆分单独的输入段进行重新分配，所以如果一个输入段包含超过计数的重定位，那么一个输出段将包含相同数量的重定位。Count默认值为32768。


#### --stats

计算并显示有关链接器操作的统计信息，例如执行时间和内存使用情况。

#### --sysroot=directory

使用directory作为sysroot的位置，覆盖配置时间的默认值。该选项仅被使用--with-sysroot配置的链接器支持。

#### --task-link

基于COFF/PE的目标使用它来创建一个任务链接的对象文件，其中所有全局符号都已转换为静态值。

#### --traditional-format

对于某些目标，ld的输出在某些方面与某些现有链接器的输出不同。此开关要求ld使用传统格式。

例如，在SunOS上，ld组合符号字符串表中的重复条目。这可以将包含完整调试信息的输出文件的大小减少30%以上。不幸的是，SunOS dbx程序不能读取生成的程序（gdb没有问题）。‘--tradition-format’开关告诉ld不要合并重复的条目。

#### --section-start=sectionname=org

在输出文件中找到org给出的绝对地址处的一个节。您可以根据需要多次使用此选项来定位命令行中的多个部分。Org必须是一个十六进制整数；为了与其他链接器兼容，您可以省略通常与十六进制值相关联的前导‘ 0x ’。注意：sectionname、等号（"="）和org之间不应该有空格。

#### --image-base=org

当使用ELF时与-text-segment相同，两个选项都有效地设置ELF可执行文件的基址。

当使用PE时，使用value作为程序或dll的基址。这是加载程序或dll时将使用的最低内存位置。为了减少重新定位的需要并提高dll的性能，每个dll都应该有一个唯一的基址，并且不与任何其他dll重叠。可执行文件的默认值是0x400000，而dll的默认值是0x10000000。

#### -Tbss=org、-Tdata=org、-Ttext=org

与`--section-start`相同，使用`.bss`、`.data`或`.text`作为节名。

#### -Ttext-segment=org

当创建一个ELF可执行文件时，它将设置第一个段的第一个字节的地址。请注意，当`-pie`与`-text-segment=org`一起使用时，输出的可执行文件被标记为`ET_EXEC`，以便在运行时保证文本段的第一个字节的地址为org。

#### -Trodata-segment=org

当为只读数据位于与可执行文本分开的自己的段中的目标创建ELF可执行对象或共享对象时，它将设置只读数据段的第一个字节的地址。

#### -Tldata-segment=org

在为x86-64介质内存模型创建ELF可执行对象或共享对象时，它将设置ldata段的第一个字节的地址。

#### --unresolved-symbols=method

确定如何处理未解析的符号。‘method’有四种可能的值：
- 'ignore-all': 不要报告任何未解析的符号。
- 'report-all': 报告所有未解析的符号。这是默认值。
- 'ignore-in-object-files': 报告共享库中包含的未解析符号，但如果它们来自常规对象文件，则忽略它们。
- 'ignore-in-shared-libs': 报告来自常规对象文件的未解析符号，但如果它们来自共享库则忽略它们。这在创建动态二进制文件时非常有用，并且已知它应该引用的所有共享库都包含在链接器的命令行中。

共享库本身的行为也可以通过——[no-]allow-shlib-undefined选项来控制。

通常，链接器将为每个报告的未解析符号生成一条错误消息，但选项--warn-unresolved-symbols可以将其更改为警告。

#### --dll-verbose、--verbose[=NUMBER]

显示ld的版本号并列出支持的链接器模拟。显示哪些输入文件可以打开，哪些不能打开。显示链接器正在使用的链接器脚本。如果可选的NUMBER参数> 1，插件符号状态也将显示。

#### --version-script=version-scriptfile

为链接器指定版本脚本的名称。这通常在创建共享库时使用，以指定正在创建的库的版本层次结构的附加信息。此选项仅在支持共享库的ELF平台上得到完全支持；请参见版本命令。它在PE平台上得到部分支持，PE平台可以使用版本脚本在自动导出模式下过滤符号可见性：版本脚本中标记为“local”的任何符号都不会被导出。参见ld和WIN32 （cygwin/mingw）。

#### --warn-common

当一个通用符号与另一个通用符号或符号定义组合时发出警告。Unix链接器允许这种有点草率的做法，但其他一些操作系统上的链接器不允许。此选项允许您从组合全局符号中查找潜在的问题。不幸的是，一些C库使用这种做法，因此您可能会在库中以及您的程序中得到一些关于符号的警告。

#### --warn-constructors

如果使用了任何全局构造函数，则发出警告。这只对少数目标文件格式有用。对于像COFF或ELF这样的格式，链接器无法检测到全局构造函数的使用。

#### --warn-execstack、--warn-execstack-objects、--no-warn-execstack

在ELF平台上，如果要求链接器创建包含可执行堆栈的输出文件，它可能会生成警告消息。有三种可能的状态：
1. 不要产生任何警告。
2. 始终生成警告，即使通过-z execstack命令行选项请求可执行堆栈。
3. 仅当目标文件请求可执行堆栈时生成警告，但如果使用-z execstack选项则不会生成警告。

默认状态取决于构建链接器时如何配置它。`--no-warn-execstack`选项总是将链接器置于无警告状态。`--warn-execstack`选项将链接器置于“始终警告”状态。`--warn-execstack-objects`选项将链接器置于仅对object-files发出警告的状态。

注意：ELF格式的输入文件可以通过使用. Note来指定它们需要一个可执行堆栈。在其节标志中设置可执行位的GNU-stack节。它们可以通过具有相同的节来指定它们不需要可执行堆栈，但不设置可执行标志位。如果输入文件没有.note。则默认行为是特定于目标的。对于某些目标，缺少这样一个部分意味着需要一个可执行堆栈。对于手工制作的汇编文件来说，这通常是一个问题。

#### --error-execstack、--no-error-execstack

如果链接器要生成关于可执行堆栈的警告消息，那么--error-execstack选项将把该警告更改为错误。注意-此选项不会更改链接器的execstack警告生成状态。使用--warn-execstack或--warn-execstack-objects来设置特定的警告状态。
--no-error-execstack选项将恢复生成警告消息的默认行为。

#### --warn-multiple-gp

如果输出文件中需要多个全局指针值，则发出警告。这只对某些处理器有意义，比如Alpha。具体来说，有些处理器将大值常量放在一个特殊的部分中。一个特殊的寄存器（全局指针）指向这一节的中间，因此可以通过基寄存器相对寻址模式有效地加载常量。由于基寄存器相对模式的偏移量是固定的并且相对较小（例如，16位），这限制了常量池的最大大小。因此，在大型程序中，为了能够寻址所有可能的常量，通常需要使用多个全局指针值。此选项会在发生这种情况时发出警告。

#### --warn-once

只对每个未定义的符号发出一次警告，而不是对每个引用它的模块发出一次警告。

#### --warn-rwx-segments、--no-warn-rwx-segments

如果链接器创建了一个可加载的，非零大小的段，并且设置了所有三个读，写和执行权限标志，则发出警告。这样的段表示潜在的安全漏洞。此外，如果线程本地存储段创建时设置了执行权限标志，无论它是否设置了读和/或写标志，都将生成警告。

这些警告在默认情况下是启用的。可以通过--no-warn-rwx-segments选项禁用它们，并通过--warn-rwx-segments选项重新启用它们。

#### --error-rwx-segments、--no-error-rwx-segments

如果链接器要生成关于可执行、可写段或可执行TLS段的警告消息，那么--error-rwx-segments选项将把此警告转换为错误。--no-error-rwx-segments选项将恢复仅生成警告消息的默认行为。

注意--error-rwx-segments选项本身不会打开关于这些段的警告。如果链接器是以这种方式配置的，这些警告要么默认启用，要么通过--warn-rwx-segments命令行选项启用。

#### --warn-section-align

如果输出部分的地址因对齐而更改，则发出警告。通常，对齐方式将由输入部分设置。地址只有在没有明确指定的情况下才会被更改；也就是说，如果SECTIONS命令没有指定节的起始地址

#### --warn-textrel

如果链接器将DT_TEXTREL添加到位置无关的可执行或共享对象中，则发出警告。

#### --warn-alternate-em

如果对象有备用ELF机器码，则发出警告。

#### --warn-unresolved-symbols

如果链接器要报告一个未解析的符号（参见选项--unresolved-symbols），它通常会生成一个错误。这个选项使它生成一个警告。

#### --error-unresolved-symbols

这将恢复链接器在报告无法解析的符号时生成错误的默认行为。

#### --whole-archive

对于命令行中`--whole-archive`选项之后提到的每个归档，在链接中包括归档中的每个对象文件，而不是在归档中搜索所需的对象文件。这通常用于将归档文件转换为共享库，迫使每个对象都包含在生成的共享库中。此选项可以多次使用。

在gcc中使用这个选项时需要注意两点：首先，gcc不知道这个选项，所以你必须使用`-Wl,-whole-archive`。其次，不要忘记在存档列表后面使用`-Wl,-no-whole-archive`，因为gcc会将自己的存档列表添加到您的链接中，您可能不希望这个标志也影响到这些。

#### --wrap=symbol

对symbol使用包装器函数。任何对symbol的未定义引用将被解析为`__wrap_symbol`。任何对`__real_symbol`的未定义引用将被解析为symbol。

这可用于为系统功能提供包装器。包装器函数应该命名为`__wrap_symbol`。如果它希望调用系统函数，它应该调用`__real_symbol`。

这里有一个简单的例子：
```C
void *
__wrap_malloc (size_t c)
{
  printf ("malloc called with %zu\n", c);
  return __real_malloc (c);
}
```

如果使用`--wrap malloc`将其他代码与该文件链接，那么所有对malloc的调用将调用函数`__wrap_malloc`。对`__wrap_malloc`中的`__real_malloc`的调用将调用真正的malloc函数。

您可能还希望提供`__real_malloc`函数，以便没有`--wrap`选项的链接将成功。如果你这样做，你不应该把`__real_malloc`的定义和`__wrap_malloc`放在同一个文件中；如果这样做，汇编程序可能会在链接器有机会将调用包装为malloc之前解析调用。

只有未定义的引用才会被链接器替换。因此，对symbol的翻译单元内部引用不会解析为`__wrap_symbol`。在下一个示例中，对f在g中的调用不会解析为`__wrap_f`。

```
int
f (void)
{
  return 123;
}

int
g (void)
{
  return f();
}
```

#### --eh-frame-hdr、--no-eh-frame-hdr

请求（--eh-frame-hdr）或抑制（--no-eh-frame-hdr）创建`.eh_frame_hdr`段和ELF `PT_GNU_EH_FRAME`段头。

#### --no-ld-generated-unwind-info

请求为链接器生成的代码段（如PLT）创建`.eh_frame` unwind信息。如果支持链接器生成的unwind信息，则默认开启此选项。此选项还控制链接器生成的代码段（如PLT）的.sframe堆栈跟踪信息的生成。

#### --enable-new-dtags、--disable-new-dtags

这个链接器可以在ELF中创建新的动态标签。但是旧的极低频系统可能无法理解它们。如果指定`--enable-new-dtags`，将根据需要创建新的动态标记，而旧的动态标记将被省略。如果指定`--disable-new-dtags`，则不会创建新的动态标签。缺省情况下，不创建新的动态标记。请注意，这些选项仅适用于ELF系统。

#### --hash-size=number

将链接器哈希表的默认大小设置为接近number的素数。增加此值可以减少链接器执行其任务所需的时间长度，但代价是增加链接器的内存需求。同样地，减少这个值可以以牺牲速度为代价来减少内存需求。

#### --hash-style=style

设置链接器哈希表的类型。style可以是sysv（代表经典ELF `.hash` section, gnu（代表新风格`.gnu.gnu`）。对于经典的ELF`.hash`和新风格的GNU `.GNU.hash`。默认值取决于链接器的配置方式，但对于大多数基于Linux的系统，它将两者都是。

#### --compress-debug-sections=none、--compress-debug-sections=zlib、--compress-debug-sections=zlib-gnu、--compress-debug-sections=zlib-gabi、--compress-debug-sections=zstd

在ELF平台上，这些选项控制如何使用zlib压缩DWARF调试段。

`--compress-debug-sections=none`不压缩DWARF调试段。`--compress-debug-sections=zlib-gnu`压缩DWARF调试段，并将其重命名为'.Zdebug ‘而不是’.debug '。`--compress-debug-sections=zlib-gabi`也压缩DWARF调试段，但它不会重命名它们，而是在节的头中设置`SHF_COMPRESSED`标志。

`--compress-debug-sections=zlib`选项是`--compress-debug-sections=zlib-gabi`的别名。

`--compress-debug-sections=zstd`使用zstd压缩DWARF调试段。

请注意，此选项将覆盖输入调试部分中的任何压缩，因此，如果使用`--compress-debug-sections=none`链接二进制文件，则在将输入文件中的任何压缩的调试部分复制到输出二进制文件之前，将对其进行解压缩。

默认的压缩行为取决于所涉及的目标和用于构建工具链的配置选项。可以通过检查链接器的——help选项的输出来确定默认值。

#### --reduce-memory-overheads

此选项以牺牲链接速度为代价，减少了旧运行时的内存需求。这是为了选择旧的O（n^2）算法来生成链接映射文件，而不是新的O(n)算法，它使用大约40%的内存用于符号存储。

切换的另一个效果是将默认哈希表大小设置为1021，这再次节省了内存，但代价是延长了链接器的运行时间。但是，如果使用了`--hash-size`开关，则不会这样做。

在未来版本的链接器中，还可以使用`--reduce-memory-overheads`开关来实现其他折衷。

#### --max-cache-size=size

ld通常将输入文件的重定位信息和符号表缓存到内存中，大小不限。此选项将最大缓存大小设置为size。

#### --build-id、--build-id=style

请求创建一个`.note.gnu.build-id`ELF注释节或`.buildid` COFF节。内容是唯一的比特来标识这个链接的文件。样式可以使用128个随机位；sha1使用160位sha1哈希，md5使用128位md5哈希，或者xx对输出内容的规范部分使用128位XXHASH；或0xhexstring使用指定为偶数十六进制数字的选定位字符串（忽略数字对之间的-和：字符）。如果省略style，则使用sha1。

md5、sha1和xx样式产生的标识符在相同的输出文件中总是相同的，但在所有不相同的输出文件中几乎肯定是唯一的。它不打算作为文件内容的校验和进行比较。链接的文件稍后可能会被其他工具更改，但标识原始链接文件的构建ID位字符串不会更改。

为style传递none将禁用命令行上先前的任何`--build-id`选项的设置。

#### --package-metadata=JSON

请求创建一个`.note.package` ELF注释部分。根据包元数据规范，注释的内容采用JSON格式。[参看：https://systemd.io/ELF_PACKAGE_METADATA/](https://systemd.io/ELF_PACKAGE_METADATA/)

### 其他平台命令行选项

[Options Specific to i386 PE Targets](https://sourceware.org/binutils/docs/ld/Options.html#Options-Specific-to-i386-PE-Targets)
[Options specific to C6X uClinux targets](https://sourceware.org/binutils/docs/ld/Options.html#Options-specific-to-C6X-uClinux-targets)
[Options specific to C-SKY targets](https://sourceware.org/binutils/docs/ld/Options.html#Options-specific-to-C_002dSKY-targets)
[Options specific to Motorola 68HC11 and 68HC12 targets](https://sourceware.org/binutils/docs/ld/Options.html#Options-specific-to-Motorola-68HC11-and-68HC12-targets)
[Options specific to Motorola 68K target](https://sourceware.org/binutils/docs/ld/Options.html#Options-specific-to-Motorola-68K-target)
[Options specific to MIPS targets](https://sourceware.org/binutils/docs/ld/Options.html#Options-specific-to-MIPS-targets)
[Options specific to PDP11 targets](https://sourceware.org/binutils/docs/ld/Options.html#Options-specific-to-PDP11-targets)

### i386 PE目标的特殊选项

#### --add-stdcall-alias
#### --base-file file
#### --dll
#### --enable-long-section-names
#### --disable-long-section-names
#### --enable-stdcall-fixup
#### --disable-stdcall-fixup
#### --leading-underscore、--no-leading-underscore
#### --export-all-symbols
#### --exclude-symbols symbol,symbol,...
#### --exclude-all-symbols
#### --file-alignment
#### --heap reserve、--heap reserve,commit
#### --kill-at
#### --large-address-aware
#### --disable-large-address-aware
#### --major-image-version value
#### --major-os-version value
#### --major-subsystem-version value
#### --minor-image-version value
#### --minor-os-version value
#### --minor-subsystem-version value
#### --output-def file
#### --enable-auto-image-base、--enable-auto-image-base=value
#### --disable-auto-image-base
#### --dll-search-prefix string
#### --enable-auto-import
#### --disable-auto-import
#### --enable-runtime-pseudo-reloc
#### --disable-runtime-pseudo-reloc
#### --enable-extra-pe-debug
#### --section-alignment
#### --stack reserve、--stack reserve,commit
#### --subsystem which、--subsystem which:major、--subsystem which:major.minor
#### --high-entropy-va、--disable-high-entropy-va
#### --dynamicbase、--disable-dynamicbase
#### --forceinteg、--disable-forceinteg
#### --nxcompat、--disable-nxcompat
#### --no-isolation、--disable-no-isolation
#### --no-seh、--disable-no-seh
#### --no-bind、--disable-no-bind
#### --wdmdriver、--disable-wdmdriver
#### --tsaware、--disable-tsaware
#### --insert-timestamp、--no-insert-timestamp
#### --enable-reloc-section、--disable-reloc-section

### 特定于C6X uClinux目标的选项

#### --dsbt-size size
#### --dsbt-index index

### 特定于C-SKY目标的选项
#### --branch-stub
#### --stub-group-size=N

### 特定于摩托罗拉68HC11和68HC12目标的选项

#### --no-trampoline
#### --bank-window name

### 特定于摩托罗拉68K目标的选项

#### --got=type

### 特定于MIPS目标的选项

#### --insn32、--no-insn32
#### --ignore-branch-isa、--no-ignore-branch-isa
#### --compact-branches、--no-compact-branches

### 特定于PDP11目标的选项

#### -N、--omagic
#### -n、--nmagic
#### -z、--imagic
#### --no-omagic
