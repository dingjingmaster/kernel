# 链接脚本

每次链接都由一个链接脚本控制。该脚本使用链接器命令语言编写。

链接脚本的主要目的是描述如何将输入文件中的各个部分映射到输出文件中，并控制输出文件的内存布局。大多数链接脚本都是如此，然而，在必要时，链接器脚本还可以使用下面描述的命令来指示链接器执行许多其他操作。

链接器总是使用链接器脚本。如果您自己不提供一个，链接器将使用编译到链接器可执行文件中的默认脚本。您可以使用“--verbose”命令行选项来显示默认的链接器脚本。某些命令行选项，例如“-r”或“-N”，将影响默认的链接器脚本。

您可以使用“-T”命令行选项提供自己的链接器脚本。当您这样做时，您的链接器脚本将替换默认的链接器脚本。

也可以通过将脚本作为链接器输入文件隐式的使用链接脚本：

## 链接器脚本基本概念

为了描述链接脚本语言，我们需要定义一些基本概念和词汇。

**链接器**将**输入文件**(一个或多个)合并为一个**输出文件**。**输出文件**和每个输入文件都采用一种特殊的数据格式，称为**目标文件格式**。每个文件称为**目标文件**。输出文件通常称为**可执行文件**，但出于我们的目的，我们也将其称为**目标文件**。每个目标文件都有一个段（section）列表。有时把输入文件的段称作**输入段**，类似的，输出文件的段称作**输出段**。

目标文件中的每个段都有名称和大小。大多数段还具有关联的数据块，称为**段内容**。一个段可能被标记为**可加载**(loadable)，这意味着在运行输出文件时，段内容需要先加载到内存中。一个没有内容的段意味着需要在内存中预留相应的空间，但是这里不需要加载任何东西（在某些情况下，该内存必须初始化为0）。既不可装载也不可分配的部分通常包含某些调试信息。

每个可加载或预留空间的输出段都有两个地址。第一个是`VMA`或称为`虚拟内存地址`。这是运行输出文件时该段将具有的地址。第二个是`LMA`，即`加载内存地址`。这是段将会被加载的地址。在大多数情况下，这两个地址是相同的。当然它们也可能不同，比如：将数据段加载到ROM中，然后在程序启动时将其复制到RAM中（此技术通常用于初始化基于ROM的系统中的全局变量）。在这种情况下，ROM地址将是`LMA`，而RAM地址将是`VMA`。

您可以使用`objdump -h <目标文件>`来查看目标文件中的各个段。

每个目标文件还具有一个符号列表，称为**符号表**。符号可以是定义的也可以是未定义的。每个符号都有一个名称，每个定义的符号都有一个地址，以及其他信息。如果将C或C++程序编译到目标文件中，则将会将所有定义过的函数和全局变量以及静态变量作为已定义符号。输入文件中引用的每个未定义函数或全局变量都将成为未定义符号。

您可以使用`nm -t <目标文件>`来查看目标文件中的符号。

## 链接脚本的格式

链接脚本是文本文件。

一个链接器脚本是一系列的命令。每个命令都是一个关键字，可能后面还跟有一个参数，或者一个符号的赋值。使用分号分割命令，通常忽略空格。

类似于文件名或者格式名的字串可以直接输入。如果文件名含有一个字符例如逗号（逗号被用来分割文件名），你可以将文件名放在双引号内部。 但是禁止在文件名内使用双引号字符 。

你可以像C语言一样在链接脚本内包含注释，由’/’和’/’划分。和C一样，注释在句法上被当作空格。

## 一个简单的链接脚本示例

大多数的链接脚本非常简单。

最简单的链接脚本只有一个命令：’SECTIONS’。您可以使用’SECTIONS’命令来描述输出文件的内存布局。

’SECTIONS’命令功能非常强大。在这里，我们将描述它的一个简单用法。假设您的程序仅包含代码，初始化数据和未初始化数据。它们分别位于`.text`，`.data`和`.bss`段中。 我们进一步假设这些是唯一将会出现在输入文件中的段。

在此示例中，假设代码应在地址`0x10000`处加载，数据应从地址`0x8000000`开始。下面的链接脚本将会执行如下操作：
```
SECTIONS
{
  . = 0x10000;
  .text : { *(.text) }
  . = 0x8000000;
  .data : { *(.data) }
  .bss : { *(.bss) }
}
```

上例中`SECTIONS`指令中的第一行设置特殊符号 `.`的值，即**位置计数器**。如果未通过其他方式指定输出段的地址，地址就会被设置为位置计数器的当前值。然后将位置计数器增加输出段的大小。在`SECTIONS`命令的开头，位置计数器的值为`0`。

第二行定义了一个输出段`.text`。冒号是必需的语法，现在可以忽略它。在输出段名称后面的花括号中，列出应放置在此输出段中的输入段的名称。`*`是文件名匹配的通配符。表达式 `*(.text)` 表示所有输入文件中的所有`.text`输入段

由于在定义输出段`.text`时位置计数器为`0x10000`，因此链接程序会将输出文件中`.text`段的地址设置为`0x10000`。

剩下的行定义了输出文件中的`.data`和`.bss`段。链接器会将`.data`输出段放置在地址`0x8000000`处。在链接器放置`.data`段后，位置计数器为`0x8000000`加上`.data`段的大小。因此`.bss`输出段在内存中将会紧紧挨在`.data`段后面。

链接器将通过增加位置计数器来确保每个输出部分具有所需的对齐方式。在此示例中，`.text`和`.data`段的指定地址可以满足任何对齐方式约束，但链接器可能必须在`.data`和`.bss`段之间创建一个小的间隙。

如上，这就是一个简单完整的链接脚本。

## 简单链接脚本指令

### 设置入口点

在程序中执行的第一条指令称为入口点。使用`ENTRY`链接器脚本命令来设置入口点。其参数是一个符号名称：
```
ENTRY(symbol)
```

有几种设置入口点的方法。链接器将通过依次尝试以下每种方法来设置入口点，并在其中一种成功后停止：
- `-e`输入命令行选项；
- 链接器脚本中的`ENTRY(symbol)`命令；
- 目标专用符号值（如果已定义）； 对于许多目标来说是`start`符号，但是例如基于PE和BeOS的系统检查可能的输入符号列表，并与找到的第一个符号匹配。
- `.text`部段的第一个字节的地址（如果存在）；
- 地址0

### 文件处理指令

以下是链接器脚本处理文件的几个常用命令:

#### INCLUDE filename

在命令行中包含链接脚本文件 filename，将在当前目录以及 -L 选项指定的任何目录中搜索文件。INCLUDE 调用嵌套最多10个级别。

#### INPUT(file, file, …)或INPUT(file file …)

INPUT 命令指示链接程序在链接中包含指定的文件，就好像它们是在命令行上命名的一样。

例如，如果您始终希望在每次执行链接时都包含 subr.o，但又不想将其放在每个链接命令行中，则可以在链接脚本中放置 ‘INPUT(subr.o)’。

实际上，可以在链接描述文件中列出所有输入文件，然后仅用‘-T’选项调用链接脚本

如果配置了`sysroot`前缀，且文件名以`/`开头，并且正在处理的脚本位于`sysroot`前缀内，则将在`sysroot`前缀中查找文件名。也可以通过指定`=`作为文件名路径中的第一个字符，或在文件名路径前加上 `$SYSROOT` 来强制使用`sysroot` 前缀。

如果未使用`sysroot`前缀，则链接器将尝试打开包含链接器脚本的目录中的文件。如果没有找到，链接器将搜索当前目录。如果仍未找到，链接器将搜索库的搜索路径。

如果您使用‘INPUT(-lfile)’，则 ld 会将名称转换为 libfile.a，就像命令行参数‘-l ’一样

当您在隐式链接脚本中使用`INPUT`命令时，文件在链接脚本文件被包含的时刻才会被加入。这可能会影响库的搜索。

#### GROUP(file, file, …)、GROUP(file file …)

GROUP命令与INPUT类似，不同之处在于传入的文件都应该是归档文件，并且它们将被反复搜索，直到没有创建新的未定义引用。

#### AS_NEEDED(file, file, …)、AS_NEEDED(file file …)

此构造只能出现在`INPUT`或`GROUP`命令以及其他文件名中。命令中的文件将会以类似于直接出现在`INPUT`或`GROUP`命令中的文件一样处理，除了ELF共享库，ELF共享库仅在真正需要使用时才被添加。这个构造实质上为其中列出的所有文件启用了`-as-needed` 选项，为了恢复以前编译环境，之后需设置`--no-as-needed`。

#### OUTPUT(filename)

`OUTPUT`命令设置输出文件的文件名。在链接脚本中使用 `OUTPUT(filename)` 与在命令行中使用 `-o filename` 一样。 如果两者都使用，则命令行选项优先。
您可以使用 OUTPUT 命令为输出文件定义默认名称，以此替代默认名称a.out。

#### SEARCH_DIR(path)

`SEARCH_DIR`指令添加一个 ld 搜索库的路径。使用 `SEARCH_DIR(path)` 与在命令行上使用 `-L path` 完全一样。如果同时使用了这两条路径，那么链接器将会搜索所有路径。首先搜索使用命令行选项指定的路径。

#### STARTUP(filename)

`STARTUP`指令与`INPUT`指令类似，除了filename将成为要链接的第一个输入文件，就像它是在命令行中首先指定的一样。在一些把第一个文件当作入口点的系统上这个命令非常有效。

### 处理目标文件的指令

有两个链接器脚本命令可以用来处理对象文件格式：
```
OUTPUT_FORMAT(bfdname)
OUTPUT_FORMAT(default, big, little)
```

`OUTPUT_FORMAT` 命令使用BFD格式的命名方式。使用 `OUTPUT_FORMAT(bfdname)` 与在命令行上使用 `–oformat bfdname` 完全相同。如果两者都使用，则命令行选项优先。

您可以将OUTPUT_格式与三个参数一起使用，以根据 `-EB` 和 `-EL` 命令行选项使用不同的格式。这允许链接器脚本根据所需的endianness设置输出格式。

如果未使用 `-EB` 和 `-EL`，那么输出格式将会使用第一个参数作为默认值。如果使用 `-EB`，输出格式将是第二个参数 big。如果使用 `-EL`，输出格式将是第三个参数little。

例如，MIPS ELF目标的默认链接器脚本使用以下命令：
```
OUTPUT_FORMAT(elf32-bigmips, elf32-bigmips, elf32-littlemips)
```
这说明输出文件的默认格式是 `elf32-bigmips`，但如果用户使用`-EL`命令行选项，则将以`elf32-littlemips`格式创建输出文件。

```
TARGET(bfdname)
```
`TARGET`命令设置读取输入文件时的BFD格式。这将影响后面的`INPUT`和`GROUP`命令。此命令类似使用命令行指令`-b bfdname`。如果使用了`TARGET`命令，但`OUTPUT_FORMAT`命令没使用，则最后的`TARGET`命令还被用来设置输出文件的格式

### 为内存区域分配别名

可以为MEMORY命令创建的内存区域提供别名。每个名称最多对应一个存储区域

```
REGION_ALIAS(alias, region)
```

`REGION_ALIAS`函数为内存区域创建别名。它允许灵活地将输出部分映射到内存指定区域。下面有一个例子。

假设一个用于嵌入式系统的应用程序，它有各种内存存储设备。有一个通用的，易失性内存RAM，允许代码执行或数据存储。有一个只读的、非易失性内存ROM，允许代码执行和只读数据访问。最后一个是只读、非易失性存储器ROM2，允许对只读数据段读取，不允许代码执行。现在有四个输出段：
- `.text`：程序代码
- `.rodata`：只读数据
- `.data`：可读写且需要初始化数据
- `.bss`：可读写的置零初始化数据
目标是提供一个链接器脚本文件，该文件包含定义系统无关的输出段的部分，和将输出段映射到系统上可用内存区域的系统相关部分。我们的嵌入式系统有三种不同的内存设置A、B和C：
```
Section	Variant A	Variant B	Variant C
.text	RAM	         ROM	    ROM
.rodata	RAM	         ROM	    ROM2
.data	RAM	         RAM/ROM	RAM/ROM2
.bss	RAM	         RAM	    RAM
```
RAM/ROM或RAM/ROM2表示将此段分别加载到区域ROM或ROM2中。请注意，三个设置的`.data`段的起始地址都位于`.rodata`段的末尾。

接下来是处理输出段的基本链接脚本。它依赖描述内存布局的系统相关链接文件: linkcmds.memory
```
INCLUDE linkcmds.memory
SECTIONS
{
    .text : 
    {
        *(.text)
    } > REGION_TEXT
    
    .rodata : 
    {
        *(.rodata)
        rodata_end = .;
    } > REGION_RODATA

    .data : AT (rodata_end) 
    {
        data_start = .;
        *(.data)
    } > REGION_DATA

    data_size = SIZEOF(.data);
    data_load_start = LOADADDR(.data);

    .bss : 
    {
        (.bss)
    } > REGION_BSS
}
```
现在我们需要三个不同的 linkcmds.memory 来定义内存区域以及别名。下面是A，B，C不同的 linkcmds.memory：
- A: 所有都存入RAM
    ```
    // A
    MEMORY
    {
        RAM : ORIGIN = 0, LENGTH = 4M
    }

    REGION_ALIAS("REGION_TEXT", RAM);
    REGION_ALIAS("REGION_RODATA", RAM);
    REGION_ALIAS("REGION_DATA", RAM);
    REGION_ALIAS("REGION_BSS", RAM);
    ```
- B: 代码和只读数据存入ROM。可读写数据放入RAM。一个已初始化了的数据的镜像被加载到ROM，并在系统启动的时候读入RAM
    ```
    MEMORY
    {
        ROM : ORIGIN = 0, LENGTH = 3M
        RAM : ORIGIN = 0x10000000, LENGTH = 1M
    }
    REGION_ALIAS("REGION_TEXT", ROM);
    REGION_ALIAS("REGION_RODATA", ROM);
    REGION_ALIAS("REGION_DATA", RAM);
    REGION_ALIAS("REGION_BSS", RAM);
    ```
- C: 代码放入ROM，只读数据放入ROM2。可读写数据放入RAM。一个已初始化了的数据的镜像被加载到ROM2，并在系统启动的时候读入RAM
    ```
    MEMORY
    {
        ROM : ORIGIN = 0, LENGTH = 2M
        ROM2 : ORIGIN = 0x10000000, LENGTH = 1M
        RAM : ORIGIN = 0x20000000, LENGTH = 1M
    }
    REGION_ALIAS("REGION_TEXT", ROM);
    REGION_ALIAS("REGION_RODATA", ROM2);
    REGION_ALIAS("REGION_DATA", RAM);
    REGION_ALIAS("REGION_BSS", RAM);
    ```
如有必要，可以编写通用的系统初始化程序以将.data段从ROM或ROM2复制到RAM：
```
#include <string.h>

extern char data_start [];
extern char data_size [];
extern char data_load_start [];

void copy_data(void)
{
    if (data_start != data_load_start) {
        memcpy(data_start, data_load_start, (size_t) data_size);
    }
}
```

### 其他链接脚本指令

#### ASSERT(exp, message)

注意此断言会在最终链接阶段之前进行检查。这表示，在段内使用PROVIDE的定义如果用户没有为其设置值，此表达式将无法通过检测。唯一的例外是PROVIDE的符号刚刚引用了`.`。因此，一个如下断言：

确保 exp 不为零。 如果为零，则退出链接并显示错误代码，并打印一些相关的信息。

请注意，在链接的最后阶段发生之前会检查断言。 这意味着，如果用户没有为这些符号设置值，则涉及段定义中提供的符号的表达式将失败。该规则的唯一例外是仅引用点的提供的符号。因此，这样的断言：
```
.stack :
{
    PROVIDE (__stack = .);
    PROVIDE (__stack_size = 0x100);
    ASSERT ((__stack > (_end + __stack_size)), "Error: No room left for the stack");
}
```

如果在其他地方没有定义`stack_size`，则会失败。在段外定义的符号会在此前被求值，可以在 PROVIDEd 使用它们，因此:
```
PROVIDE (__stack_size = 0x100);
.stack :
{
    PROVIDE (__stack = .);
    ASSERT ((__stack > (_end + __stack_size)), "Error: No room left for the stack");
}
```

#### EXTERN(symbol symbol …)

强制将符号作为未定义符号输入到输出文件中。这样做可能会触发标准库中其他模块的链接。您可以为每个 EXTERN 列出几个符号，并且可以多次使用 EXTERN。 此命令与 ‘-u’ 命令行选项具有相同的作用。

#### FORCE_COMMON_ALLOCATION

这个命令与’-d’ 命令行选项具有相同的效果:即便是使用了’-r’ 的重定位输出文件，也让 ld 为普通符号分配空间。

#### INHIBIT_COMMON_ALLOCATION

这个命令与命令行选项 ‘–no-define-common’ 具有相同的效果: 让 ld 不为普通符号分配空间，即便是一个非可重定位输出文件。

#### FORCE_GROUP_ALLOCATION

这个命令与命令行选项 ‘–force-group-allocation’ 具有相同的效果: 使ld place 段组成员像普通的输入段一样，并且即使指定了可重定位的输出文件(’-r')也可以删除段组。

#### INSERT [AFTER|BEFORE] output_section

此命令通常在‘-T’ 指定的脚本中使用，用来增强默认的SECTIONS。例如，重复占位程序段。它将把所有此前的链接脚本的声明插入`output_section`的后面（或者前面），并且使 ’-T’不要覆盖默认链接脚本。实际插入点类似于孤儿段。插入发生在链接器把输入段映射到输出段后。在插入前，因为’-T’的脚本在默认脚本之前被解析，在’-T’脚本中的声明会先于默认内部脚本的声明而执行。特别是，将对默认脚本中的’-T’输出段进行输入段分配。下例为’-T’脚本使用INSERT可能的情况：
```
SECTIONS
{
    OVERLAY :
    {
        .ov1 { ov1*(.text) }
        .ov2 { ov2*(.text) }
    }
}
INSERT AFTER .text;
```

#### NOCROSSREFS(section section …)

此命令可能被用来告诉 ld，如果引用了section的参数就报错。

在特定的程序类型中，比如使用覆盖技术的嵌入式系统，当一个段被加载到内存中，另一个段不会被加载。任何两个段之间直接的引用都会带来错误。例如，如果一个段中的代码调用另一个段中的函数，将会产生错误。

NOCROSSREFS 命令列出了一系列输出段的名字。如果ld检测到任何段间交叉引用，将会报告错误并返回非零退出码。注意NOCROSSREFS使用输出段名称，而不是输入段名称。

#### NOCROSSREFS_TO(tosection fromsection …)

此命令可能被用来告诉 ld，从其他段列表中对某个段的任何引用就会引发错误。
当需要确保两个或多个输出段完全独立，但是在某些情况下需要单向依赖时，NOCROSSREFS 命令很有用。例如，在多核应用程序中，可能存在可以从每个核调用的共享代码，但是出于安全考虑，绝不能回调。

`NOCROSSREFS_TO`命令携带(给出)输出段名称的列表。其他任何部分都不能引用第一部分。 如果 ld 从其他任何部分中检测到对第一部分的任何引用，它将报告错误并返回非零退出状态。请注意，`NOCROSSREFS_TO`命令使用输出段名称，而不是输入段名称。

#### OUTPUT_ARCH(bfdarch)

指定一个特定的输出机器架构。该参数是BFD库使用的名称之一。通过使用带有 ’-f’ 选项的objdump程序，您可以看到目标文件的体系结构。

#### LD_FEATURE(string)

此命令可用于修改 ld 行为。如果字符串是`SANE_EXPR`，那么脚本中的绝对符号和数字将被在任何地方当作数字对待。

## 给符号赋值

可以给链接器脚本中的符号赋值。这会定义符号并将其放入具有全局作用域的符号表中。

### 简单赋值

可以使用任何C赋值操作符来赋值符号:

```
symbol = expression ;
symbol += expression ;
symbol -= expression ;
symbol *= expression ;
symbol /= expression ;
symbol <<= expression ;
symbol >>= expression ;
symbol &= expression ;
symbol |= expression ;
```

第一种情况将表达式的值赋值给符号。在其他情况下，必须先定义符号，并相应地调整符号的值。
特殊符号名称`.` 表示位置计数器。您只能在 `SECTIONS` 命令中使用它。

表达式后面的分号不能省略。
表达式定义如下
你在写表达式赋值语句时，可以把它们作为单独的部分,也可以作为 `SECTIONS` 命令中的一个语句，或者作为 `SECTIONS` 命令中输出段描述的一个部分。

符号的有效作用区域由表达式所在的段决定

下面是是三个不同位置为符号赋值的示例：

```
floating_point = 0;
SECTIONS
{
    .text :
    {
        *(.text)
        _etext = .;
    }
    _bdata = (. + 3) & ~ 3;
    .data : { *(.data) }
}
```

在本例中，符号 `floating_point` 将被定义为零。符号 `_etext` 将被设置为紧随 `.text` 最后一个输入段后面的地址。符号`_bdata`将被定义为在 `.text` 输出段后面的一个4字节向上对齐的地址。

### HIDDEN

语法HIDDEN(symbol = expression)为ELF目标的端口定义一个符号，符号将被隐藏并且不会被导出。
下面是简单赋值例子，使用HIDDEN重写：

```
HIDDEN(floating_point = 0);
SECTIONS
{
    .text :
    {
        *(.text)
        HIDDEN(_etext = .);
    }
    HIDDEN(_bdata = (. + 3) & ~ 3);
    .data : { *(.data) }
}
```

在本例中，这三个符号在此模块之外都不可见

### PROVIDE

在某些情况下，仅当一个符号被引用了却没有定义在任何链接目标中，才需要为链接脚本定义一个符号。例如，传统链接器定义了符号`etext`。然而，ANSI C要求用户能够使用`etext`作为函数名而不会引发错误。PROVIDE关键字可以用来定义一个符号，比如`etext`，只有当它被引用但没有被定义时才使用。语法是`PROVIDE(symbol = expression)`。

下面是一个使用提供定义`etext`的例子:

```
SECTIONS
{
    .text :
    {
        *(.text)
        _etext = .;
        PROVIDE(etext = .);
    }
}
```

在本例中，如果程序定义了`_etext`(带有前导下划线)，链接器将给出重复定义错误。另一方面，如果程序定义了`etext`(没有前导下划线)，链接器会默认使用程序中的定义。如果程序引用了`etext`但没有定义它，链接器将使用链接器脚本中的定义。

注意 -PROVIDE指令将考虑定义一个普通符号，即使这样的符号可以与PROVIDE将创建的符号组合在一起。当考虑构造函数和析构函数列表符号时，这一点尤其重要，因为它们通常被定义为普通符号。

### PROVIDE_HIDDEN

与 PROVIDE 类似。对于ELF目标的端口，符号将被隐藏且不会被输出。

### 源码

从源代码获取链接器脚本定义的变量并不直观。特别是，特别是链接脚本中的符号与高级语言定义的变量声明不同的时候，将使用一个没有值的变量替代它。

在进一步讨论之前，必须注意，当编译器将源代码中的名称存储在符号表中时，它们通常会将它们转换为不同的名称。例如，Fortran编译器通常在前面或后面加上下划线，而C++则执行大量的 ‘name mangling’。 因此，在源代码中使用的变量名称与在链接脚本中定义的相同变量的名称之间可能会有差异。例如，在C语言中，链接脚本变量可能称为：

```
extern int foo;
```

但是在链接器脚本中，它可能被定义为:

```
_foo = 1000;
```

然而，在其余的例子中，假设没有发生名称转换。

当一个符号用高级语言，比如C语言，声明了一个符号，会发生两件事。首先，编译器在程序内存中保留足够的空间来保存符号的值。第二种方法是编译器在程序的符号表中创建一个条目，用来保存符号的地址。例如下面的C声明：
```
int foo = 1000;
```

在符号表中创建一个名为’ foo '的条目。这个入口保存了一个‘int’ 大小的内存块的地址，数字1000最初存储在这里。

当程序引用一个符号时，编译器生成的代码首先访问符号表以查找该符号的内存块地址，然后代码从该内存块读取值。所以:

```
foo = 1;
```

在符号表中查找符号’ foo '，获取与该符号关联的地址，然后将值1写入该地址。而:

```
int * a = & foo;
```

在符号表中查找符号’ foo '，获取它的地址，然后将这个地址复制到与变量 ’ a ’ 相关联的内存块中。

相比之下，链接器脚本符号声明在符号表中创建一个条目，但不给它们分配任何内存。因此，它们是一个没有值的地址。例如链接器脚本定义:

```
foo = 1000;
```

在符号表中创建一个名为’ foo '的条目，该条目保存内存位置1000的地址，但地址1000上没有存储任何特殊内容。这意味着您无法访问链接程序脚本定义的符号的值-它没有值。您所能做的就是访问链接器脚本定义符号的地址。

因此，当您在源代码中使用链接器脚本定义的符号时，您应该始终获取该符号的地址，并且永远不要尝试使用它的值。例如，假设你想把内存的 .ROM 拷贝到 .FLASH 中，链接器脚本包含了这些声明:
```
start_of_ROM   = .ROM;
end_of_ROM     = .ROM + sizeof (.ROM);
start_of_FLASH = .FLASH;
```

那么执行复制的C源代码为:

```
extern char start_of_ROM, end_of_ROM, start_of_FLASH;
memcpy (& start_of_FLASH, & start_of_ROM, & end_of_ROM - & start_of_ROM);
```

注意 ‘&’ 运算符的使用。上面是正确的代码。一种替换是，把符号被当作一个数组变量的名称，因此代码变成了：
```
extern char start_of_ROM[], end_of_ROM[], start_of_FLASH[];
memcpy (start_of_FLASH, start_of_ROM, end_of_ROM - start_of_ROM);
```

注意此时不需要操作符 ’&’ 了。

## SECTIONS指令

SECTIONS 命令告诉链接器如何将输入段映射到输出段，以及如何将输出段放在内存中。
SECTIONS 命令的格式为:
```
SECTIONS
{
    sections-command
    sections-command
    …
}
```

每个 sections-command 命令可能是下面之一：
- ENTRY 命令
- 符号赋值
- 输出段的描述
- overlay描述

为了方便在这些命令中使用位置计数器，在SECTIONS 命令中允许使用 ENTRY 命令和符号赋值。 这也可以使链接描述文件更容易理解，因为你可以在更有意义的地方使用这些命令来控制输出文件的布局。

输出段描述和覆盖在下面将会分析。

如果在链接脚本中未使用 SECTIONS 命令，则链接器将会照输入文本的顺序，将每个输入部段放置到名称相同的输出段中。例如，如果所有输入段出现在第一个文件中，输出文件的段的顺序将会与第一个输入文件保持一致。第一个段被放在地址0。

### 输出Section描述

```
section [address] [(type)] :
  [AT(lma)]
  [ALIGN(section_align) | ALIGN_WITH_INPUT]
  [SUBALIGN(subsection_align)]
  [constraint]
  {
    output-section-command
    output-section-command
    ...
  } [>region] [AT>lma_region] [:phdr :phdr ...] [=fillexp] [,]
```

大部分的可选段属性在多数输出段不需要使用。

SECTION 边上的空格是必须的，这样段名就没有歧义了。冒号和花括号也是必需的。如果使用了fillexp，并且下一个section -命令看起来像是表达式的延续，则可能需要在末尾使用逗号。换行符和其他空格是可选的。

当 fillexp 使用且接下来的 sections-command 看起来像是表达式的延续的时候，可能需要在后面加上逗号。

每个 output-section-command 可以是下列命令之一:
- 符号赋的值
- 输入段描述
- 直接包引用的数据值
- 特殊的输出段关键字

### 输出段名

输出段的名字是 section 。section必须满足输出格式的规定。在只支持有限段数目的格式中，例如`a.out`，名称必须是该格式所支持的名称之一(例如a.out，只允许`.text`，`.data`，`.bss`)。如果输出格式支持任意数量的段，但是只有数字而不是名称(Oasys 就是这种情况)，则名称应该以带引号的数字字符串的形式提供。一个段的名字可以由任意字符序列组成，但一个含有许多特殊字符(如逗号)的名称必须用引号括起来。

名称为 ‘/DISCARD/’ 的输出段

### 输出段地址

address 是输出段VMA（虚拟内存地址）的表达式。此地址是可选参数，但如果提供了该地址，则输出地址就会被精确的设置为指定的值。

如果没有指定输出地址，那么则依照下面的几种方式尝试选择一个地址。此地址将被调整以适应输出段的对齐要求。输出段的对齐要求是所有输入节中含有的对齐要求中最严格的一个。

输出段地址探索如下：
- 如果为该段设置了一个输出内存区域，那么它将被添加到该区域中，其地址将是该区域中的下一个空闲地址。
- 如果使用 MEMORY 命令创建内存区域列表，那么将选择具有与该段兼容属性的第一个区域来包含该区域。该部分的输出地址将是该区域中的下一个空闲地址；MEMORY 。
- 如果没有指定内存区域，或者没有与段匹配的内存区域，则输出地址将基于位置计数器的当前值。

例如:

```
.text . : { *(.text) }
```
和
```
.text : { *(.text) }
```

有着细微的不同。 第一个将‘.text’ 输出段的地址设置为位置计数器的当前值。 第二个参数会将其设置为位置计数器的当前值，但是该值与所有‘.text’ 输入段中最严格的对齐方式对齐。

address 可以是任意表达式； 例如，如果要在0x10字节(16字节)边界上对齐段，以使节地址的最低四位为零，则可以执行以下操作：
```
.text ALIGN(0x10) : { *(.text) }
```

之所以这样做，是因为 ALIGN 返回的当前位置计数器向上对齐到指定的值。
为段指定地址将会改变位置计数器的值，前提是该段是非空的(空的段被忽略)。

### 输入段描述


