# 大内核锁

BKL本质上是一个递归自旋锁，由自旋锁和锁深度变量组成。

- 自旋锁：定义在`lib/kernel_lock.c`中，使用`DEFINE_SPINLOCK(kernel_flag)`实现
- 锁深度变量：存储在`struct task_struct`的`lock_depth`字段中，支持递归获取锁（避免死锁）

历史背景：BKL起源于早期Linux内核（单处理器时代），用于简化多处理器同步问题。随着内核发展，其粗粒度锁机制导致性能瓶颈，逐渐被细粒度锁（如自旋锁、RCU）取代
调度兼容性：BKL在调用`schedule()`时会自动释放，重新调度时需通过`reacquire_kernel_lock()`重新获取，这种特性使其使用复杂且隐蔽

## API

```c
// 获取大内核锁，支持递归调用，适用于保护全局内核资源（如初始化代码）
lock_kernel(void);

// 释放大内核锁，需与lock_kernel()配对使用，调用次数需严格匹配
unlock_kernel(void);
```

典型应用场景：
- 内核初始化阶段：保护全局数据结构的初始化过程
- 设备驱动注册：确保设备注册表的一致性（如USB子系统）

通过上述机制，BKL在历史场景中提供了简单的全局同步能力，但其设计缺陷使其逐渐成为性能瓶颈。现代内核开发中应优先选择更高效的同步原语
