# 顺序锁

通过版本号机制实现无锁读，写操作时递增版本号。适用于读操作远多于写且允许短暂数据不一致的场景

## 定义

```c
typedef struct
{
    /**
     * Make sure that readers don't starve writers on PREEMPT_RT: use
     * seqcount_spinlock_t instead of seqcount_t. Check __SEQ_LOCK().
     */
    seqcount_spinlock_t seqcount; // 序列号计数器
    spinlock_t          lock;     // 自旋锁(仅用于写操作互斥)
} seqlock_t;
```

序列号机制：写操作时序列号递增两次（进入临界区时+1，退出时+1），读操作通过比较序列号变化判断数据是否被修改

自旋锁：仅用于保护写操作的互斥，避免写写冲突

## API

```
write_seqlock(sl)	获取写锁（进入临界区前调用）
write_sequnlock(sl)	释放写锁（退出临界区后调用）
read_seqbegin(sl)	读取当前序列号并进入临界区，若序列号为奇数则自旋等待至偶数
read_seqretry(sl, start)	检查退出临界区时序列号是否变化，若变化则返回1（需重读）
```

工作原理：
- 写操作：
	- 获取自旋锁（spin_lock(&sl->lock)）。
	- 序列号+1（进入临界区时）。
	- 执行写操作。
	- 序列号+1（退出临界区时）。
	- 释放自旋锁（spin_unlock(&sl->lock)）。
	- 写操作期间序列号始终为奇数，读操作需等待序列号变为偶数
- 读操作：
	- 调用read_seqbegin()获取当前序列号。
	- 读取数据。
	- 调用read_seqretry()检查序列号是否变化：
	- 若未变化，数据有效，退出循环。
	- 若变化，数据可能被修改，需重读
应用场景：
- 时钟更新：中断处理程序（写操作）更新时钟，用户态程序（读操作）通过gettimeofday()读取时间，避免阻塞中断。
- 中断处理：写操作优先于读操作，如设备状态寄存器的更新与读取。
- 统计类数据：读多写少且允许短暂不一致的场景（如CPU使用率统计）

注意事项：
- 资源类型：保护的数据不能是指针，否则写操作可能导致指针失效，读操作访问野指针。
- 性能限制：写操作需频繁修改序列号，若写操作频繁，性能可能下降。
- 适用性：仅适用于读多写少且写操作优先的场景，否则可能引发读操作频繁重试
