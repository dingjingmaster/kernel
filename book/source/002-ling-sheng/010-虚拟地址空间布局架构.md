# 虚拟地址空间布局架构

## 内存管理架构

内存管理子系统架构可以分为：用户空间、内核空间以及硬件部分3个层面，具体结构如下：
- 用户空间：引用程序使用malloc()申请资源，通过free()释放资源
- 内核空间：内核总是驻留在内存中，是操作系统的一部分，内核空间为内核保留，不允许引用程序读写该区域的内容或直接调用内核代码定义的函数
- 硬件：处理器包含一个内存管理单元（Memory Management Uint, MMU）的部件，负责把虚拟地址转换为物理地址

虚拟内存管理
- 页错误异常处理
- 页表管理

虚拟内存管理————内存分配器(内核)
```
+----------+--------+--------------+------------------+--------------+
| 引导内存 |块分配器|不连续页分配器|每处理器内存分配器|连续内存分配器|
| 分配器   +--------+--------------+------------------+--------------+
|          |                      页分配器                           |
+----------+---------------------------------------------------------+

内存碎片整理、内存耗尽、内存控制组、页回收
```

硬件层
```
+--------------------------------------------+
| 硬件 +-------------------+                 |
|      | 处理器            |    +----------+ |
|      | +--------------+  |    | 物理内存 | |
|      | | 内存管理单元 |  |    +----------+ |
|      | | +----------+ |  |                 |
|      | | | 页表缓存 | |  |                 |
|      | | +----------+ |  |                 |
|      | +--------------+  |                 |
|      |                   |                 |
|      | +--------------+  |                 |
|      | |     缓存     |  |                 |
|      | +--------------+  |                 |
+--------------------------+-----------------+
```

### 系统调用

```
+-------------------------------+
|    malloc/free、new/delete    |
+-------------------------------+
               | 系统调用
              \|/
+-------------------------------+
| 内核与应用层接口：            |
| sbrk()/brk()或mmap()/munmap() |
+-------------------------------+
               |内核层
              \|/
+-------------------------------+
|      kmalloc/vmalloc          |
+-------------------------------+
```

### 用户空间
程序调用malloc时候，实际使用了glibc提供的内存分配器 ptmalloc 提供的接口。使用系统调用brk或mmap项内核以页为单位申请内存，然后进行分成很小的内存块，给到对应的引用程序。

### 内核空间

虚拟内存管理器负责从进程的虚拟地址空间分配虚拟页，sys_brk来扩大或收缩堆，sys_mmap用来在内存映射区分配虚拟页，sys_munmap来释放虚拟页。页分配器负责分配物理页，使用的分配器是伙伴分配器。

内核空间扩展功能：不连续页分配器提供内存的接口vmalloc和释放内存接口vfree。在内存碎片化的时候，申请连续物理页的成功率比较低，可以申请不连续的物理页，映射到连续的虚拟页，即虚拟地址连续而物理地址不连续。

内存控制组用来控制进程占用的内存资源。当内存碎片化的时候，找不到连续的物理页，内存碎片整理通过迁移方式得到连续的物理页，在内存不足的时候，页回收负责回收物理页。

### 硬件

CPU中有MMU，MMU中包含一个页表缓存，保存最近使用过的页表映射，避免每次把虚拟地址转换为物理地址都需要查询内存中的页表。解决处理器执行速度和内存速度不匹配问题，中间增加一个缓存。一级缓存分为数据缓存和指令缓存。二级缓存作用是协调一级缓存和内存之间工作效率的。


## 虚拟地址空间布局

用户虚拟地址空间划分：起始位置是0，长度是：TASK_SIZE，32位是4GB，64位2^{VA_BITS}字节

用户虚拟地址空间包含区域：代码段、数据段、未初始化数据段、动态库代码段、数据段和未初始化数据段、动态生成的数据的堆、局部变量和实现函数调用的栈、文件区间映射到虚拟地址空间的内存映射区域、存放在栈底部的环境变量和参数字符串

内核使用内存描述符 mm_struct描述进程的用户虚拟地址空间，内核源码：include/linux/mm_types.h

一个进程的虚拟地址空间主要是由两个数据结构进行描述。一个是最高层次的mm_struct，较高层次的vm_area_struct，都在include/linux/mm_types.h文件中定义

mm_struct结构描述一个进程整个虚拟地址空间

vm_struct结构描述虚拟地址空间的区间（虚拟区）

每个进程只有一个mm_struct结构，在每个进程的task_struct结构中有一个专门用来指向该进程的结构。

```
task_struct --> mm_struct
```

## 内核地址空间布局

内核空间布局 include/linux/memory.h
